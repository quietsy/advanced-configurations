{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#containers","title":"Containers","text":"<ul> <li>Awesome LSIO</li> <li>Consolidating Proxies</li> <li>DNS for Containers</li> <li>Optimizing Nextcloud</li> <li>Piped</li> <li>Searx</li> <li>Securing SWAG</li> <li>Simplelogin</li> <li>SOCKS Proxy</li> <li>VPN Hub</li> <li>VPN Route</li> <li>VPS Proxy</li> <li>YAML Anchors</li> </ul>"},{"location":"#network","title":"Network","text":"<ul> <li>Asus VLANs</li> <li>OPN-Arp</li> <li>Hardcoded DNS</li> <li>Split DNS</li> <li>Split Tunnel</li> <li>Firehol</li> <li>Geoblock</li> </ul>"},{"location":"#other","title":"Other","text":"<ul> <li>Setup Template</li> <li>Phone</li> <li>Atuin</li> <li>Brave</li> <li>Tmux</li> <li>Smartd</li> <li>ZFS</li> </ul>"},{"location":"asus-vlans/","title":"Turning an Asus Router to a VLAN aware Access Point","text":""},{"location":"asus-vlans/#reasons-for-using-an-asus-router","title":"Reasons for using an Asus router","text":"<ul> <li>Not cloud connected</li> <li>Doesn't require a controller</li> <li>Supports mesh, wpa3</li> <li>Cheap for a 2x2 Wi-Fi 6 AP with 5 LAN ports and VLAN support</li> <li>Can act as a backup router if needed</li> <li>Has a great community around it with asus-merlin</li> </ul>"},{"location":"asus-vlans/#steps","title":"Steps","text":"<p>Tested on the Asus RT-AX58U but could work on any asus-merlin router.</p> <ul> <li>Install Asus-Merlin on the router</li> <li>Set the router to AP mode</li> <li>Enable Administration &gt; System &gt; Enable JFFS custom scripts and configs</li> <li>Set the router to a static IP instead of DHCP</li> <li>Create all needed guest networks, in this example there will be Guest 2.5Ghz and Guest 5Ghz</li> <li>Save the script to <code>/jffs/scripts/services-start</code> after it's done</li> <li>Set <code>chmod a+x /jffs/scripts/services-start</code></li> <li>Reboot the router to apply changes</li> </ul>"},{"location":"asus-vlans/#discovery","title":"Discovery","text":"<p>Before editing the script we need to figure out the interface names, disconnect all ethernet cables except one and run <code>ip a</code> to check which interface is UP, keep switching between ports and running  <code>ip a</code> to map all ports.</p> <p>For example:</p> <ul> <li>eth0 - LAN 1</li> <li>eth1 - LAN 2</li> <li>eth2 - LAN 3</li> <li>eth3 - LAN 4</li> <li>eth4 - WAN</li> <li>eth5 - Main wifi 2.4Ghz</li> <li>eth6 - Main wifi 5Ghz</li> <li>wl0.1 - Guest wifi 2.4Ghz</li> <li>wl1.1 - Guest wifi 5Ghz</li> </ul>"},{"location":"asus-vlans/#script","title":"Script","text":"<p>The following script assumes the layout above and creates 2 VLANs:</p> <ol> <li>227 - LAN ports 1-4, Main wifi 2.5Ghz, Main wifi 5Ghz</li> <li>11 (with client isolation) - Guest wifi 2.5Ghz, Guest wifi 5Ghz</li> </ol> <p>Change the script according to your router model's layout and needs.</p> <pre><code>#!/bin/sh\n\nbrctl delif br0 eth4\nbrctl delif br0 wl0.1\nbrctl delif br0 wl1.1\nip link add link eth4 name eth4.227 type vlan id 227\nip link add link eth4 name eth4.11 type vlan id 11\nip link set eth4.227 up\nip link set eth4.11 up\nbrctl addif br0 eth4.227\nbrctl addbr br1\nbrctl addif br1 eth4.11\nbrctl addif br1 wl0.1\nbrctl addif br1 wl1.1\nip link set br1 up\nnvram set lan_ifnames=\"eth0 eth1 eth2 eth3 eth5 eth6 eth4.227\"\nnvram set lan1_ifnames=\"wl0.1 wl1.1 eth4.11\"\nnvram set lan1_ifname=\"br1\"\nnvram set br0_ifnames=\"eth0 eth1 eth2 eth3 eth5 eth6 eth4.227\"\nnvram set br1_ifnames=\"wl0.1 wl1.1 eth4.11\"\nnvram set br1_ifname=\"br1\"\nnvram set wl0.1_ap_isolate=\"1\"\nnvram set wl1.1_ap_isolate=\"1\"\nkillall eapd\neapd\nethswctl -c hw-switch\n</code></pre>"},{"location":"asus-vlans/#recovery","title":"Recovery","text":"<p>If the router doesn't boot after making the changes, you can revert it to factory defaults on most models by following these steps:</p> <ol> <li>Power off the router</li> <li>Hold the WDS button on the back</li> <li>Turn the router on while still holding the WDS button</li> <li>Wait for the power led to turn off</li> <li>Reboot the router normally</li> </ol>"},{"location":"atuin/","title":"Atuin","text":"<p>Atuin replaces your existing shell history with a SQLite database, and records additional context for your commands. With this context, Atuin gives you faster and better search of your shell history.</p> <p>Atuin also syncs your shell history between all of your machines. Fully end-to-end encrypted.</p>"},{"location":"atuin/#server","title":"Server","text":"<p>Change the version to the latest.</p> <pre><code>  atuin:\n    image: ghcr.io/atuinsh/atuin:v18.1.0\n    container_name: atuin\n    user: \"${PUID}:${PGID}\"\n    command: server start\n    environment:\n      ATUIN_HOST: \"0.0.0.0\"\n      ATUIN_OPEN_REGISTRATION: \"true\"\n      ATUIN_DB_URI: postgres://${MYUSER}:${MYPASSWORD}@atuindb/atuin\n    volumes:\n      - \"${APPSDIR}/atuin/config:/config\"\n    restart: always\n  atuindb:\n    image: postgres:14-alpine\n    container_name: atuindb\n    user: \"${PUID}:${PGID}\"\n    environment:\n      POSTGRES_USER: ${MYUSER}\n      POSTGRES_PASSWORD: ${MYPASSWORD}\n      POSTGRES_DB: atuin\n    volumes:\n      - ${APPSDIR}/atuin/db:/var/lib/postgresql/data\n    restart: always\n</code></pre>"},{"location":"atuin/#client-installation","title":"Client Installation","text":""},{"location":"atuin/#linux","title":"Linux","text":"<pre><code>bash &lt;(curl --proto '=https' --tlsv1.2 -sSf https://setup.atuin.sh)\n</code></pre>"},{"location":"atuin/#termux","title":"Termux","text":"<pre><code>pkg install atuin\n</code></pre>"},{"location":"atuin/#opnsense","title":"OPNSense","text":"<p>Enable the freebsd repo in <code>/usr/local/etc/pkg/repos/FreeBSD.conf</code> and run:</p> <pre><code>pkg update\npkg install atuin\n</code></pre>"},{"location":"atuin/#configuration","title":"Configuration","text":"<p>Run:</p> <pre><code>echo 'eval \"$(atuin init zsh)\"' &gt;&gt; ~/.zshrc\natuin gen-completions --shell zsh --out-dir $HOME\n</code></pre> <p>Edit <code>~/.config/atuin/config.toml</code>:</p> <pre><code>dialect = \"uk\"\nauto_sync = true\nupdate_check = true\nsync_address = \"https://atuin.domain.com\"\nsync_frequency = \"0\"\nfilter_mode = \"global\"\nworkspaces = true\nfilter_mode_shell_up_key_binding = \"host\"\nstyle = \"compact\"\nenter_accept = true\n\n[sync]\nrecords = true\n</code></pre>"},{"location":"atuin/#initialization","title":"Initialization","text":"<pre><code>atuin register -u &lt;USERNAME&gt; -e &lt;EMAIL&gt;\natuin import auto\natuin sync -f\n</code></pre>"},{"location":"atuin/#new-machine","title":"New Machine","text":"<pre><code>atuin login -u &lt;USERNAME&gt;\natuin import auto\natuin sync -f\n</code></pre>"},{"location":"atuin/#usage","title":"Usage","text":"<p>Atuin documentation</p>"},{"location":"awesome-lsio/","title":"Awesome LSIO","text":""},{"location":"awesome-lsio/#administration","title":"Administration","text":"Container Description doublecommander Double Commander is a free cross platform open source file manager with two panels side by side. It is inspired by Total Commander and features some new ideas. endlessh endlessh is an SSH tarpit that very slowly sends an endless, random SSH banner. It keeps SSH clients locked up for hours or even days at a time. The purpose is to put your real SSH server on another port and then let the script kiddies get stuck in this tarpit instead of bothering a real server. ldap-auth ldap-auth software is for authenticating users who request protected resources from servers proxied by nginx. It includes a daemon (ldap-auth) that communicates with an authentication server, and a webserver daemon that generates an authentication cookie based on the user\u2019s credentials. The daemons are written in Python for use with a Lightweight Directory Access Protocol (LDAP) authentication server (OpenLDAP or Microsoft Windows Active Directory 2003 and 2012). netbootxyz netbootxyz is a way to PXE boot various operating system installers or utilities from one place within the BIOS without the need of having to go retrieve the media to run the tool. iPXE is used to provide a user friendly menu from within the BIOS that lets you easily choose the operating system you want along with any specific types of versions or bootable flags. netbox netbox is an IP address management (IPAM) and data center infrastructure management (DCIM) tool. Initially conceived by the network engineering team at DigitalOcean, NetBox was developed specifically to address the needs of network and infrastructure engineers. It is intended to function as a domain-specific source of truth for network operations. openssh-server openssh-server is a sandboxed environment that allows ssh access without giving keys to the entire server. snipe-it snipe-it makes asset management easy. It was built by people solving real-world IT and asset management problems, and a solid UX has always been a top priority. Straightforward design and bulk actions mean getting things done faster."},{"location":"awesome-lsio/#audiobooks","title":"Audiobooks","text":"Container Description booksonic-air booksonic-air is a platform for accessing the audiobooks you own wherever you are. At the moment the platform consists of"},{"location":"awesome-lsio/#automation","title":"Automation","text":"Container Description domoticz domoticz is a Home Automation System that lets you monitor and configure various devices like: Lights, Switches, various sensors/meters like Temperature, Rain, Wind, UV, Electra, Gas, Water and much more. Notifications/Alerts can be sent to any mobile device. habridge habridge emulates Philips Hue API to other home automation gateways such as an Amazon Echo/Dot Gen 1 (gen 2 has issues discovering ha-bridge) or other systems that support Philips Hue. The Bridge handles basic commands such as \"On\", \"Off\" and \"brightness\" commands of the hue protocol. This bridge can control most devices that have a distinct API. homeassistant Home Assistant Core - Open source home automation that puts local control and privacy first. Powered by a worldwide community of tinkerers and DIY enthusiasts. Perfect to run on a Raspberry Pi or a local server. kanzi kanzi, formerly titled Kodi-Alexa, this custom skill is the ultimate voice remote control for navigating Kodi. It can do anything you can think of (100+ intents).  This container also contains lexigram-cli to setup Kanzi with an Amazon Developer Account and automatically deploy it to Amazon."},{"location":"awesome-lsio/#backup","title":"Backup","text":"Container Description duplicati duplicati works with standard protocols like FTP, SSH, WebDAV as well as popular services like Microsoft OneDrive, Amazon Cloud Drive &amp; S3, Google Drive, box.com, Mega, hubiC and many others. resilio-sync resilio-sync (formerly BitTorrent Sync) uses the BitTorrent protocol to sync files and folders between all of your devices. There are both free and paid versions, this container supports both. There is an official sync image but we created this one as it supports user mapping to simplify permissions for volumes. rsnapshot rsnapshot is a filesystem snapshot utility based on rsync. rsnapshot makes it easy to make periodic snapshots of local machines, and remote machines over ssh. The code makes extensive use of hard links whenever possible, to greatly reduce the disk space required.\" syncthing syncthing replaces proprietary sync and cloud services with something open, trustworthy and decentralized. Your data is your data alone and you deserve to choose where it is stored, if it is shared with some third party and how it's transmitted over the Internet."},{"location":"awesome-lsio/#books","title":"Books","text":"Container Description calibre calibre is a powerful and easy to use e-book manager. Users say it\u2019s outstanding and a must-have. It\u2019ll allow you to do nearly everything and it takes things a step beyond normal e-book software. It\u2019s also completely free and open source and great for both casual users and computer experts. calibre-web calibre-web is a web app providing a clean interface for browsing, reading and downloading eBooks using an existing Calibre database.   It is also possible to integrate google drive and edit metadata and your calibre library through the app itself. cops cops by S\u00e9bastien Lucas, stands for Calibre OPDS (and HTML) Php Server. lazylibrarian lazylibrarian is a program to follow authors and grab metadata for all your digital reading needs. It uses a combination of Goodreads Librarything and optionally GoogleBooks as sources for author info and book info.  This container is based on the DobyTang fork. mylar3 mylar3 is an automated Comic Book downloader (cbr/cbz) for use with NZB and torrents written in python. It supports SABnzbd, NZBGET, and many torrent clients in addition to DDL. readarr readarr - Book Manager and Automation (Sonarr for Ebooks) ubooquity ubooquity is a free, lightweight and easy-to-use home server for your comics and ebooks. Use it to access your files from anywhere, with a tablet, an e-reader, a phone or a computer."},{"location":"awesome-lsio/#cloud","title":"Cloud","text":"Container Description nextcloud nextcloud gives you access to all your files wherever you are."},{"location":"awesome-lsio/#crypto","title":"Crypto","text":"Container Description gmail-order-bot gmail-order-bot - A bot used to leverage a Gmail account as an order messaging service to consume email orders from Nano Checkout and process them using any custom logic you choose. nano nano is a digital payment protocol designed to be accessible and lightweight, with a focus on removing inefficiencies present in other cryptocurrencies. With ultrafast transactions and zero fees on a secure, green and decentralized network, this makes Nano ideal for everyday transactions. nano-discord-bot nano-discord-bot - A bot used to hook into a self hosted Nano RPC endpoint and discord server to Distribute funds from a faucet account. nano-wallet nano-wallet is a digital payment protocol designed to be accessible and lightweight, with a focus on removing inefficiencies present in other cryptocurrencies. With ultrafast transactions and zero fees on a secure, green and decentralized network, this makes Nano ideal for everyday transactions."},{"location":"awesome-lsio/#dns","title":"DNS","text":"Container Description adguardhome-sync adguardhome-sync is a tool to synchronize AdGuardHome config to replica instances. ddclient ddclient is a Perl client used to update dynamic DNS entries for accounts on Dynamic DNS Network Service Provider. It was originally written by Paul Burry and is now mostly by wimpunk. It has the capability to update more than just dyndns and it can fetch your WAN-ipaddress in a few different ways. duckdns duckdns is a free service which will point a DNS (sub domains of duckdns.org) to an IP of your choice. The service is completely free, and doesn't require reactivation or forum posts to maintain its existence."},{"location":"awesome-lsio/#dashboard","title":"Dashboard","text":"Container Description heimdall heimdall is a way to organise all those links to your most used web sites and web applications in a simple way. muximux muximux is a lightweight portal to view &amp; manage your HTPC apps without having to run anything more than a PHP enabled webserver. With Muximux you don't need to keep multiple tabs open, or bookmark the URL to all of your apps."},{"location":"awesome-lsio/#databases","title":"Databases","text":"Container Description mariadb mariadb is one of the most popular database servers. Made by the original developers of MySQL. mysql-workbench MySQL Workbench is a unified visual tool for database architects, developers, and DBAs. MySQL Workbench provides data modeling, SQL development, and comprehensive administration tools for server configuration, user administration, backup, and much more. phpmyadmin phpmyadmin is a free software tool written in PHP, intended to handle the administration of MySQL over the Web. phpMyAdmin supports a wide range of operations on MySQL and MariaDB. sqlitebrowser DB Browser for SQLite is a high quality, visual, open source tool to create, design, and edit database files compatible with SQLite."},{"location":"awesome-lsio/#docker","title":"Docker","text":"Container Description docker-compose No description fleet fleet provides an online web interface which displays a set of maintained images from one or more owned repositories."},{"location":"awesome-lsio/#documents","title":"Documents","text":"Container Description libreoffice LibreOffice is a free and powerful office suite, and a successor to OpenOffice.org (commonly known as OpenOffice). Its clean interface and feature-rich tools help you unleash your creativity and enhance your productivity. paperless-ng paperless-ng is an application by Daniel Quinn and contributors that indexes your scanned documents and allows you to easily search for documents and store metadata alongside your documents.\" paperless-ngx paperless-ngx is an application by Daniel Quinn and contributors that indexes your scanned documents and allows you to easily search for documents and store metadata alongside your documents.\" papermerge papermerge is an open source document management system (DMS) primarily designed for archiving and retrieving your digital documents. Instead of having piles of paper documents all over your desk, office or drawers - you can quickly scan them and configure your scanner to directly upload to Papermerge DMS.\""},{"location":"awesome-lsio/#downloaders","title":"Downloaders","text":"Container Description deluge deluge is a lightweight, Free Software, cross-platform BitTorrent client. nntp2nntp nntp2nntp proxy allow you to use your NNTP Account from multiple systems, each with own user name and password. It fully supports SSL and you can also limit the access to proxy with SSL certificates. nntp2nntp proxy is very simple and pretty fast. nzbget nzbget is a usenet downloader, written in C++ and designed with performance in mind to achieve maximum download speed by using very little system resources. pyload-ng pyLoad is a Free and Open Source download manager written in Python and designed to be extremely lightweight, easily extensible and fully manageable via web. qbittorrent The qbittorrent project aims to provide an open-source software alternative to \u00b5Torrent. qBittorrent is based on the Qt toolkit and libtorrent-rasterbar library. sabnzbd sabnzbd makes Usenet as simple and streamlined as possible by automating everything we can. All you have to do is add an .nzb. SABnzbd takes over from there, where it will be automatically downloaded, verified, repaired, extracted and filed away with zero human interaction. transmission transmission is designed for easy, powerful use. Transmission has the features you want from a BitTorrent client: encryption, a web interface, peer exchange, magnet links, DHT, \u00b5TP, UPnP and NAT-PMP port forwarding, webseed support, watch directories, tracker editing, global and per-torrent speed limits, and more."},{"location":"awesome-lsio/#ftp","title":"FTP","text":"Container Description davos davos is an FTP automation tool that periodically scans given host locations for new files. It can be configured for various purposes, including listening for specific files to appear in the host location, ready for it to download and then move, if required. It also supports completion notifications as well as downstream API calls, to further the workflow. filezilla FIleZilla Client is a fast and reliable cross-platform FTP, FTPS and SFTP client with lots of useful features and an intuitive graphical user interface."},{"location":"awesome-lsio/#family","title":"Family","text":"Container Description babybuddy babybuddy is a buddy for babies! Helps caregivers track sleep, feedings, diaper changes, tummy time and more to learn about and predict baby's needs without (as much) guess work."},{"location":"awesome-lsio/#file-sharing","title":"File Sharing","text":"Container Description projectsend projectsend is a self-hosted application that lets you upload files and assign them to specific clients that you create yourself. Secure, private and easy. No more depending on external services or e-mail to send those files. pwndrop pwndrop is a self-deployable file hosting service for sending out red teaming payloads or securely sharing your private files over HTTP and WebDAV. pydio-cells pydio-cells is the nextgen file sharing platform for organizations. It is a full rewrite of the Pydio project using the Go language following a micro-service architecture. snapdrop snapdrop A local file sharing in your browser. Inspired by Apple's Airdrop. xbackbone xbackbone is a simple, self-hosted, lightweight PHP file manager that support the instant sharing tool ShareX and *NIX systems. It supports uploading and displaying images, GIF, video, code, formatted text, and file downloading and uploading. Also have a web UI with multi user management, past uploads history and search support."},{"location":"awesome-lsio/#finance","title":"Finance","text":"Container Description budge budge is an open source 'budgeting with envelopes' personal finance app."},{"location":"awesome-lsio/#games","title":"Games","text":"Container Description emulatorjs emulatorjs - In browser web based emulation portable to nearly any device for many retro consoles. A mix of emulators is used between Libretro and EmulatorJS. minetest minetest (server) is a near-infinite-world block sandbox game and a game engine, inspired by InfiniMiner, Minecraft, and the like."},{"location":"awesome-lsio/#graphics","title":"Graphics","text":"Container Description blender Blender is a free and open-source 3D computer graphics software toolset used for creating animated films, visual effects, art, 3D printed models, motion graphics, interactive 3D applications, virtual reality, and computer games. This image does not support GPU rendering out of the box only accelerated workspace experience kdenlive Kdenlive is a powerful free and open source cross-platform video editing program made by the KDE community. Feature rich and production ready."},{"location":"awesome-lsio/#irc","title":"IRC","text":"Container Description limnoria limnoria A robust, full-featured, and user/programmer-friendly Python IRC bot, with many existing plugins. Successor of the well-known Supybot. ngircd ngircd is a free, portable and lightweight Internet Relay Chat server for small or private networks, developed under the GNU General Public License (GPL). It is easy to configure, can cope with dynamic IP addresses, and supports IPv6, SSL-protected connections as well as PAM for authentication. It is written from scratch and not based on the original IRCd. pidgin Pidgin is a chat program which lets you log into accounts on multiple chat networks simultaneously. This means that you can be chatting with friends on XMPP and sitting in an IRC channel at the same time. quassel-core quassel-core is a modern, cross-platform, distributed IRC client, meaning that one (or multiple) client(s) can attach to and detach from a central core. quassel-web quassel-web is a web client for Quassel.  Note that a Quassel-Core instance is required, we have a container available here. thelounge thelounge (a fork of shoutIRC) is a web IRC client that you host on your own server. znc znc is an IRC network bouncer or BNC. It can detach the client from the actual IRC server, and also from selected channels. Multiple clients from different locations can connect to a single ZNC account simultaneously and therefore appear under the same nickname on IRC."},{"location":"awesome-lsio/#indexers","title":"Indexers","text":"Container Description jackett jackett works as a proxy server: it translates queries from apps (Sonarr, SickRage, CouchPotato, Mylar, etc) into tracker-site-specific http queries, parses the html response, then sends results back to the requesting software. This allows for getting recent uploads (like RSS) and performing searches. Jackett is a single repository of maintained indexer scraping &amp; translation logic - removing the burden from other apps. nzbhydra2 nzbhydra2 is a meta search application for NZB indexers, the \"spiritual successor\" to NZBmegasearcH, and an evolution of the original application NZBHydra. prowlarr prowlarr is a indexer manager/proxy built on the popular arr .net/reactjs base stack to integrate with your various PVR apps. Prowlarr supports both Torrent Trackers and Usenet Indexers. It integrates seamlessly with Sonarr, Radarr, Lidarr, and Readarr offering complete management of your indexers with no per app Indexer setup required (we do it all)."},{"location":"awesome-lsio/#media-management","title":"Media Management","text":"Container Description bazarr bazarr is a companion application to Sonarr and Radarr. It can manage and download subtitles based on your requirements. You define your preferences by TV show or movie and Bazarr takes care of everything for you. medusa medusa is an automatic Video Library Manager for TV Shows. It watches for new episodes of your favorite shows, and when they are posted it does its magic. plex-meta-manager plex-meta-manager is a Python 3 script that can be continuously run using YAML configuration files to update on a schedule the metadata of the movies, shows, and collections in your libraries as well as automatically build collections based on various methods all detailed in the wiki. radarr radarr - A fork of Sonarr to work with movies \u00e0 la Couchpotato. sickchill sickchill is an Automatic Video Library Manager for TV Shows. It watches for new episodes of your favorite shows, and when they are posted it does its magic. sickgear SickGear provides management of TV shows and/or Anime, it detects new episodes, links downloader apps, and more.. sonarr sonarr (formerly NZBdrone) is a PVR for usenet and bittorrent users. It can monitor multiple RSS feeds for new episodes of your favorite shows and will grab, sort and rename them. It can also be configured to automatically upgrade the quality of files already downloaded when a better quality format becomes available."},{"location":"awesome-lsio/#media-players","title":"Media Players","text":"Container Description emby emby organizes video, music, live TV, and photos from personal media libraries and streams them to smart TVs, streaming boxes and mobile devices. This container is packaged as a standalone emby Media Server. jellyfin jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. plex plex organizes video, music and photos from personal media libraries and streams them to smart TVs, streaming boxes and mobile devices. This container is packaged as a standalone Plex Media Server. has always been a top priority. Straightforward design and bulk actions mean getting things done faster."},{"location":"awesome-lsio/#media-requesters","title":"Media Requesters","text":"Container Description doplarr doplarr is an *arr request bot for Discord.\" ombi ombi allows you to host your own Plex Request and user management system. overseerr overseerr is a request management and media discovery tool built to work with your existing Plex ecosystem."},{"location":"awesome-lsio/#media-tools","title":"Media Tools","text":"Container Description embystat embystat is a personal web server that can calculate all kinds of statistics from your (local) Emby server. Just install this on your server and let him calculate all kinds of fun stuff. ffmpeg No description htpcmanager htpcmanager is a front end for many htpc related applications. minisatip minisatip is a multi-threaded satip server version 1.2 that runs under Linux and it was tested with DVB-S, DVB-S2, DVB-T, DVB-T2, DVB-C, DVB-C2, ATSC and ISDB-T cards. oscam oscam is an Open Source Conditional Access Module software used for descrambling DVB transmissions using smart cards. It's both a server and a client. synclounge synclounge is a third party tool that allows you to watch Plex in sync with your friends/family, wherever you are. tautulli tautulli is a python based web application for monitoring, analytics and notifications for Plex Media Server. tvheadend tvheadend works as a proxy server: is a TV streaming server and recorder for Linux, FreeBSD and Android supporting DVB-S, DVB-S2, DVB-C, DVB-T, ATSC, ISDB-T, IPTV, SAT&gt;IP and HDHomeRun as input sources. webgrabplus webgrabplus is a multi-site incremental xmltv epg grabber. It collects tv-program guide data from selected tvguide sites for your favourite channels."},{"location":"awesome-lsio/#monitor","title":"Monitor","text":"Container Description apprise-api apprise-api Takes advantage of Apprise through your network with a user-friendly API. healthchecks healthchecks is a watchdog for your cron jobs. It's a web server that listens for pings from your cron jobs, plus a web interface. librespeed librespeed is a very lightweight Speedtest implemented in Javascript, using XMLHttpRequest and Web Workers. smokeping smokeping keeps track of your network latency. For a full example of what this application is capable of visit UCDavis. syslog-ng syslog-ng allows you to flexibly collect, parse, classify, rewrite and correlate logs from across your infrastructure and store or route them to log analysis tools."},{"location":"awesome-lsio/#music","title":"Music","text":"Container Description airsonic-advanced airsonic-advanced is a free, web-based media streamer, providing ubiquitious access to your music. Use it to share your music with friends, or to listen to your own music while at work. You can stream to multiple players simultaneously, for instance to one player in your kitchen and another in your living room. audacity Audacity is an easy-to-use, multi-track audio editor and recorder. Developed by a group of volunteers as open source. beets beets is a music library manager and not, for the most part, a music player. It does include a simple player plugin and an experimental Web-based player, but it generally leaves actual sound-reproduction to specialized tools. daapd daapd (iTunes) media server with support for AirPlay devices, Apple Remote (and compatibles), Chromecast, MPD and internet radio. headphones headphones is an automated music downloader for NZB and Torrent, written in Python. It supports SABnzbd, NZBget, Transmission, \u00b5Torrent and Blackhole. lidarr lidarr is a music collection manager for Usenet and BitTorrent users. It can monitor multiple RSS feeds for new tracks from your favorite artists and will grab, sort and rename them. It can also be configured to automatically upgrade the quality of files already downloaded when a better quality format becomes available. mstream mstream is a personal music streaming server. You can use mStream to stream your music from your home computer to any device, anywhere.  There are mobile apps available for both Android and iPhone."},{"location":"awesome-lsio/#network","title":"Network","text":"Container Description unifi-controller The unifi-controller software is a powerful, enterprise wireless software engine ideal for high-density client deployments requiring low latency and high uptime performance. wireshark Wireshark is the world\u2019s foremost and widely-used network protocol analyzer. It lets you see what\u2019s happening on your network at a microscopic level and is the de facto (and often de jure) standard across many commercial and non-profit enterprises, government agencies, and educational institutions. Wireshark development thrives thanks to the volunteer contributions of networking experts around the globe and is the continuation of a project started by Gerald Combs in 1998."},{"location":"awesome-lsio/#photos","title":"Photos","text":"Container Description chevereto chevereto is an image hosting software that allows you to create a beautiful and full-featured image hosting website on your own server. It's your hosting and your rules, so say goodbye to closures and restrictions. darktable darktable is an open source photography workflow application and raw developer. A virtual lighttable and darkroom for photographers. It manages your digital negatives in a database, lets you view them through a zoomable lighttable and enables you to develop raw images and enhance them. digikam digiKam: Professional Photo Management with the Power of Open Source lychee lychee is a free photo-management tool, which runs on your server or web-space. Installing is a matter of seconds. Upload, manage and share photos like from a native application. Lychee comes with everything you need and all your photos are stored securely.\" photoshow photoshow is gallery software at its easiest, it doesn't even require a database. piwigo piwigo is a photo gallery software for the web that comes with powerful features to publish and manage your collection of pictures. pixapop pixapop is an open-source single page application to view your photos in the easiest way possible."},{"location":"awesome-lsio/#programming","title":"Programming","text":"Container Description cloud9 cloud9 Cloud9 is a complete web based IDE with terminal access. This container is for running their core SDK locally and developing plugins. code-server code-server is VS Code running on a remote server, accessible through the browser. openvscode-server openvscode-server provides a version of VS Code that runs a server on a remote machine and allows access through a modern web browser. pylon pylon is a web based integrated development environment built with Node.js as a backend and with a supercharged JavaScript/HTML5 frontend, licensed under GPL version 3. This project originates from Cloud9 v2 project."},{"location":"awesome-lsio/#rss","title":"RSS","text":"Container Description freshrss freshrss is a free, self-hostable aggregator for rss feeds."},{"location":"awesome-lsio/#recipes","title":"Recipes","text":"Container Description grocy grocy is an ERP system for your kitchen! Cut down on food waste, and manage your chores with this brilliant utility."},{"location":"awesome-lsio/#remote","title":"Remote","text":"Container Description guacd guacd - Apache Guacamole is a clientless remote desktop gateway. It supports standard protocols like VNC, RDP, and SSH. This container is only the backend server component needed to use The official or 3rd party HTML5 frontends. rdesktop rdesktop - Containers containing full desktop environments in many popular flavors for Alpine, Ubuntu, Arch, and Fedora accessible via RDP. remmina Remmina is a remote desktop client written in GTK, aiming to be useful for system administrators and travellers, who need to work with lots of remote computers in front of either large or tiny screens. Remmina supports multiple network protocols, in an integrated and consistent user interface. Currently RDP, VNC, SPICE, NX, XDMCP, SSH and EXEC are supported. webtop webtop - Alpine, Ubuntu, Fedora, and Arch based containers containing full desktop environments in officially supported flavors accessible via any modern web browser."},{"location":"awesome-lsio/#science","title":"Science","text":"Container Description boinc BOINC is a platform for high-throughput computing on a large scale (thousands or millions of computers). It can be used for volunteer computing (using consumer devices) or grid computing (using organizational resources). It supports virtualized, parallel, and GPU-based applications. foldingathome Folding@home is a distributed computing project for simulating protein dynamics, including the process of protein folding and the movements of proteins implicated in a variety of diseases. It brings together citizen scientists who volunteer to run simulations of protein dynamics on their personal computers. Insights from this data are helping scientists to better understand biology, and providing new opportunities for developing therapeutics."},{"location":"awesome-lsio/#storage","title":"Storage","text":"Container Description diskover diskover is an open source file system indexer that uses Elasticsearch to index and manage data across heterogeneous storage systems. qdirstat QDirStat Qt-based directory statistics: KDirStat without any KDE -- from the author of the original KDirStat. scrutiny scrutiny WebUI for smartd S.M.A.R.T monitoring. Scrutiny is a Hard Drive Health Dashboard &amp; Monitoring solution, merging manufacturer provided S.M.A.R.T metrics with real-world failure rates from Backblaze."},{"location":"awesome-lsio/#tools","title":"Tools","text":"Container Description yq No description"},{"location":"awesome-lsio/#vpn","title":"VPN","text":"Container Description wireguard WireGuard\u00ae is an extremely simple yet fast and modern VPN that utilizes state-of-the-art cryptography. It aims to be faster, simpler, leaner, and more useful than IPsec, while avoiding the massive headache. It intends to be considerably more performant than OpenVPN. WireGuard is designed as a general purpose VPN for running on embedded interfaces and super computers alike, fit for many different circumstances. Initially released for the Linux kernel, it is now cross-platform (Windows, macOS, BSD, iOS, Android) and widely deployable. It is currently under heavy development, but already it might be regarded as the most secure, easiest to use, and simplest VPN solution in the industry."},{"location":"awesome-lsio/#web","title":"Web","text":"Container Description firefox Firefox Browser, also known as Mozilla Firefox or simply Firefox, is a free and open-source web browser developed by the Mozilla Foundation and its subsidiary, the Mozilla Corporation. Firefox uses the Gecko layout engine to render web pages, which implements current and anticipated web standards. grav grav is a Fast, Simple, and Flexible, file-based Web-platform. nginx nginx is a simple webserver with php support. The config files reside in <code>/config</code> for easy user customization. swag SWAG - Secure Web Application Gateway (formerly known as letsencrypt, no relation to Let's Encrypt\u2122) sets up an Nginx webserver and reverse proxy with php support and a built-in certbot client that automates free SSL server certificate generation and renewal processes (Let's Encrypt and ZeroSSL). It also contains fail2ban for intrusion prevention."},{"location":"awesome-lsio/#wiki","title":"Wiki","text":"Container Description bookstack bookstack is a free and open source Wiki designed for creating beautiful documentation. Featuring a simple, but powerful WYSIWYG editor it allows for teams to create detailed and useful documentation with ease. dillinger dillinger is a cloud-enabled, mobile-ready, offline-storage, AngularJS powered HTML5 Markdown editor. dokuwiki dokuwiki is a simple to use and highly versatile Open Source wiki software that doesn't require a database. It is loved by users for its clean and readable syntax. The ease of maintenance, backup and integration makes it an administrator's favorite. Built in access controls and authentication connectors make DokuWiki especially useful in the enterprise context and the large number of plugins contributed by its vibrant community allow for a broad range of use cases beyond a traditional wiki. hedgedoc HedgeDoc gives you access to all your files wherever you are. raneto raneto - is an open source Knowledgebase platform that uses static Markdown files to power your Knowledgebase. wikijs wikijs A modern, lightweight and powerful wiki app built on NodeJS."},{"location":"brave/","title":"Brave Settings","text":"<p>brave://flags</p> <ul> <li>Enable First Party Storage Cleanup support: enabled</li> <li>Enable Brave Wallet: disabled</li> <li>Strict-Origin-Isolation: enabled</li> </ul> <p>Get started</p> <ul> <li>Continue where you left off: on</li> <li>New tab page shows: homepage</li> </ul> <p>Appearance</p> <ul> <li>Show home button: on</li> <li>Show bookmarks button: on</li> <li>Show bookmarks: always</li> <li>Show news button: off</li> <li>Show brave rewards button: off</li> <li>Show brave wallet button: off</li> <li>Show sidebar butoon: off</li> <li>Always show full URLs: on</li> </ul> <p>Shields</p> <ul> <li>Trackers &amp; ads blocking: aggressive</li> <li>Upgrade connections to HTTPS: strict</li> <li>Block scripts: off</li> <li>Block fingerprinting: strict</li> <li>Block cookies: only cross-site</li> <li>Forget me when I close this site: on</li> <li>Content filtering<ul> <li>EasyList Cookie</li> <li>Fanboy's Annoyances</li> <li>Fanboy's Social</li> <li>Fanboy's Anti-Newsletter</li> <li>Fanboy's Mobile Notifications</li> <li>Fanboy's Anti-chat Apps</li> <li>uBlock Annoyances</li> <li>Bypass Paywalls Clean Filters</li> </ul> </li> <li>Show the number of blocked items on the Shields icon: on</li> <li>Auto-redirect AMP pages: on</li> <li>Auto redirect tracking URLs: on</li> <li>Prevent sites from fingerprinting me based on my language preferences: on</li> <li>Allow use of third-party cookies for legacy google sign-in: off</li> <li>Allow facebook logins and embedded posts: off</li> <li>Allow twitter embedded tweets: off</li> <li>Allow linkedin embedded posts: off</li> </ul> <p>Privacy and security</p> <ul> <li>WebRTC IP handling policy: disable</li> <li>Use google services for push messaging: off</li> <li>Allow privacy-preserving product analytics: off</li> <li>Automatically send daily usage ping to brave: off</li> <li>Automatically send diagnostic reports: off</li> <li>Clear browsing data<ul> <li>On exit: browsing history, download history, passwords, autofill</li> </ul> </li> <li>Third-party cookies<ul> <li>Block third-party cookies: enabled</li> <li>Send a \"do not track\" request with your browsing traffic: off</li> </ul> </li> <li>Security<ul> <li>Standard protection: enabled</li> <li>Use secure DNS: disabled</li> <li>Manage V8 security<ul> <li>Sites can use the V8 optimizer: disabled</li> </ul> </li> </ul> </li> <li>Private window with tor: off</li> </ul> <p>Web3</p> <ul> <li>Default ethereum wallet: extensions (no fallback)</li> <li>Default solana wallet: extensions (no fallback)</li> <li>Enable NFT discovery: off</li> <li>Automatically pin NFTs: off</li> <li>Method to resolve IPFS: off</li> <li>IPFS public gateway fallback: off</li> <li>Automatically redirect requests for IPFS network resources to the configured gateway: off</li> <li>IPFS companion: off</li> </ul> <p>Leo</p> <ul> <li>Show Leo icon in the sidebar: off</li> <li>Show Leo in the context menu on websites: off</li> </ul> <p>Search engine</p> <ul> <li>Normal Window - Search engine used in the address bar: searx</li> <li>Private Window - Search engine used in the address bar: searx</li> <li>Improve search suggestions: off</li> <li>Web discovery project: off</li> <li>Index other search engines: off</li> <li>Manage search engines: add searx and piped</li> </ul> <p>Extensions</p> <ul> <li>Allow google login for extensions: off</li> <li>Hangouts: off</li> <li>Media router: off</li> <li>Webtorrent: off</li> <li>Widevine: off</li> <li>Manage extensions<ul> <li>Bitwarden<ul> <li>Auto-fill<ul> <li>Show auto-fill menu on form fields: when field is selected</li> <li>Make bitwarden your default password manager: on</li> <li>Auto-fill on page load: off</li> <li>Default URI match detection: host</li> </ul> </li> <li>Vault timeout action: on browser restart</li> <li>Options<ul> <li>Everything: on</li> </ul> </li> </ul> </li> <li>Dark reader</li> <li>Floccus<ul> <li>Server target: /Bookmarks</li> </ul> </li> <li>Redirector: import</li> <li>SmartProxy: import</li> </ul> </li> </ul> <p>Autofill and passwords</p> <ul> <li>All: off</li> </ul> <p>System</p> <ul> <li>Continue running background apps when Brave is closed: off</li> <li>Use graphics acceleration when available: on</li> </ul>"},{"location":"consolidate/","title":"Consolidating Internal SWAG proxies","text":"<p>It's possible to consolidate the majority of internal nginx proxies using mappings, these mappings get resolved when the mapped variables are used.</p> <p>Note - This doesn't work for every app since some require special configuration, but it works for most of them.</p>"},{"location":"consolidate/#consolidated-proxies","title":"Consolidated proxies","text":"<pre><code>map $internal_app $internal_port {\n    babybuddy 8000;\n    bazarr 6767;\n    bitwarden 80;\n    collabora 9980;\n    drawio 8080;\n    gitea 3000;\n    heimdall 4443;\n    lidarr 8686;\n    mkdocs 8000;\n    paperless 8000;\n    photoview 80;\n    podgrab 8080;\n    prowlarr 9696;\n    radarr 7878;\n    scrutiny 8080;\n    sonarr 8989;\n    uptime 3001;\n    youtubedl 8080;\n}\nmap $internal_app $internal_proto {\n    default http;\n    collabora https;\n    heimdall https;\n}\nmap $internal_app $internal_container {\n    default $internal_app;\n    bazarr \"mullvad\";\n    lidarr \"mullvad\";\n    podgrab \"mullvad\";\n    prowlarr \"mullvad\";\n    radarr \"mullvad\";\n    sonarr \"mullvad\";\n}\nserver {\n    listen 443 ssl;\n    server_name ~^(?&lt;internal_app&gt;.*?)\\..*$;\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n    if ($lan-ip = no) { return 404; }\n\n    location / {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        proxy_pass $internal_proto://$internal_container:$internal_port;\n    }\n}\n</code></pre>"},{"location":"consolidate/#explanation","title":"Explanation","text":"<p>We created 3 mappings:</p> <ol> <li><code>map $internal_app $internal_container</code> - app name to the container name, with the app name by default.</li> <li><code>map $internal_app $internal_proto</code> - app name to the protocol, with <code>http</code> by default.</li> <li><code>map $internal_app $internal_port</code> - app name to the app port, with no default.</li> </ol> <p>When a request comes in, it gets processed by the regular expression <code>~^(?&lt;internal_app&gt;.*?)\\..*$</code> which sets <code>$internal_app</code> with the subdomain, for example radarr in the case of <code>radarr.domain.com</code>.</p> <p>It then checks if the request is local, which requires defining what is the local network.</p> <p>The final part: <code>proxy_pass $internal_proto://$internal_container:$internal_port</code> figures out where to proxy the request based on the <code>$internal_app</code> variable, for example radarr gets proxied to <code>http://radarr:7878</code>.</p>"},{"location":"container-dns/","title":"DNS for Containers","text":""},{"location":"container-dns/#problem","title":"Problem","text":"<p>The common setup is to have a server with many containers, and a network DNS such as pihole or adguardhome.</p> <p>The issue is that all dns queries by the server and all containers are grouped into a single bucket on the network DNS, making it difficult to track malicious DNS queries by a single container.</p>"},{"location":"container-dns/#solution","title":"Solution","text":"<p>Create an adguardhome container for all the other containers to use as their DNS, and set the host as the upstream DNS for reverse lookups, so that container names will be displayed instead of IPs.</p> <p>These are the general steps with an example below:</p> <ul> <li>Create a bridge network with a static subnet.</li> <li>Create an adguardhome container with a static IP in that subnet.</li> <li>Assign all other containers static IPs in that subnet as well.</li> <li>Set the DNS of all other containers to the static IP of adguardhome.</li> <li>Set all other containers to depend on adguardhome.</li> </ul> <pre><code>networks:\n  internal:\n    driver: bridge\n    ipam:\n      config:\n        - subnet: 172.20.0.0/16\nservices:\n  agh:\n    image: adguard/adguardhome\n    container_name: agh\n    volumes:\n      - /path/to/agh/conf:/opt/adguardhome/conf\n      - /path/to/agh/work:/opt/adguardhome/work\n    networks:\n      internal:\n        ipv4_address: 172.20.20.20\n    ports:\n      - 13080:80\n      - 13000:3000\n  someapp:\n    networks:\n      internal:\n        ipv4_address: 172.20.0.2\n    dns: 172.20.20.20\n    depends_on:\n        - agh\n</code></pre>"},{"location":"container-dns/#adguardhome-configuration","title":"AdguardHome Configuration","text":"<p>Go through the initial configuration on port 13000 and switch to port 13080 to access the web-ui.</p> <p>Settings &gt; General settings</p> <ul> <li>Block domains using filters and hosts files: Uncheck</li> <li>Enable log: Check</li> <li>Query logs rotation: 90 days</li> <li>Ignored domains: ||your-private-domain.tld^</li> <li>Enable statistics: Check</li> <li>Statistics retention: 90 days</li> <li>Ignored domains: ||your-private-domain.tld^</li> </ul> <p>Settings &gt; DNS settings</p> <ul> <li>Upstream DNS servers: <code>127.0.0.11</code>.</li> <li>Private reverse DNS servers: <code>127.0.0.11:53</code>.</li> <li>Use private reverse DNS resolvers: Check</li> <li>Rate limit: 0</li> </ul>"},{"location":"firehol/","title":"Firehol Blocklists","text":"<p>Firehol blocklists are a collection of automatically updating ipsets from all available security IP Feeds, mainly related to on-line attacks, on-line service abuse, malwares, botnets, command and control servers and other cybercrime activities.</p>"},{"location":"firehol/#vps","title":"VPS","text":""},{"location":"firehol/#installation","title":"Installation","text":"<p>Install the following packages:</p> <pre><code>sudo apt install ipset iprange\n</code></pre>"},{"location":"firehol/#firehol-blocklists_1","title":"Firehol Blocklists","text":"<p>Navigate to Firehol's website or Firehol's github repo and choose which blocklists you want to enable.</p> <p>Copy the raw links into <code>/home/user/firehol/firehol.conf</code>. For example:</p> <pre><code>https://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level1.netset\nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level2.netset\nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level3.netset\nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_abusers_1d.netset\n</code></pre>"},{"location":"firehol/#firehol-script","title":"Firehol Script","text":"<p>Create a script to refresh the firehol ipsets and recreate the iptables rules.</p> <p>For example <code>/home/user/firehol/firehol.sh</code>:</p> <pre><code>#!/bin/bash\n\nLOG=\"/home/user/firehol/firehol.log\"\nURLS=$(cat \"/home/user/firehol/firehol.conf\")\necho \"Updating Firehol $(date)\" &gt;&gt; $LOG\n\niptables -D INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT &gt; /dev/null 2&gt;&amp;1\niptables -D DOCKER-USER -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT &gt; /dev/null 2&gt;&amp;1\niptables -D FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT &gt; /dev/null 2&gt;&amp;1\niptables -I FORWARD 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT &gt;&gt; $LOG\niptables -I INPUT 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT &gt;&gt; $LOG\niptables -I DOCKER-USER 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT &gt;&gt; $LOG\n\nfor URL in $URLS\ndo\n    echo $URL &gt;&gt; $LOG\n    NAME=$(basename $URL)\n    echo $NAME &gt;&gt; $LOG\n    FILE=\"/home/user/firehol/$NAME\"\n    curl -s -k $URL &gt; $FILE\n    # The following sed removes LAN ranges from the lists otherwise you might block yourself\n    sed -i -e 's#10.0.0.0/8##' -e 's#172.16.0.0/12##' -e 's#192.168.0.0/16##' -e 's#127.0.0.0/8##' $FILE\n    COUNT=$(/usr/bin/iprange -C $FILE)\n    COUNT=${COUNT/*,/}\n    echo $COUNT &gt;&gt; $LOG\n    /usr/sbin/ipset create --exist $NAME hash:net family inet maxelem 131072 &gt;&gt; $LOG\n    /usr/sbin/ipset flush $NAME &gt; /dev/null 2&gt;&amp;1\n    /usr/bin/iprange $FILE --ipset-reduce 20 --ipset-reduce-entries 65535 --print-prefix \"-A $NAME \" &gt; $FILE.ipset\n    /usr/sbin/ipset restore --exist --file $FILE.ipset &gt;&gt; $LOG\n    /usr/sbin/iptables -D FORWARD -m set --match-set $NAME src -j DROP &amp;&gt;/dev/null\n    /usr/sbin/iptables -D INPUT -m set --match-set $NAME src -j DROP &amp;&gt;/dev/null\n    /usr/sbin/iptables -D DOCKER-USER -m set --match-set $NAME src -j DROP &amp;&gt;/dev/null\n    /usr/sbin/iptables -I DOCKER-USER 2 -m set --match-set $NAME src -j DROP &gt;&gt; $LOG\n    /usr/sbin/iptables -I INPUT 2 -m set --match-set $NAME src -j DROP &gt;&gt; $LOG\n    /usr/sbin/iptables -I FORWARD 2 -m set --match-set $NAME src -j DROP &gt;&gt; $LOG\ndone\n</code></pre> <p>Verify that it works and the ipsets have been filled:</p> <pre><code>chmod +x /home/user/firehol/firehol.sh\nsudo /home/user/firehol/firehol.sh\nsudo ipset list firehol_level1.netset\n</code></pre>"},{"location":"firehol/#cron-scheduling","title":"Cron Scheduling","text":""},{"location":"firehol/#warning-make-sure-youre-not-accidentally-blocking-your-own-access-to-the-vps-before-proceeding","title":"Warning - make sure you're not accidentally blocking your own access to the VPS before proceeding.","text":"<p>Run the firehol script on reboot and daily.</p> <p>For example, add the following to <code>sudo crontab -e</code>:</p> <pre><code>0 1 * * * /home/user/firehol/firehol.sh\n@reboot sleep 120 &amp;&amp; /home/user/firehol/firehol.sh\n</code></pre> <p>Verify that it runs on reboot and daily. There's a 2 minute delay before it applies after reboots, to give you enough time to fix a lockout.</p>"},{"location":"firehol/#opnsense","title":"OPNSense","text":""},{"location":"firehol/#alias","title":"Alias","text":"<p>Navigate to Firewall &gt; Aliases and create the following aliases:</p> <pre><code>Name: Firehol\nType: URL IPs\nContent: \nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level1.netset\nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level2.netset\nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level3.netset\nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_abusers_1d.netset\n</code></pre> <pre><code>Name: External\nType: Networks\nContent: !10.0.0.0/8, !172.16.0.0/12, !192.168.0.0/16, !127.0.0.1\n</code></pre> <pre><code>Name: Firehol_without_internal\nType: Network group\nContent: External, Firehol\n</code></pre>"},{"location":"firehol/#firewall","title":"Firewall","text":"<p>Navigate to Firewall &gt; Rules &gt; WAN and create the following firewall rule:</p> <pre><code>Action: Block\nInterface: WAN\nDirection: in\nTCP/IP Version: IPv4\nProtocol: any\nSource: Firehol_without_internal\nDestination: any\n</code></pre>"},{"location":"firehol/#cron","title":"Cron","text":"<p>Create a cron job to automatically update the blocklists every day.</p> <p>Navigate to System &gt; Settings &gt; Cron and add the following job:</p> <pre><code>Eabled: checked\nMinutes: 0\nHours: 0\nDay of the month: *\nMonths: *\nDays of the week: *\nCommand: Update and reload firewall aliases\n</code></pre>"},{"location":"geoblock/","title":"Geoblock","text":""},{"location":"geoblock/#vps","title":"VPS","text":"<p>I've been dealing with constant attacks on a mail server on a VPS coming from 2 specific countries, the only solution that worked was completely blocking these countries.</p> <p>There are 2 popular geoblock providers, Maxmind and DP-IP, we can utilize them using a python library called geoipsets.</p>"},{"location":"geoblock/#installation","title":"Installation","text":"<p>Install the following packages:</p> <pre><code>sudo apt install python3 python3.12 python3-pip python3-venv ipset\n</code></pre> <p>Create a python virtual environment:</p> <pre><code>python3 -m venv .venv\n</code></pre> <p>Verify that it works:</p> <pre><code>source .venv/bin/activate\n</code></pre>"},{"location":"geoblock/#geoblock-config","title":"Geoblock Config","text":"<p>Create a geoblock config according to the geoipsets documentation.</p> <p>For example <code>/home/user/geoipsets.conf</code>:</p> <pre><code>[general]\nprovider=dbip\nfirewall=iptables\naddress-family=ipv4,ipv6\n\n[countries]\nRU\nCN\n</code></pre> <p>Verify that it works:</p> <pre><code>source .venv/bin/activate\ngeoipsets -o /home/user -c /home/user/geoipsets.conf\n</code></pre>"},{"location":"geoblock/#geoblock-script","title":"Geoblock Script","text":"<p>Create a script to refresh the geoblock ipsets and recreate the iptables rules.</p> <p>For example <code>/home/user/geoblock.sh</code>:</p> <pre><code>#!/bin/bash\n\noutput_path=\"/home/user\"\nvenv_path=\"/home/user/.venv/bin/activate\"\nconfig_path=\"/home/user/geoipsets.conf\"\nlog=\"/home/user/geoblock.log\"\n\necho \"Updating Blocklist $(date)\" &gt;&gt; $log\nsource $venv_path\ngeoipsets -o $output_path -c $config_path &gt;&gt; $log\n\nfor i in $(find \"${output_path}/geoipsets\" -name \"*.ipv*\");\ndo\n    name=$(basename $i)\n    echo $name &gt;&gt; $log\n    /usr/sbin/ipset flush $name &gt;&gt; $log\n    /usr/sbin/ipset restore --exist --file $i &gt;&gt; $log\n    command=$(if [[ $name == *ipv4 ]]; then echo \"/usr/sbin/iptables\"; else echo \"/usr/sbin/ip6tables\"; fi)\n    $command -D FORWARD -m set --match-set $name src -j DROP &amp;&gt;/dev/null\n    $command -D INPUT -m set --match-set $name src -j DROP &amp;&gt;/dev/null\n    $command -D DOCKER-USER -m set --match-set $name src -j DROP &amp;&gt;/dev/null\n    $command -I DOCKER-USER 1 -m set --match-set $name src -j DROP &gt;&gt; $log\n    $command -I INPUT 1 -m set --match-set $name src -j DROP &gt;&gt; $log\n    $command -I FORWARD 1 -m set --match-set $name src -j DROP &gt;&gt; $log\ndone\n</code></pre> <p>Verify that it works and the ipsets have been filled:</p> <pre><code>chmod +x /home/user/geoblock.sh\nsudo /home/user/geoblock.sh\nsudo ipset list RU.ipv4\n</code></pre>"},{"location":"geoblock/#cron-scheduling","title":"Cron Scheduling","text":""},{"location":"geoblock/#warning-make-sure-youre-not-accidentally-blocking-your-own-access-to-the-vps-before-proceeding","title":"Warning - make sure you're not accidentally blocking your own access to the VPS before proceeding.","text":"<p>Run the geoblock script on reboot and weekly.</p> <p>For example, add the following to <code>sudo crontab -e</code>:</p> <pre><code>20 0 * * 2 /home/user/geoblock.sh\n@reboot sleep 120 &amp;&amp; /home/user/geoblock.sh\n</code></pre> <p>Verify that it runs on reboot and weekly. There's a 2 minute delay before it applies after reboots, to give you enough time to fix a lockout.</p>"},{"location":"geoblock/#opnsense","title":"OPNSense","text":""},{"location":"geoblock/#alias","title":"Alias","text":"<p>Navigate to Firewall &gt; Aliases &gt; GeoIP settings and add a link to a geoblock database with your license key:</p> <pre><code>https://download.maxmind.com/app/geoip_download?edition_id=GeoLite2-Country-CSV&amp;license_key=your-license-key&amp;suffix=zip\n</code></pre> <p>Navigate to Firewall &gt; Aliases and create aliases with the countries you want to block or whitelist a specific country:</p> <pre><code>Name: Geoblock\nType: GeoIP (IPv4, IPv6)\nContent: Select all the countries you want to block\n</code></pre> <pre><code>Name: UK\nType: GeoIP (IPv4, IPv6)\nContent: Select UK\n</code></pre>"},{"location":"geoblock/#firewall","title":"Firewall","text":"<p>Navigate to Firewall &gt; Rules &gt; WAN and create firewall rules:</p> <pre><code>Action: Block\nInterface: WAN\nDirection: in\nTCP/IP Version: IPv4+IPv6\nProtocol: any\nSource: Geoblock\nDestination: any\nDescription: Blocks specific countries\n</code></pre> <pre><code>Action: Pass\nInterface: WAN\nDirection: in\nTCP/IP Version: IPv4+IPv6\nProtocol: TCP\nSource: UK\nDestination: WAN address\nDestination port range: 443\nDescription: Whitelist UK on port 443\n</code></pre>"},{"location":"geoblock/#cron","title":"Cron","text":"<p>Create a cron job to automatically update the blocklists every day.</p> <p>Navigate to System &gt; Settings &gt; Cron and add the following job:</p> <pre><code>Eabled: checked\nMinutes: 0\nHours: 0\nDay of the month: *\nMonths: *\nDays of the week: *\nCommand: Update and reload firewall aliases\n</code></pre>"},{"location":"hardcoded-dns/","title":"Hardcoded DNS","text":"<p>Smart home IoT devices are often configured with hardcoded DNS servers such as Google public DNS. 98% of smart assistants and 72% of smart TVs use hardcoded Google DNS servers to resolve DNS queries instead of using the default DNS server configured at the home gateway.</p> <p>Detailed in the paper Characterizing Smart Home IoT Traffic in the Wild.</p> <p>Hardcoded DNS can be prevented with the following actions:</p> <ul> <li>Catch all network traffic on ports 53, 853 and NAT it back to the local DNS.</li> <li>Block all traffic to public DoH IPs using DoH-IP-blocklists.</li> <li>Block all public DoH domains using DoH-IP-blocklists.</li> </ul> <p>The following rules were made using OPNSense and AdGuardHome to achieve it.</p>"},{"location":"hardcoded-dns/#opnsense","title":"OPNSense","text":""},{"location":"hardcoded-dns/#alias","title":"Alias","text":"<p>Navigate to Firewall &gt; Aliases and create the following aliases:</p> <pre><code>Name: NAT_Ports\nType: Ports\nContent: 53, 853\n</code></pre> <pre><code>Name: Internal\nType: Networks\nContent: 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16\n</code></pre> <pre><code>Name: Public_DNS\nType: URL IPs\nContent: https://raw.githubusercontent.com/dibdot/DoH-IP-blocklists/master/doh-ipv4.txt, https://raw.githubusercontent.com/dibdot/DoH-IP-blocklists/master/doh-ipv6.txt\n</code></pre>"},{"location":"hardcoded-dns/#nat","title":"NAT","text":"<p>The NAT rule redirects all traffic on ports 53, 853 to the local DNS.</p> <p>Navigate to Firewall &gt; NAT &gt; Port Forward and create the following NAT rule:</p> <pre><code>Interface: Select all the LAN and VLAN interfaces\nProtocol: TCP/UDP\nSource: Internal (the alias we created)\nDestination / Invert: checked\nDestination: This Firewall (the local DNS, in my case AGH runs on opnsense)\nDestination port range: NAT_Ports (the alias we created)\nRedirect target IP: 192.168.0.1 (the local DNS IP, in my case AGH runs on opnsense)\nRedirect target port: NAT_Ports\n</code></pre>"},{"location":"hardcoded-dns/#floating","title":"Floating","text":"<p>The floating rule blocks DoH traffic.</p> <p>Navigate to Firewall &gt; Rules &gt; Floating and create the following floating rule:</p> <pre><code>Action: Block\nInterface: Select all the interfaces\nDirection: any\nTCP/IP Version: IPv4+IPv6\nProtocol: TCP/UDP\nSource / Invert: checked\nSource: This Firewall (the local DNS, in my case AGH runs on opnsense)\nDestination: Public_DNS (the alias we created)\nDestination port range: HTTPS\n</code></pre>"},{"location":"hardcoded-dns/#adguardhome","title":"AdGuardHome","text":"<p>The AdGuardHome blocklist blocks DoH domains.</p> <p>Navigate to AGH &gt; Filters &gt; DNS blocklists and add the following blocklist:</p> <pre><code>https://raw.githubusercontent.com/dibdot/DoH-IP-blocklists/master/doh-domains.txt\n</code></pre>"},{"location":"hardcoded-dns/#cron","title":"Cron","text":"<p>Create a cron job to automatically update the blocklist every day.</p> <p>Navigate to System &gt; Settings &gt; Cron and add the following job:</p> <pre><code>Eabled: checked\nMinutes: 0\nHours: 0\nDay of the month: *\nMonths: *\nDays of the week: *\nCommand: Update and reload firewall aliases\n</code></pre>"},{"location":"hub/","title":"Wireguard Hub","text":"<p>Linuxserver's Wireguard container is extremely versatile, in this example we'll use it as a server that tunnels clients through multiple redundant vpn connections while maintaining access to the LAN.</p> <p>VPN providers have a limit on the amount of devices, this setup will allow you to have an unlimited amount of devices tunneled through a single VPN connection while also supporting a failover backup connection!</p> <p>Objectives:</p> <ul> <li>Implement in a single wireguard server container.</li> <li>Allow unlimited clients to connect to the wireguard server container and utilize the same VPN connection.</li> <li>Support a fallback VPN connection for increased reliability.</li> <li>Support accessing LAN devices over wireguard.</li> <li>Support excluding domains that block VPNs.</li> <li>Support tunneling other containers through the same VPN connection.</li> <li>Support tunneling entire VLANs and hosts through the same VPN connection.</li> </ul>"},{"location":"hub/#instructions","title":"Instructions","text":"<p>Clone the following boilerplate:</p> <pre><code>git clone https://github.com/quietsy/wireguard-hub.git\n</code></pre>"},{"location":"hub/#server-template","title":"Server Template","text":"<p>Replace <code>CHANGETHIS</code> with your LAN subnet under <code>wireguard/templates/server.conf</code>.</p>"},{"location":"hub/#client-tunnels","title":"Client Tunnels","text":"<ul> <li>Obtain 2 wireguard vpn configurations from your vpn provider (mullvad and torguard have been tested).</li> <li>Replace <code>CHANGETHIS</code> with your vpn configurations under:<ul> <li><code>wireguard/wg_confs/wg1.conf</code></li> <li><code>wireguard/wg_confs/wg2.conf</code></li> </ul> </li> </ul>"},{"location":"hub/#wireguard-server-container","title":"Wireguard Server Container","text":"<p>Configure a Wireguard server container according to the Wireguard documentation with the <code>wireguard</code> folder of the boilerplate mounted to <code>/config</code>.</p> <pre><code>services:\n  wireguard:\n    image: lscr.io/linuxserver/wireguard:latest\n    container_name: wireguard\n    cap_add:\n      - NET_ADMIN\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Etc/UTC\n      - SERVERURL=wireguard.domain.com\n      - SERVERPORT=51820\n      - PEERS=1\n      - PEERDNS=auto\n      - INTERNAL_SUBNET=10.13.13.0\n      - ALLOWEDIPS=0.0.0.0/0\n      - LOG_CONFS=true\n      - DOCKER_MODS=linuxserver/mods:universal-package-install\n      - INSTALL_PACKAGES=ipset\n    volumes:\n      - ./wireguard:/config\n    ports:\n      - 51820:51820/udp\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1\n    restart: unless-stopped\n</code></pre> <p>Create the container and perform the following checks to verify that the VPN tunnels works:</p> <ul> <li>Check that <code>docker logs wireguard</code> contains no errors, and check that the server is working properly by connecting a client to it.</li> <li>Check that you have connectivity on wg1 by running <code>docker exec wireguard ping -c4 -I wg1 1.1.1.1</code>.</li> <li>Check that you have connectivity on wg2 by running <code>docker exec wireguard ping -c4 -I wg2 1.1.1.1</code>.</li> <li>Check the details of your VPN tunnel on wg1 by running <code>docker exec wireguard curl --interface wg1 -s https://am.i.mullvad.net/json</code>, you should get an IP that is different from your WAN IP.</li> <li>Check the details of your VPN tunnel on wg2 by running <code>docker exec wireguard curl --interface wg2 -s https://am.i.mullvad.net/json</code>, you should get an IP that is different from your WAN IP.</li> <li>Connect to the tunnel with a client device and navigate to <code>https://am.i.mullvad.net/json</code>, verify that the server is working properly and that you're tunneled through one the VPN tunnels.</li> </ul>"},{"location":"hub/#bypassing-the-vpn-for-specific-sites-optional","title":"Bypassing the VPN for specific sites (optional)","text":""},{"location":"hub/#manual","title":"Manual","text":"<p>Add domains that would bypass the VPN to <code>wireguard/unblock/domains.txt</code>.</p>"},{"location":"hub/#web-ui","title":"Web-UI","text":"<p>There's a basic web-ui for adding sites to the file under <code>wireguard/unblock/index.php</code>.</p> <p>You can host it on SWAG by adding the following mounts to SWAG's compose:</p> <pre><code>    volumes:\n      - ./wireguard/unblock:/config/unblock\n      - ./wireguard/unblock/unblock.subdomain.conf:/config/nginx/proxy-confs/unblock.subdomain.conf:ro\n</code></pre> <p>Recreate SWAG and navigate to <code>https://unblock.domain.com</code>, test that it adds domains to <code>wireguard/unblock/domains.txt</code>.</p>"},{"location":"hub/#routing-other-containers-through-the-tunnel-optional","title":"Routing other containers through the tunnel (optional)","text":"<p>Other containers can be routed through the hub by adding another wireguard container in client mode.</p>"},{"location":"hub/#wireguard-client-container","title":"Wireguard Client Container","text":"<ul> <li>Add a new peer to the wireguard server container using the <code>PEERS</code> environment variable, and recreate it.</li> <li>Create another wireguard container, this time in client mode, according to the VPN Route guide.</li> <li>Copy the peer's <code>./wireguard/peer#/peer#.conf</code> from the server to the client's <code>./wgclient/wg_confs/wg0.conf</code>.</li> <li>Set the <code>Endpoint</code> to be the server container: <code>Endpoint = wireguard:51820</code>.</li> <li>Add <code>PostUp</code> and <code>PreDown</code> rules according to the VPN Route guide.</li> <li>Create the container for changes to take effect.</li> </ul>"},{"location":"hub/#port-forwarding-optional","title":"Port forwarding (optional)","text":"<ul> <li>Uncomment the port forwarding <code>PostUp</code> and <code>PreDown</code> rules in <code>wg1.conf</code> and <code>wg2.conf</code>.</li> <li>Replace <code>10.13.13.2</code> with the wireguard client peer IP.</li> <li>Replace <code>45678</code> with the port of the app.</li> <li>Replace <code>12345</code> with the port you got from the vpn provider for each tunnel.</li> <li>Duplicate the rules for udp if needed.</li> <li>Restart the container for changes to take effect.</li> </ul>"},{"location":"hub/#routing-on-opnsense-optional","title":"Routing on OPNSense (optional)","text":"<p>VLANs and hosts can be routed through the hub via OPNSense.</p> <ul> <li>Add a new peer to the wireguard server container using the <code>PEERS</code> environment variable, and recreate it.</li> <li>Follow https://docs.opnsense.org/manual/how-tos/wireguard-selective-routing.html.</li> </ul> <p>Step 1:</p> <ul> <li>Set <code>Public Key</code> to the server's public key from <code>./wireguard/server/publickey-server</code>.</li> <li>Set <code>Allowed IPs</code> to <code>0.0.0.0/0</code>.</li> <li>Set <code>Endpoint Address</code> to the server's LAN IP.</li> <li>Set <code>Endpoint Port</code> to <code>51820</code>.</li> <li>Set <code>Keepalive</code> to <code>25</code>.</li> </ul> <p>Step 2:</p> <ul> <li>Set <code>Public Key</code> to the peer's public key from <code>./wireguard/peer#/publickey-peer#</code>.</li> <li>Set <code>Private Key</code> to the peer's public key from <code>./wireguard/peer#/privatekey-peer#</code>.</li> <li>Set <code>Listen Port</code> to <code>51820</code>.</li> <li>Set <code>Tunnel Address</code> to the peer's address as listed under<code>[interface]</code> in <code>./wireguard/peer#/peer#.conf</code>.</li> <li>Select your peer under <code>Peers</code>.</li> <li>Check <code>Disable Routes</code>.</li> <li>Set <code>Gateway</code> to <code>10.13.13.200</code>.</li> </ul> <p>Follow the rest of the guide.</p>"},{"location":"hub/#traffic-overview","title":"Traffic Overview","text":"<p>The order of traffic is as follows:</p> <ol> <li>Localhost - traffic to the container.</li> <li>Local network - traffic the DNS and gateway.</li> <li>Wireguard clients - traffic to the wireguard clients.</li> <li>Excluded domains - bypasses the VPN and routes directly.</li> <li>Main VPN tunnel - the VPN tunnel in <code>wg1.conf</code>.</li> <li>Failover VPN tunnel - the VPN tunnel in <code>wg2.conf</code>.</li> </ol>"},{"location":"nextcloud/","title":"Optimizing Nextcloud","text":"<p>The following is a collection of ways to optimize Nextcloud's performance and responsiveness.</p>"},{"location":"nextcloud/#optimization-steps","title":"Optimization Steps","text":"<ul> <li>Use the LSIO image, not the official</li> <li>Use the latest tag which includes php8</li> <li>Enable redis</li> <li>Use mariadb (alpine) or postgres</li> <li>Use nextcloud v22 or higher</li> <li>Use imaginary to speed up thumbnail creation</li> <li>Add the following to <code>/config/php/php-local.ini</code></li> </ul> <pre><code>memory_limit = -1\nopcache.enable = 1\nopcache.enable_cli = 1\nopcache.interned_strings_buffer = 16\nopcache.max_accelerated_files = 130987\nopcache.memory_consumption = 256\nopcache.save_comments = 1\nopcache.revalidate_freq = 1\n</code></pre> <ul> <li>Add the following to <code>/config/php/www2.conf</code> <pre><code>pm = dynamic\npm.max_children = 120\npm.start_servers = 12\npm.min_spare_servers = 6\npm.max_spare_servers = 18\n</code></pre></li> <li>Disable Dark Reader extension on it, if you use it</li> <li>For Nextcloud to identify filesystem changes, add the following to the config: <pre><code>  'filesystem_check_changes' =&gt; 1,\n</code></pre></li> <li>Move <code>/config</code> to a fast disk such as nvme and mount it from there</li> <li>After the initial run move <code>/data/appdata_INSTANCEID</code> to a fast disk such as nvme and mount it from there, add the following under <code>volumes:</code>: (the ID in the directory names will be different) <pre><code>      - /path/to/appdata/appdata_ocytnd8b2l1b:/data/appdata_ocytnd8b2l1b\n</code></pre></li> </ul>"},{"location":"nextcloud/#example-nextcloud-config","title":"Example Nextcloud Config","text":"<p>Located in <code>/config/www/nextcloud/config/config.php</code> <pre><code>  'dbname' =&gt; 'nextcloud',\n  'dbhost' =&gt; 'mariadb',\n  'dbport' =&gt; '',\n  'dbtableprefix' =&gt; 'oc_',\n  'mysql.utf8mb4' =&gt; true,\n  'dbuser' =&gt; 'nextcloud_user',\n  'dbpassword' =&gt; 'DATABASE_PASSWORD',\n  'trusted_proxies' =&gt; ['172.16.0.0/12'],\n  'filesystem_check_changes' =&gt; 1,\n  'memcache.local' =&gt; '\\\\OC\\\\Memcache\\\\APCu',\n  'memcache.distributed' =&gt; '\\\\OC\\\\Memcache\\\\Redis',\n  'memcache.locking' =&gt; '\\\\OC\\\\Memcache\\\\Redis',\n  'enable_previews' =&gt; true,\n  'enabledPreviewProviders' =&gt; \n  array (\n    0 =&gt; 'OC\\\\Preview\\\\Imaginary',\n    1 =&gt; 'OC\\\\Preview\\\\Movie',\n    2 =&gt; 'OC\\\\Preview\\\\MP4',\n  ),\n  'preview_imaginary_url' =&gt; 'http://imaginary:9000',\n  'redis' =&gt; \n  array (\n    'host' =&gt; 'redis',\n    'port' =&gt; 6379,\n  ),\n</code></pre></p>"},{"location":"nextcloud/#example-compose","title":"Example Compose","text":"<pre><code>  nextcloud:\n    image: ghcr.io/linuxserver/nextcloud:latest\n    container_name: nextcloud\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n    volumes:\n      - /path/to/appdata:/config\n      - /path/to/data:/data\n      - /path/to/appdata/appdata_ocytnd8b2l1b:/data/appdata_ocytnd8b2l1b\n    restart: unless-stopped\n    depends_on:\n      - mariadb\n      - redis\n      - imaginary\n  imaginary:\n    image: nextcloud/aio-imaginary:latest\n    container_name: imaginary\n    restart: unless-stopped\n  redis:\n    image: redis:alpine\n    container_name: redis\n    restart: unless-stopped\n  mariadb:\n    image: ghcr.io/linuxserver/mariadb\n    container_name: mariadb\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n      - MYSQL_DATABASE=nextcloud\n      - MYSQL_USER=nextcloud_user\n      - MYSQL_PASSWORD=DATABASE_PASSWORD\n      - MYSQL_ROOT_PASSWORD=ROOT_ACCESS_PASSWORD\n    volumes:\n      - /path/to/appdata:/config\n    restart: unless-stopped\n</code></pre>"},{"location":"opnarp/","title":"OPN-Arp","text":"<p>OPN-Arp on OPNSense allows you to send alerts when new devices are spotted on the network.</p> <p></p>"},{"location":"opnarp/#setup","title":"Setup","text":"<ul> <li>Install the <code>opn-arp</code> plugin via the community repo</li> <li>Enable OPN-Arp under Services &gt; OPN-Arp</li> <li>Enable Monit under Services &gt; Monit</li> <li>Add a new entry under Service Tests Settings:<ul> <li>Name: <code>MAC pair</code></li> <li>Condition: <code>content = \"MAC pair\"</code></li> <li>Action: <code>Alert</code> for an email alert or <code>Execute</code> and <code>/root/gotify.sh</code> for gotify (script below)</li> </ul> </li> <li>Add a new entry under Service Settings:<ul> <li>Name: <code>MAC_PAIR</code></li> <li>Type: <code>File</code></li> <li>Path: <code>/var/log/system/latest.log</code></li> <li>Tests: <code>MAC Pair</code></li> </ul> </li> <li>Add a new entry under Alert Settings: (only for email alerts)<ul> <li>Recipient: <code>your@email.com</code></li> <li>Mail Format: <code>From: your@email.com</code></li> </ul> </li> <li>Fill the mail server details under general (only for email alerts)</li> </ul>"},{"location":"opnarp/#gotify-alerts","title":"Gotify Alerts","text":"<ul> <li>Connect to OPNSense via SSH</li> <li>Execute <code>touch /root/gotify.sh &amp;&amp; chmod +x /root/gotify.sh</code></li> <li>Paste the following script into <code>/root/gotify.sh</code>:<pre><code>#!/usr/local/bin/bash\n\nif [[ $MONIT_DESCRIPTION =~ \"MAC pair\" ]]; then\n        ip=$(echo $MONIT_DESCRIPTION | cut -d '(' -f 2  | cut -d ')' -f 1)\n        mac=$(echo $MONIT_DESCRIPTION | cut -d '(' -f 2  | cut -d ')' -f 2)\n        host=$(host $ip | cut -d ' ' -f 5)\n        title=\"New device spotted\"\n        msg=\"IP: $ip - MAC: $mac - Hostname: $host\"\nelse\n        title=$MONIT_SERVICE\n        msg=$MONIT_DESCRIPTION\nfi\n\ncurl -X POST \"https://gotify.domain.com/message?token=yourtoken\" -F \"title=$title\" -F \"message=$msg\"\n</code></pre> </li> </ul> <ul> <li>Edit <code>gotify.domain.com</code> and <code>yourtoken</code> accordingly</li> <li>Create a file under <code>/usr/local/etc/rc.syshook.d/start/99-opnarp</code>:<pre><code>#!/bin/sh\n\nchmod +x /usr/local/etc/rc.d/opnarp\n</code></pre> </li> </ul> <ul> <li> <p>Test it by running:</p> <pre><code>echo \"&lt;29&gt;1 2022-08-29T20:16:44+03:00 router.home root 59285 - [meta sequenceId=1] New IPv4/MAC pair seen: (10.1.3.22)3a:d1:ee:bc:20:2f\" &gt;&gt; /var/log/system/latest.log\n</code></pre> </li> </ul>"},{"location":"phone/","title":"Periodic Phone Wipe Notes","text":"<p>I got into the habit of wiping my phone every 6 months (takes about an hour) in order to:</p> <ul> <li>Streamline the process</li> <li>Validate the backups</li> <li>Re-examine which apps should stay</li> <li>Remove leftover data</li> <li>Figure out the pains and find alternatives</li> </ul> <p>My phone is a Pixel 8 with GrapheneOS, it has an always-on VPN, and a lot of self-hosting related apps.</p>"},{"location":"phone/#backup","title":"Backup","text":"<ul> <li>Snapshot<ul> <li>Homepages</li> <li>Toggles</li> <li>App drawer</li> </ul> </li> <li>Export<ul> <li>Wireguard</li> <li>Gadgetbridge</li> <li>Lawnchair</li> <li>Ntfy</li> <li>Termux</li> </ul> </li> <li>Backup the entire phone to the PC</li> </ul>"},{"location":"phone/#install","title":"Install","text":"<ul> <li>Follow the official documentation.</li> </ul>"},{"location":"phone/#configuration","title":"Configuration","text":"<ul> <li>Copy exports and snapshots back</li> <li>Initial configuration<ul> <li>Network &amp; Internet<ul> <li>Private DNS: quietsy.dns.domain.tld</li> <li>Internet connectivity checks: off</li> <li>Internet<ul> <li>Network preferences<ul> <li>Turn on wi-fi automatically: off</li> <li>Notify for public networks: off</li> </ul> </li> </ul> </li> <li>SIMs<ul> <li>VoLTE: off</li> <li>Preferred network type: LTE</li> <li>Allow 2G: off</li> </ul> </li> <li>VPN<ul> <li>Always-on VPN: on</li> <li>Block connections without VPN: off</li> </ul> </li> </ul> </li> <li>Connected devices<ul> <li>Connection preferences<ul> <li>NFC: off</li> <li>Printing: off</li> </ul> </li> </ul> </li> <li>Apps<ul> <li>Sandboxed Google Play<ul> <li>Reroute location requests to the OS: on</li> <li>Google location accuracy: off</li> </ul> </li> <li>Special app access<ul> <li>Special access to hardware accelerators for Google apps: on</li> <li>Unrestricted mobile data: Linphone, FindMyDevice</li> </ul> </li> </ul> </li> <li>Notifications<ul> <li>Wireless emergency alerts: off</li> <li>Hide silent notifications in status bar: on</li> <li>Notification dot on app icon: on</li> <li>Enhanced notifications: on</li> <li>Notifications on lock screen: off</li> <li>Bubbles: on</li> </ul> </li> <li>Sound &amp; vibration<ul> <li>Spatial audio: off</li> <li>Vibration &amp; haptics: on</li> <li>Dial pad tones: off</li> <li>Screen locking sound: off</li> <li>Charging sounds and vibrations: off</li> <li>Tap &amp; click sounds: off</li> <li>Always show icon when in vibrate mode: on</li> <li>Set ringtone and notification sound</li> </ul> </li> <li>Display<ul> <li>Adaptive brightness: on</li> <li>Lock screen<ul> <li>Privacy: don't show notifications at all</li> <li>Shortcuts<ul> <li>Flashlight</li> <li>Camera</li> </ul> </li> <li>Dynamic clock: on</li> <li>Always show time and info: off</li> <li>Tap to check phone: on</li> <li>Lift to check phone: off</li> <li>Wake screen for notifications: on</li> </ul> </li> <li>Screen timeout: 1 minute</li> <li>Dark theme: on</li> <li>Night light: off</li> <li>Auto-rotate screen: off</li> <li>Smooth display: off</li> <li>Increase touch sensitivity: off</li> <li>Screen saver: off</li> </ul> </li> <li>Wallpaper &amp; style<ul> <li>Set wallpaper</li> <li>Show notifications on the lock screen: off</li> </ul> </li> <li>Battery<ul> <li>Battery saver: off</li> <li>Charging optimization: limit to 80%</li> <li>Battery percentage: on</li> <li>Battery share: off</li> </ul> </li> <li>System<ul> <li>Keyboard<ul> <li>Futo<ul> <li>Keyboard &amp; Typing<ul> <li>Show number row: on</li> <li>Show action/suggestions bar: on</li> <li>Automatic spaces mode: automatically insert spaces only after inserting suggestions</li> <li>Swipe typing: on</li> <li>Auto-correction: on</li> <li>Auto-capitalization: on</li> <li>Double-space period: on</li> <li>Sound on keypress: off</li> <li>Popup on keypress: on</li> <li>Vibrate on keypress: on</li> <li>Vibration: minimum</li> <li>Clipboard history: on</li> </ul> </li> </ul> </li> </ul> </li> <li>Gestures<ul> <li>Quickly open camera: on</li> <li>Navigation mode: gesture navigation</li> <li>Tap to check phone: on</li> <li>Lift to check phone: off</li> </ul> </li> <li>Date &amp; time<ul> <li>Use 24-hour format: on</li> </ul> </li> <li>System updates<ul> <li>Require battery above warning: on</li> <li>Require device to be charging: off</li> <li>Automatic reboot: on</li> </ul> </li> <li>Developer options<ul> <li>OEM unlocking: off</li> <li>USB debugging: off</li> <li>Wireless debugging: off</li> <li>Mobile data always active: off</li> <li>Disable bluetooth LE audio hardware offload: on</li> </ul> </li> </ul> </li> <li>Security &amp; privacy<ul> <li>Security<ul> <li>Screen lock<ul> <li>Scramble PIN input layout: on</li> <li>Enhanced PIN privacy: on</li> <li>Lock after screen timeout: 5 seconds</li> <li>Power button instantly locks: on</li> <li>Allow camera access when locked: on</li> </ul> </li> <li>Fingerprint unlock<ul> <li>Add both hands</li> <li>Use for screen unlocking: on</li> </ul> </li> </ul> </li> <li>Privacy<ul> <li>Camera access: on</li> <li>Microphone access: on</li> <li>Show clipboard access: on</li> <li>Show passwords: off</li> <li>Allow sensors permission to apps by default: off</li> <li>Save screenshot timestamp to EXIF: off</li> <li>Notifications on lock screen: all</li> <li>Show media on lock screen: on</li> </ul> </li> <li>Exploit protection<ul> <li>Auto reboot: 18 hours</li> <li>USB-C port: charging-only when locked, except before first unlock</li> <li>Hardened memory allocator: disable camera</li> <li>Memory tagging: check</li> <li>Native code debugging: check, disable protonmail</li> <li>Webview JIT: check, disable PDF viewer</li> <li>DCL via memory: check, allow google play services, vanadium</li> <li>DCL via storage: off</li> <li>Secure app spawning: on</li> </ul> </li> <li>More privacy &amp; security<ul> <li>Allow sensors permission to apps by default: off</li> <li>Notify about system process crashes: on</li> <li>Automatic exploit protection compatibility mode: on</li> </ul> </li> </ul> </li> <li>Location<ul> <li>Location services<ul> <li>Wi-fi scanning: off</li> <li>Bluetooth scanning: off</li> </ul> </li> </ul> </li> <li>Safety &amp; emergency<ul> <li>Wireless emergency alerts: off</li> </ul> </li> </ul> </li> </ul>"},{"location":"phone/#apps","title":"Apps","text":"<p>App store priority for installation: google play store &gt; obtainium (github) &gt; obtainium (f-droid)</p> <ul> <li>Audiobookshelf<ul> <li>Permissions: network</li> <li>Background usage: optimized</li> </ul> </li> <li>Auditor<ul> <li>Enable remote verification: on</li> <li>Permissions: network, notifications</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Bitwarden (password manager)<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Breezy weather<ul> <li>Permissions: network, notifications, sensors</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Davx5 (sync contacts)<ul> <li>Permissions: calendar, contacts, network, notifications</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Discord<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Finamp (music)<ul> <li>Permissions: network</li> <li>Background usage: optimized</li> </ul> </li> <li>Findmydevice<ul> <li>Permissions: camera, contacts, location, network, notifications, phone, sensors</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Floccus (bookmark sync)<ul> <li>Permissions: network</li> <li>Background usage: off</li> </ul> </li> <li>FUTO keyboard<ul> <li>Permissions: microphone</li> <li>Background usage: optimized</li> </ul> </li> <li>Gadgetbridge (cloudless gadgets)<ul> <li>Permissions: calendar, call logs, contacts, location, nearby devices, network, notifications, phone, sensors, sms</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Google Play Services (sandboxed)<ul> <li>Permissions: network</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Google Play Store (sandboxed)<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Google Services Framework (sandboxed)<ul> <li>Permissions: network</li> <li>Background usage: optimized</li> </ul> </li> <li>Immich (photos)<ul> <li>Permissions: network</li> <li>Background usage: optimized</li> </ul> </li> <li>Jellyfin (media)<ul> <li>Permissions: network</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Lawnchair (launcher)<ul> <li>Permissions: nearby devices</li> <li>Background usage: optimized</li> </ul> </li> <li>LibreTube (youtube)<ul> <li>Permissions: network</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Linphone (voip)<ul> <li>Permissions: contacts, microphone, network, notifications, phone, sensors</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Nextcloud news (rss reader)<ul> <li>Permissions: network</li> <li>Background usage: none</li> </ul> </li> <li>Nextcloud (self-hosted cloud)<ul> <li>Permissions: network, notifications</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Nextcloud notes<ul> <li>Permissions: network</li> <li>Background usage: none</li> </ul> </li> <li>Ntfy (notifications)<ul> <li>Permissions: network, notifications</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Obtainium<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Organic maps (navigation)<ul> <li>Permissions: location, network, sensors</li> <li>Background usage: none</li> </ul> </li> <li>OSS document scanner<ul> <li>Permissions: none</li> <li>Background usage: optimized</li> </ul> </li> <li>Pixel Camera<ul> <li>Permissions: camera, microphone, notifications, photos and videos (storage scope /DCIM/), sensors</li> <li>Background usage: optimized</li> </ul> </li> <li>Proton calendar<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Proton mail<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Signal<ul> <li>Permissions: contacts, network, notifications, phone, sensors</li> <li>Background usage: optimized</li> </ul> </li> <li>SimpleLogin<ul> <li>Permissions: network</li> <li>Background usage: none</li> </ul> </li> <li>Termux<ul> <li>Permissions: files (storage scope /backup/), network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Vanadium (browser)<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>VLC<ul> <li>Permissions: network</li> <li>Background usage: optimized</li> </ul> </li> <li>Wireguard (vpn)<ul> <li>Permissions: network</li> <li>Background usage: optimized</li> </ul> </li> <li>Configure all apps</li> <li>Set folders to auto upload to nextcloud<ul> <li>Photos</li> <li>Videos</li> <li>Call recordings</li> <li>Snapshots</li> <li>Backup</li> </ul> </li> </ul>"},{"location":"piped/","title":"Piped - Getting Started","text":"<p>Piped is an alternative YouTube frontend which is efficient by design.</p>"},{"location":"piped/#compose","title":"Compose","text":"<p>Create the following containers:</p> <pre><code>  pipeddb:\n    image: postgres:13-alpine\n    container_name: pipeddb\n    volumes:\n      - /path/to/pipeddb:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_DB=piped\n      - POSTGRES_USER=piped\n      - POSTGRES_PASSWORD=&lt;PASSWORD&gt; # Set a database password\n    restart: always\n\n  pipedproxy:\n    image: 1337kavin/ytproxy\n    container_name: pipedproxy\n    user: \"1000:1000\" # Replace with the user and group IDs\n    volumes:\n      - /path/to/pipedproxy:/app/socket\n    restart: always\n\n  pipedfe:\n    image: 1337kavin/piped-frontend\n    container_name: pipedfe\n    # Replace pipedapi.mydomain.com with the API subdomain\n    entrypoint: ash -c 'sed -i s/pipedapi.kavin.rocks/pipedapi.mydomain.com/g /usr/share/nginx/html/assets/* &amp;&amp; /docker-entrypoint.sh &amp;&amp; nginx -g \"daemon off;\"' \n    restart: always\n\n  pipedapi:\n    image: 1337kavin/piped\n    container_name: pipedapi\n    volumes:\n      - /path/to/piped/config.properties:/app/config.properties:ro\n    restart: always\n</code></pre> <p>You may need to <code>chown -R 1000:1000 /path/to/pipedproxy</code> with your user and group ID.</p>"},{"location":"piped/#configuration","title":"Configuration","text":"<p>Set the following configuration in <code>/path/to/piped/config.properties</code>:</p> <pre><code># The port to Listen on.\nPORT: 8080\n\n# The number of workers to use for the server\nHTTP_WORKERS: 2\n\n# Proxy\nPROXY_PART: https://pipedproxy.mydomain.com\n\n# Outgoing HTTP Proxy - eg: 127.0.0.1:8118\n#HTTP_PROXY: 127.0.0.1:8118\n\nFRONTEND_URL: https://piped.mydomain.com\n\n# Captcha Parameters\n#CAPTCHA_BASE_URL: https://api.capmonster.cloud/\n#CAPTCHA_API_KEY: INSERT_HERE\n\n# Public API URL\nAPI_URL: https://pipedapi.mydomain.com\n\n# Hibernate properties\nhibernate.connection.url: jdbc:postgresql://pipeddb:5432/piped\nhibernate.connection.driver_class: org.postgresql.Driver\nhibernate.dialect: org.hibernate.dialect.PostgreSQL10Dialect\nhibernate.connection.username: piped\nhibernate.connection.password: &lt;PASSWORD&gt; # Replace with the database password\n</code></pre>"},{"location":"piped/#reverse-proxy","title":"Reverse Proxy","text":"<pre><code>server {\n    listen 443 ssl;\n    server_name piped.mydomain.com; # Set the API domain\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location / {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        set $upstream_app pipedfe;\n        set $upstream_port 80;\n        set $upstream_proto http;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n    }\n}\n\nserver {\n    listen 443 ssl;\n    server_name pipedapi.mydomain.com; # Set the frontend domain\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location / {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        set $upstream_app pipedapi;\n        set $upstream_port 8080;\n        set $upstream_proto http;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n    }\n    location /webhooks/pubsub {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        set $upstream_app pipedapi;\n        set $upstream_port 8080;\n        set $upstream_proto http;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n    }\n}\n\nserver {\n    listen 443 ssl;\n    server_name pipedproxy.mydomain.com; # Set the proxy domain\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location ~ (/videoplayback|/api/v4/|/api/manifest/) {\n        proxy_pass http://unix:/var/run/ytproxy/http-proxy.sock;\n        add_header Access-Control-Allow-Origin *;\n        add_header Access-Control-Allow-Headers *;\n        if ($request_method = OPTIONS ) {\n            return 200;\n        }\n        proxy_buffering on;\n        proxy_set_header Host $arg_host;\n        proxy_ssl_server_name on;\n        proxy_set_header X-Forwarded-For \"\";\n        proxy_set_header CF-Connecting-IP \"\";\n        proxy_hide_header \"alt-svc\";\n        sendfile on;\n        sendfile_max_chunk 512k;\n        tcp_nopush on;\n        aio threads=default;\n        aio_write on;\n        directio 2m;\n        proxy_hide_header Cache-Control;\n        proxy_hide_header etag;\n        proxy_http_version 1.1;\n        proxy_set_header Connection keep-alive;\n        proxy_max_temp_file_size 0;\n        access_log off;\n        add_header Cache-Control private always;\n        proxy_hide_header Access-Control-Allow-Origin;\n    }\n\n    location / {\n        proxy_pass http://unix:/var/run/ytproxy/http-proxy.sock;\n        add_header Access-Control-Allow-Origin *;\n        add_header Access-Control-Allow-Headers *;\n        if ($request_method = OPTIONS ) {\n            return 200;\n        }\n        proxy_buffering on;\n        proxy_set_header Host $arg_host;\n        proxy_ssl_server_name on;\n        proxy_set_header X-Forwarded-For \"\";\n        proxy_set_header CF-Connecting-IP \"\";\n        proxy_hide_header \"alt-svc\";\n        sendfile on;\n        sendfile_max_chunk 512k;\n        tcp_nopush on;\n        aio threads=default;\n        aio_write on;\n        directio 2m;\n        proxy_hide_header Cache-Control;\n        proxy_hide_header etag;\n        proxy_http_version 1.1;\n        proxy_set_header Connection keep-alive;\n        proxy_max_temp_file_size 0;\n        access_log off;\n        add_header Cache-Control \"public, max-age=604800\";\n        proxy_hide_header Access-Control-Allow-Origin;\n    }\n}\n</code></pre> <p>All the sub-domains can remain internal-only except for the following domain that must be exposed for subscriptions to work:</p> <pre><code>    location /webhooks/pubsub {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        set $upstream_app pipedapi;\n        set $upstream_port 8080;\n        set $upstream_proto http;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n    }\n</code></pre> <p>And finally, add the following volume to SWAG: <pre><code>  - /path/to/pipedproxy:/var/run/ytproxy\n</code></pre></p>"},{"location":"searx/","title":"SearXNG","text":"<p>SearXNG is a free metasearch engine with the aim of protecting the privacy of its users. To this end, Searx does not share users' IP addresses or search history with the search engines from which it gathers results. Tracking cookies served by the search engines are blocked, preventing user-profiling-based results modification.</p>"},{"location":"searx/#installation","title":"Installation","text":""},{"location":"searx/#compose","title":"Compose","text":"<pre><code>  searxng:\n    image: searxng/searxng\n    container_name: searxng\n    volumes:\n      - /path/to/searxng:/etc/searxng\n    environment:\n      - BASE_URL=https://search.yourdomain.com/\n    ports:\n      - 8080:8080\n    restart: always\n</code></pre>"},{"location":"searx/#reverse-proxy","title":"Reverse Proxy","text":"<pre><code>server {\n    listen 443 ssl;\n    server_name search.yourdomain.com;\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location / {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        set $upstream_app searxng;\n        set $upstream_port 8080;\n        set $upstream_proto http;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n    }\n}\n</code></pre>"},{"location":"searx/#settings","title":"Settings","text":"<p>The settings file is <code>/path/to/searx/settings.yml</code>, it can seem overwhelming but the majority of it are the search engine configuration which can be enabled/disabled from the UI.</p> <p>These settings may require changing in the file: <pre><code># see https://docs.searxng.org/admin/engines/settings.html#use-default-settings\nuse_default_settings: true\ngeneral:\n  debug: false\n  instance_name: \"Search\"\n  privacypolicy_url: false\n  donation_url: false\n  contact_url: false\n  enable_metrics: false\nserver:\n  secret_key: \"CHANGE THIS\"\n  limiter: false  # can be disabled for a private instance\n  image_proxy: true\nui:\n  static_use_hash: true\n  default_theme: simple\n  theme_args:\n    simple_style: dark\n  infinite_scroll: true\n  query_in_title: true\nsearch:\n  autocomplete: \"duckduckgo\"\n  default_lang: \"all\"\nenabled_plugins:\n  - 'Hash plugin'\n  - 'Search on category select'\n  - 'Self Informations'\n  - 'Tracker URL remover'\n  - 'Hostnames plugin'\n  - 'Open Access DOI rewrite'\n  - 'Unit converter plugin'\nhostnames:\n  high_priority:\n    - '(.*)\\/blog\\/(.*)'\n    - '(.*\\.)?wikipedia.org$'\n    - '(.*\\.)?github.com$'\n    - '(.*\\.)?reddit.com$'\n    - '(.*\\.)?linuxserver.io$'\n    - '(.*\\.)?docker.com$'\n    - '(.*\\.)?archlinux.org$'\n    - '(.*\\.)?stackoverflow.com$'\n    - '(.*\\.)?askubuntu.com$'\n    - '(.*\\.)?superuser.com$'\n  remove:\n    - '(.*\\.)?facebook.com$'\n    - '(.*\\.)?instagram.com$'\n    - '(.*\\.)?codegrepper.com$'\n    - '(.*\\.)?w3schools.com$'\n    - '(.*\\.)?geeksforgeeks.org$'\n    - '(.*\\.)?stackshare.io$'\n    - '(.*\\.)?tutorialspoint.com$'\n    - '(.*\\.)?answeright.com$'\n    - '(.*\\.)?askdev.info$'\n    - '(.*\\.)?askdev.io$'\n    - '(.*\\.)?blogmepost.com$'\n    - '(.*\\.)?c-sharpcorner.com$'\n    - '(.*\\.)?code-examples.net$'\n    - '(.*\\.)?codeflow.site$'\n    - '(.*\\.)?gitmemory.cn$'\n    - '(.*\\.)?gitmemory.com$'\n    - '(.*\\.)?intellipaat.com$'\n    - '(.*\\.)?javaer101.com$'\n    - '(.*\\.)?programmerstart.com$'\n    - '(.*\\.)?programmersought.com$'\n    - '(.*\\.)?qastack.com$'\n    - '(.*\\.)?roboflow.ai$'\n    - '(.*\\.)?stackanswers.net$'\n    - '(.*\\.)?stackoom.com$'\n    - '(.*\\.)?stackovernet.com$'\n    - '(.*\\.)?stackovernet.xyz$'\n    - '(.*\\.)?stackoverrun.com$'\n    - '(.*\\.)?thetopsites.net$'\n    - '(.*\\.)?ubuntugeeks.com$'\n    - '(.*\\.)?cyberciti.biz$'\n    - '(.*\\.)?ispycode.com$'\n    - '(.*\\.)?reposhub.com$'\n    - '(.*\\.)?githubmemory.com$'\n    - '(.*\\.)?issueexplorer.com$'\n    - '(.*\\.)?tabnine.com$'\n    - '(.*\\.)?gitcode.net$'\n    - '(.*\\.)?command-not-found.com$'\n    - '(.*\\.)?im-coder.com$'\n    - '(.*\\.)?i-harness.com$'\n  replace:\n    '(.*\\.)?reddit.com$': 'some.redlib.com'\n    '(.*\\.)?redd.it$': 'some.redlib.com'\n    '(.*\\.)?youtube.com$': 'some.piped.com'\n    '(.*\\.)?youtu.be$': 'some.piped.com'\n</code></pre></p>"},{"location":"searx/#rate-limiting-optional","title":"Rate Limiting (Optional)","text":"<p>Rate limiting can be enabled by adding a redis container and setting these: <pre><code>server:\n  limiter: true  # can be disabled for a private instance\nredis:\n  url: redis://redis:6379/0\n</code></pre></p> <p>An example compose can be found here.</p>"},{"location":"secure/","title":"Securing SWAG","text":"<p>SWAG is a reverse proxy that allows you to expose your self-hosted apps to the world, but that comes with risks.</p> <p>We can mitigate some risks by fine-tuning SWAG and how we access it:</p> <ul> <li>Prevent accessing some apps via the internet while exposing others.</li> <li>Set up brute-force protection via Crowdsec/Fail2Ban.</li> <li>Set up geoblock to whitelist/blacklist countries via DBIP/Maxmind.</li> <li>Prevent your apps from appearing in search results.</li> <li>Set up SSO via Authelia/Authentik.</li> <li>Monitor SWAG via a dashboard.</li> <li>Access your apps through Wireguard instead of exposing them.</li> </ul>"},{"location":"secure/#requirements","title":"Requirements","text":"<ul> <li>A working instance of SWAG.</li> </ul>"},{"location":"secure/#internal-applications","title":"Internal Applications","text":"<p>Only expose apps you want to share with others and must expose, keep the rest internal and use WireGuard to access them.</p>"},{"location":"secure/#requirements_1","title":"Requirements","text":"<ul> <li>Split DNS - the source IP on requests needs to be local for allow/deny to work properly.</li> </ul> <p>Create a file called <code>nginx/internal.conf</code> with the following configuration:</p> <pre><code>allow 192.168.1.0/24; # Replace with your LAN subnet\ndeny all;\n</code></pre> <p>Utilize the LAN filter in your configuration by adding the following line inside the server block for every application you want to protect.</p> <pre><code>    include /config/nginx/internal.conf;\n</code></pre> <p>Example:</p> <pre><code>server {\n    listen 443 ssl;\n    listen [::]:443 ssl;\n\n    server_name collabora.*;\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n    include /config/nginx/internal.conf;\n\n    location / {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        set $upstream_app collabora;\n        set $upstream_port 9980;\n        set $upstream_proto https;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n    }\n}\n</code></pre> <p>Repeat the process for all internal applications.</p>"},{"location":"secure/#brute-force-protection","title":"Brute-Force Protection","text":"<p>Crowdsec and Fail2Ban can prevent brute-force attacks by monitoring the logs of apps and banning IPs that fail multiple login attempts.</p> <p>SWAG comes with Fail2Ban pre-configured with a few basic protections, you can fine-tune it specifically for your apps, or disable it and set up Crowdsec instead.</p>"},{"location":"secure/#crowdsec","title":"Crowdsec","text":"<p>Crowdsec is a free, open-source and collaborative IPS; it's like fail2ban but you share your bans with all of the other users to try and pre-emptively block malicious hosts.</p> <p>Follow this blog post to set it up in SWAG.</p>"},{"location":"secure/#fail2ban","title":"Fail2Ban","text":"<p>Fail2Ban is an intrusion prevention software that protects external applications from brute-force attacks. Attackers that fail to login to your applications a certain number of times will get blocked from accessing all of your applications. Fail2Ban looks for failed login attempts in log files, counts the failed attempts in a short period, and bans the IP address of the attacker.</p>"},{"location":"secure/#the-following-is-an-example-of-setting-up-nextcloud-in-fail2ban-configure-other-apps-in-the-same-way","title":"The following is an example of setting up Nextcloud in Fail2Ban, configure other apps in the same way.","text":"<p>Mount the application logs to SWAG's container by adding a volume for the log to the compose yaml:</p> <pre><code>      - /path/to/nextcloud/logs:/nextcloud:ro\n</code></pre> <p>Note that you should only mount the parent folders, log files can rotate.</p> <p>Recreate the container with the log mount, then create a file called <code>nextcloud.local</code> under <code>fail2ban/filter.d</code>:</p> <pre><code>[Definition]\nfailregex=^.*Login failed: '?.*'? \\(Remote IP: '?&lt;ADDR&gt;'?\\).*$\n          ^.*\\\"remoteAddr\\\":\\\"&lt;ADDR&gt;\\\".*Trusted domain error.*$\nignoreregex =\n</code></pre> <p>Before making your own Fail2Ban filter for apps search online for existing one, most chances someone already made it.</p> <p>The filter containes a pattern by which failed login attempts are matched. Test the pattern by failing to login to nextcloud and look for the entry corresponding to your failed attempt.</p> <pre><code>{\"reqId\":\"k5j5H7K3eskXt3hCLSc4i\",\"level\":2,\"time\":\"2020-10-14T22:56:14+00:00\",\"remoteAddr\":\"1.2.3.4\",\"user\":\"--\",\n\"app\":\"no app in context\",\"method\":\"POST\",\"url\":\"/login\",\"message\":\"Login failed: username (Remote IP: 5.5.5.5)\",\n\"userAgent\":\"Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/5.6.7.8 Mobile \nSafari/537.36\",\"version\":\"19.0.4.2\"}\n</code></pre> <p>Test the pattern in <code>nextcloud.local</code> by running the following command on the docker host:</p> <pre><code>docker exec swag fail2ban-regex /nextcloud/nextcloud.log /config/fail2ban/filter.d/nextcloud.local\n</code></pre> <p>If the pattern works, you will see matches corresponding to the amount of failed login attempts:</p> <pre><code>Lines: 92377 lines, 0 ignored, 2 matched, 92375 missed\n[processed in 7.51 sec]\n</code></pre> <p>The final step is to activate the jail, add the following to <code>fail2ban/jail.local</code>:</p> <pre><code>[nextcloud]\nenabled = true\nport    = http,https\nfilter  = nextcloud\nlogpath = /nextcloud/nextcloud.log\naction  = iptables-allports[name=nextcloud]\n</code></pre> <p>The logpath is slightly different for applications that have multiple log files with dates:</p> <pre><code>[jellyfin]\nenabled  = true\nfilter   = jellyfin\nport     = http,https\nlogpath  = /jellyfin/log*.log\naction   =  iptables-allports[name=jellyfin]\n</code></pre> <p>Repeat the process for every app you expose, you can find Fail2Ban configurations for most applications on the internet.</p> <p>If you need to unban an IP address that was blocked, run the following command on the docker host:</p> <pre><code>docker exec swag fail2ban-client unban &lt;ip address&gt;\n</code></pre>"},{"location":"secure/#geoblock","title":"Geoblock","text":"<p>Geoblock significantly reduces the attack surface of SWAG by restricting access based on countries.</p> <p>Follow the instructions of one of the following mods to set it up:</p> <ul> <li>DBIP mod</li> <li>Maxmind mod</li> </ul> <p>DBIP doesn't require an account, but Maxmind might be more accurate in some cases.</p>"},{"location":"secure/#search-results","title":"Search Results","text":"<p>You can prevent apps from appearing in search engine results and being crawled by web crawlers. </p> <p>Note that not all search engines and web crawlers respect this tag, but it significantly reduces the amount.</p> <p>Add the following to <code>ssl.conf</code> to enable it on all apps:</p> <pre><code>add_header X-Robots-Tag \"noindex, nofollow, nosnippet, noarchive\";\n</code></pre> <p>To disable on a specific app, add the following line to the app's proxy-conf inside the server tag:</p> <pre><code>add_header X-Robots-Tag \"\";\n</code></pre>"},{"location":"secure/#sso","title":"SSO","text":"<p>Setting up SSO will provide an additional layer of security and protect you against login bypass exploits in apps.</p> <ul> <li>Authelia</li> <li>Authentik</li> </ul> <p>Note that api endpoints shouldn't have SSO for them to function properly.</p>"},{"location":"secure/#monitor","title":"Monitor","text":"<p>Use monitoring solutions such as SWAG Dashboard to keep an eye on the traffic going through SWAG and check for suspicious activity such as:</p> <ul> <li>Many hits from a country unrelated to your users.</li> <li>Many requests to a specific page or static file.</li> <li>Referers that shouldn't refer to your domain.</li> <li>Many hits on status codes that are not 2xx.</li> </ul>"},{"location":"secure/#vpn","title":"VPN","text":"<p>The most effective security you can implement is to stop exposing your apps entirely, and instead access them via WireGuard.</p>"},{"location":"secure/#requirements_2","title":"Requirements","text":"<ul> <li>A working instance of WireGuard.</li> <li>Split DNS - the source IP on requests needs to be local for SWAG to work without being exposed.</li> <li>DNS Validation - allows you to get an SSL certificate without port forwarding.</li> </ul> <p>Once you've set up wireguard, split DNS, and DNS validation, you can remove the port forwarding on your router and remove your domain's public DNS records on your public DNS provider (not the local DNS).</p>"},{"location":"setup/","title":"Setup Diagram Template","text":"<p>Use the following template to create a diagram of your setup.</p> <p></p>"},{"location":"setup/#requirements","title":"Requirements","text":"<p>The online draw.io or the self-hosted draw.io, here is an example compose: <pre><code>  drawio:\n    image: jgraph/drawio:alpine\n    container_name: drawio\n    ports:\n        - 8080:8080\n    restart: always\n</code></pre></p>"},{"location":"setup/#download","title":"Download","text":""},{"location":"simplelogin/","title":"Simplelogin","text":""},{"location":"simplelogin/#strategy","title":"Strategy","text":""},{"location":"simplelogin/#notes","title":"Notes","text":"<ul> <li>Check the reputation of your VPS IP before proceeding.</li> <li>Follow the official documentation to set up the domain.</li> <li>Read about each environment variable of simplelogin and postfix.</li> <li>Using SWAG to generate certs and then mounting the certs to postfix.</li> <li>SWAG has the following post-renewal hook under <code>./swag/etc/letsencrypt/renewal-hooks/post/postfix.sh</code>:<pre><code>#!/usr/bin/with-contenv bash\n\ntouch /config/etc/letsencrypt/postfix_renew\n</code></pre> </li> </ul> <ul> <li>Postfix has the following script mounted to <code>/etc/periodic/hourly/renew-postfix-tls</code> for reloading on cert updates:<pre><code>#!/usr/bin/env bash\n\nset -e\n\nif [ -f ${RENEW_PATH} ]; then\n    /src/generate_config.py --postfix\n    postfix reload\n    rm -f ${RENEW_PATH}\nfi\n</code></pre> </li> </ul> <ul> <li>Setting up Crowdsec, Geoblock, and Firehol is highly recommended.</li> <li>After upgrading simplelogin run:<pre><code>docker exec slapp alembic upgrade head\n</code></pre> </li> </ul> <ul> <li>Check the dmarc once you finish setting everything up.</li> <li>Check the spammyness once you finish setting everything up.</li> </ul>"},{"location":"simplelogin/#example-compose","title":"Example Compose","text":"<pre><code>  simplelogin:\n    image: lscr.io/linuxserver-labs/simplelogin:latest\n    container_name: simplelogin\n    volumes:\n      - ./mail/sl:/config\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n      - DB_URI=postgresql://dbuser:dbpassword@sldb:5432/simplelogin\n    ports:\n      - 7777:7777\n    restart: unless-stopped\n  sldb:\n    image: postgres:12.1-alpine\n    container_name: sldb\n    volumes:\n      - ./mail/db:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_USER=dbuser\n      - POSTGRES_PASSWORD=dbpassword\n      - POSTGRES_DB=simplelogin\n    restart: unless-stopped\n  postfix:\n    container_name: postfix\n    image: simplelogin/postfix:4.2.0\n    ports:\n      - \"0.0.0.0:25:25\"\n      - \"0.0.0.0:465:465\"\n    volumes:\n      - ./mail/db:/var/lib/postgresql/data\n      - ./swag/etc/letsencrypt:/etc/letsencrypt\n      - ./mail/check-cert.sh:/etc/periodic/hourly/renew-postfix-tls:ro\n    environment:\n      - DB_HOST=sldb\n      - DB_USER=dbuser\n      - DB_PASSWORD=dbpassword\n      - DB_NAME=simplelogin\n      - EMAIL_HANDLER_HOST=simplelogin\n      - POSTFIX_FQDN=mail.domain.com\n      - ALIASES_DEFAULT_DOMAIN=domain.com\n      - LETSENCRYPT_EMAIL=support@domain.com\n      - TLS_KEY_FILE=/etc/letsencrypt/live/domain.com/privkey.pem\n      - TLS_CERT_FILE=/etc/letsencrypt/live/domain.com/fullchain.pem\n      - RENEW_PATH=/etc/letsencrypt/postfix_renew\n      - POSTFIX_DQN_KEY=dqnkey\n      - SIMPLELOGIN_COMPATIBILITY_MODE=v4\n    restart: unless-stopped\n</code></pre>"},{"location":"simplelogin/#example-env-file","title":"Example ENV File","text":"<pre><code>URL=https://simplelogin.domain.com\nEMAIL_DOMAIN=domain.com\nSUPPORT_EMAIL=support@domain.com\nADMIN_EMAIL=support@domain.com\nEMAIL_SERVERS_WITH_PRIORITY=[(10, \"mail.domain.com.\")]\nDKIM_PRIVATE_KEY_PATH=/config/dkim.key\nDB_URI=postgresql://dbuser:dbpassword@sldb:5432/simplelogin\nFLASK_SECRET=secret123\nGNUPGHOME=/config/gnupg\nLOCAL_FILE_UPLOAD=1\nPOSTFIX_SERVER=postfix\nDISABLE_ONBOARDING=true\nNAMESERVERS=\"1.1.1.1\"\nDISABLE_REGISTRATION=0\n</code></pre>"},{"location":"simplelogin/#self-test","title":"Self Test","text":"<p>Create <code>test</code> aliases for each domain and disable them so you won't get emails. Add the following to your host's cron, edit the <code>TARGETS</code> and <code>curl</code> command accordingly.</p> <pre><code>#!/bin/bash\n\nTARGETS=(\"test@domain1.com\" \"test@domain2.com\" \"test@domain3.com\")\n\nfor TARGET in \"${TARGETS[@]}\"; do\n    docker exec postfix sendmail $TARGET\n    sleep 10\n    result=$(docker exec sldb psql -U sl_user simplelogin -AXqtc \"SELECT COUNT(*) FROM email_log JOIN alias ON email_log.alias_id = alias.id WHERE alias.email = '$TARGET' AND email_log.created_at BETWEEN NOW() - INTERVAL '5 MINUTES' AND NOW();\")\n    if [[ \"$result\" -lt 1 ]]; then\n        curl -d \"Email test failed for $TARGET\" \"https://ntfy.domain1.com/topic\"\n    fi\ndone\n</code></pre>"},{"location":"smartd/","title":"Smartd","text":"<p><code>smartd</code> is a daemon that monitors the Self-Monitoring, Analysis and Reporting Technology (SMART) system built into many ATA-3 and later ATA, IDE and SCSI-3 hard drives. The purpose of SMART is to monitor the reliability of the hard drive and predict drive failures, and to carry out different types of drive self-tests.</p>"},{"location":"smartd/#installation","title":"Installation","text":"<pre><code>sudo apt install smartmontools\n</code></pre>"},{"location":"smartd/#configuration","title":"Configuration","text":"<p>Add the following to <code>/etc/smartmontools/smartd.conf</code>:</p> <pre><code>DEVICESCAN -a -S on -s (S/../.././03|L/../01/./02) -W 10,50,60 -m &lt;nomailer&gt; -M exec /home/user/ntfy.sh -M test\n</code></pre> <ul> <li><code>-a</code> - Equivalent to turning on all of the following Directives: '-H' to check the SMART health status, '-f' to report failures of Usage (rather than Prefail) Attributes, '-t' to track changes in both Prefailure and Usage Attributes, '-l error' to report increases in the number of ATA errors, '-l selftest' to report increases in the number of Self-Test Log errors, '-l selfteststs' to report changes of Self-Test execution status, '-C 197' to report nonzero values of the current pending sector count, and '-U 198' to report nonzero values of the offline pending sector count.</li> <li><code>-S on</code> - Enables or disables Attribute Autosave when smartd starts up and has no further effect.</li> <li><code>-s</code> - Run Self-Tests or Offline Immediate Tests, at scheduled times.</li> <li><code>S/../.././03</code> - Runs a short test daily at 3AM.</li> <li><code>L/../01/./02</code> - Runs a long test on the first of every month at 2AM.</li> <li><code>-W 10,50,60</code> - Tracks disk temperatures and alerts if they rise too quickly or hit a high limit. The following will log changes of 10 degrees or more, log when temp reaches 50 degrees, and log/email a warning when temp reaches 60.</li> <li><code>-m &lt;nomailer&gt; -M exec /home/user/ntfy.sh</code> - Run a shell script instead of the default mail command for alerts.</li> <li><code>-M test</code> - Test the notification script, remove after testing.</li> </ul> <p>Add the following to <code>/home/user/ntfy.sh</code>, replace the domain and topic:</p> <pre><code>#!/bin/bash\n\n/usr/bin/curl -Ls -H \"Title: $SMARTD_SUBJECT\" -d \"$SMARTD_FAILTYPE Device: $SMARTD_DEVICE Time: $SMARTD_TFIRST Message: $SMARTD_FULLMESSAGE\" https://ntfy.domain.com/Topic\n</code></pre> <p>Restart to test the alert:</p> <pre><code>chmod +x /home/user/ntfy.sh\nsudo systemctl restart smartd\n</code></pre> <p>Remove <code>-M test</code> from <code>smartd.conf</code> if everything works, and restart <code>smartd</code> again.</p>"},{"location":"socks/","title":"Route Applications Through a SOCKS Proxy","text":"<p>This setup allows you to route specific applications through randomized SOCKS proxies by your VPN provider without the entire devices having to connect to the VPN.</p>"},{"location":"socks/#tldr","title":"TLDR","text":"<p>Use NGINX through a Wireguard container to load balance between the VPN provider's SOCKS5 proxies and configure applications to use the NGINX proxy.</p>"},{"location":"socks/#initial-vpn-wireguard-client-configuration","title":"Initial VPN Wireguard Client Configuration","text":"<p>Configure your VPN Wireguard Client according to the Wireguard documentation.</p> <pre><code>  vpn:\n    image: ghcr.io/linuxserver/wireguard\n    container_name: vpn\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n    volumes:\n      - /path/to/appdata/config:/config\n      - /lib/modules:/lib/modules\n    restart: unless-stopped\n</code></pre> <p>Once done start the container and validate that <code>docker logs vpn</code> contains no errors (Ignore the missing wg0.conf message).</p>"},{"location":"socks/#connecting-the-wireguard-client-to-the-vpn","title":"Connecting the Wireguard Client to the VPN","text":"<p>Copy the Wireguard configuration that you get from your VPN provider into a file called <code>wg0.conf</code> and place it in your VPN Wireguard Client's <code>config</code> folder, and make the following changes:</p> <ul> <li>Remove IPv6 addresses (and ::/0) if you haven't enabled IPv6 in your docker network</li> <li>Add the <code>PostUp</code> and <code>PreDown</code> lines listed below <pre><code>[Interface]\nPrivateKey = &lt;private-key&gt;\nAddress = &lt;some-address&gt;/32\nDNS = &lt;some-address&gt;\nPostUp = DROUTE=$(ip route | grep default | awk '{print $3}'); HOMENET=192.168.0.0/16; HOMENET2=10.0.0.0/12; HOMENET3=172.16.0.0/12; ip route add $HOMENET3 via $DROUTE;ip route add $HOMENET2 via $DROUTE; ip route add $HOMENET via $DROUTE;iptables -I OUTPUT -d $HOMENET -j ACCEPT;iptables -A OUTPUT -d $HOMENET2 -j ACCEPT; iptables -A OUTPUT -d $HOMENET3 -j ACCEPT;  iptables -A OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT\nPreDown = DROUTE=$(ip route | grep default | awk '{print $3}'); HOMENET=192.168.0.0/16; HOMENET2=10.0.0.0/12; HOMENET3=172.16.0.0/12; ip route del $HOMENET3 via $DROUTE;ip route del $HOMENET2 via $DROUTE; ip route del $HOMENET via $DROUTE; iptables -D OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT; iptables -D OUTPUT -d $HOMENET -j ACCEPT; iptables -D OUTPUT -d $HOMENET2 -j ACCEPT; iptables -D OUTPUT -d $HOMENET3 -j ACCEPT\n\n[Peer]\nPublicKey = &lt;public-key&gt;\nAllowedIPs = 0.0.0.0/0\nEndpoint = &lt;some-address&gt;:&lt;some-port&gt;\n</code></pre> The PostUp command adds a killswitch using iptables rules to prevent connections on other interfaces. Connections from LAN networks are still allowed to be able to connect to the services in the containers. The PreDown command cleans up these rules when the VPN goes down.</li> </ul> <p>Save the changes and restart the container with <code>docker restart vpn</code>, validate that <code>docker logs vpn</code> contains no errors.</p> <p>Perform the following validations to check that the VPN works:</p> <ul> <li>Check that you have connectivity by running <code>docker exec vpn ping 1.1.1.1</code></li> <li>Check that the VPN is working by running <code>docker exec vpn curl -s https://am.i.mullvad.net/ip</code>, you should get an IP that is different from your internet's IP.</li> </ul>"},{"location":"socks/#nginx-configuration","title":"NGINX Configuration","text":"<p>Create an NGINX container using the following compose:</p> <pre><code>---\n  proxy:\n    image: ghcr.io/linuxserver/nginx\n    container_name: proxy\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n    volumes:\n      - &lt;/path/to/proxy/config&gt;:/config\n    network_mode: \"service:vpn\"\n    restart: unless-stopped\n</code></pre> <p>Edit <code>/path/to/proxy/config/nginx/nginx.conf</code>, delete everything and paste the following:</p> <pre><code>## Version 2021/06/15 - Changelog: https://github.com/linuxserver/docker-baseimage-alpine-nginx/commits/master/root/defaults/nginx.conf\n\nuser abc;\nworker_processes 4;\npid /run/nginx.pid;\ninclude /etc/nginx/modules/*.conf;\n\nevents {\n    worker_connections 768;\n}\n\nstream {\n    upstream stream_backend {\n        random;\n        server ch5-wg.socks5.mullvad.net:1080;\n        server ch6-wg.socks5.mullvad.net:1080;\n        server ch7-wg.socks5.mullvad.net:1080;\n        server ch8-wg.socks5.mullvad.net:1080;\n        server ch9-wg.socks5.mullvad.net:1080;\n    }\n\n    server {\n        listen 1080;\n        proxy_pass stream_backend;\n    }\n}\n\ndaemon off;\n</code></pre> <p>Replace the list of proxy servers such as <code>server ch5-wg.socks5.mullvad.net:1080</code> with proxy servers of your VPN provider.</p> <p>Add the port under the VPN Wireguard Client container:</p> <pre><code>    ports:\n      - 1080:1080 # SOCKS proxy\n</code></pre> <p>Recreate the VPN Wireguard Client container to apply the changes, then recreate the NGINX proxy container which depends on the VPN.</p> <p>Check that the proxy is working by running the following multiple times, you should get different IPs that are different from your internet's IP.</p> <pre><code>curl --socks5 localhost:1080 https://ifconfig.me\n</code></pre> <p>Now configure the applications to use the SOCKS proxy on your server's IP and port 1080, and exclude your local domain and IP range.</p> <p>For example in Firefox:</p> <p></p>"},{"location":"socks/#notes","title":"Notes","text":"<ul> <li>If there are other containers routed through the same VPN container, the SOCKS proxy will act as another hop meaning if you connect to a VPN in one country and select a SOCKS proxy in another country, it will hop twice which is more secure.</li> </ul> <ul> <li>The performance should be almost identical to not having a SOCKS proxy, if you feel any slowness then select another proxy provided by your VPN provider.</li> </ul>"},{"location":"split-dns/","title":"Split DNS","text":""},{"location":"split-dns/#split-dns","title":"Split DNS","text":"<p>Spilt DNS allows you to give different answers to DNS requests for internal and external users, so local requests for your server don't have to go via your router, it has several benefits:</p> <ul> <li>Faster due to not having to go through the router.</li> <li>The reverse proxy can easily differentiate between internal and external requests with allow/deny since there's no NAT.</li> <li>Things still work when the internet is down.</li> <li>Things still work when upstream DNS (Your ISP/Google/OpenDNS/etc) isn't available.</li> </ul>"},{"location":"split-dns/#requirements","title":"Requirements","text":"<ul> <li>An internal reverse proxy that listens on port 80/443.</li> <li>An internal DNS resolver that supports rewrites or hosting full DNS zones.</li> </ul>"},{"location":"split-dns/#popular-dns-configurations","title":"Popular DNS Configurations","text":"<p>These examples assume <code>domain.com</code> is your domain and <code>10.10.10.10</code> is your reverse proxy.</p>"},{"location":"split-dns/#opnsense","title":"OPNSense","text":"<p>Navigate to Services &gt; Unbound DNS &gt; Overrides &gt; Host Overrides &gt; Add:</p> <ul> <li>Host: <code>*</code></li> <li>Domain: <code>domain.com</code></li> <li>Type: <code>A or AAAA</code></li> <li>IP: <code>10.10.10.10</code></li> </ul>"},{"location":"split-dns/#pfsense","title":"PFSense","text":"<p>Navigate to Services &gt; DNS Resolver &gt; General Setting &gt; Host Overrides &gt; Add:</p> <ul> <li>Host: <code>*</code></li> <li>Domain: <code>domain.com</code></li> <li>IP Address: <code>10.10.10.10</code></li> </ul>"},{"location":"split-dns/#pihole-dnsmasq","title":"Pihole &amp; dnsmasq","text":"<p>Create a file called <code>/etc/dnsmasq.d/domain.conf</code> with this contents:</p> <pre><code>address=/domain.com/10.10.10.10\n</code></pre>"},{"location":"split-dns/#adguardhome","title":"AdguardHome","text":"<p>Navigate to Filters &gt; DNS rewrites &gt; Add DNS rewrite:</p> <ul> <li>Domain name: <code>*.domain.com</code></li> <li>IP Address: <code>10.10.10.10</code></li> </ul>"},{"location":"split-dns/#wireguard-issues","title":"Wireguard Issues","text":"<p>When exposing a wireguard server, the wireguard subdomain should not be split or it will break the connection while roaming between wi-fi and mobile data.</p> <p>For example, you can exclude <code>wg.domain.com</code> on AdguardHome by creating another DNS rewrite of <code>wg.domain.com</code> to <code>wg.domain.com</code>, that will exclude it from the split.</p>"},{"location":"split-dns/#nat-reflection-nat-loopback-hairpin-nat","title":"NAT Reflection / NAT Loopback / Hairpin NAT","text":"<p>NAT reflection is an alternative option to split DNS, which can provide some but not all of the same same benefits, it allows LAN devices to use the external IP and get port-forwarded without being NAT'd. </p> <p>It's usually a setting on specific routers that can be enabled via a checkbox.</p> <p>Note that using Cloudflare proxy (the orange cloud) or Cloudflare tunnels will bypass it and still send traffic externally.</p>"},{"location":"split-dns/#neither","title":"Neither","text":"<p>Without split DNS or NAT reflection traffic goes out of your router to reach your external IP and then gets NAT'd back in, often getting blocked by the router since external traffic with a LAN IP source is seen as malicious.</p>"},{"location":"split/","title":"Always-on Split Tunnel","text":"<p>This setup allows your phone to always be connected to both your VPN provider and to your home.</p>"},{"location":"split/#tldr","title":"TLDR","text":"<p>Set the home Wireguard server to the same subnet as the IP you got from your VPN provider and split the allowed IPs with the Wireguard AllowedIPs Calculator.</p>"},{"location":"split/#requirements","title":"Requirements","text":"<ul> <li>A VPN provider that supports Wireguard</li> <li>A home Wireguard server</li> <li>An Android phone</li> <li>The official Wireguard application</li> </ul>"},{"location":"split/#vpn-provider-configuration","title":"VPN Provider Configuration","text":"<p>The VPN provider will provide you with a Wireguard config or a QR code, for example:</p> <p><code>PublicKey = aV/aFODKJH5894674CtdyhPDDFiE/qwe/1xnRM=</code> <pre><code>[Interface]\nPrivateKey = EFvrTq36k22b+DXN6788bOIeONjklb2KLVPVj/CUd3o=\nAddress = 10.22.46.77/32,fc00:bbbb:bbbb:bb01::2:d2ab/128\nDNS = 193.138.44.22\n\n[Peer]\nPublicKey = aV/aDhwG0fmp0XuvSnbmWjCtdyhPDDFiE/qwe/1xnRM=\nAllowedIPs = 0.0.0.0/0,::0/0\nEndpoint = 193.8.66.48:51820\n</code></pre></p> <p>Verify that it works by connecting the phone to it.</p>"},{"location":"split/#home-wireguard-configuration","title":"Home Wireguard Configuration","text":"<p>Set the home Wireguard server to the same subnet as the IP provided by your VPN provider.</p> <p>In this example the home Wireguard server should have this configuration:</p> <ul> <li>IP Address - <code>10.22.46.1</code></li> <li>Subnet - <code>10.22.46.0/24</code></li> </ul> <p>Create a client configuration for your phone with the same IP address, private key, and public key.</p> <p>In this example the home Wireguard server should have a client with this configuration:</p> <ul> <li>IP Address - <code>10.22.46.77/32</code></li> <li>PublicKey - <code>aV/aFODKJH5894674CtdyhPDDFiE/qwe/1xnRM=</code></li> <li>PrivateKey - <code>EFvrTq36k22b+DXN6788bOIeONjklb2KLVPVj/CUd3o=</code></li> </ul> <p>Verify that it works by connecting the phone to it.</p>"},{"location":"split/#merging-the-tunnels","title":"Merging the Tunnels","text":"<p>Edit the connection to the VPN provider &gt; Add Peer:</p> <ul> <li>Public Key - Copy the public key of the home Wireguard server.</li> <li>Endpoint - <code>your.domain.com:51820</code> (replace with your domain and Wireguard server port)</li> <li>Allowed IPs - The home network subnet, for example: <code>192.168.1.0/24</code></li> </ul> <p>Navigate to the Wireguard AllowedIPs Calculator, set Allowed IPs to <code>0.0.0.0/0, ::/0</code> and Disallowed IPs to the home network subnet, for example: <code>192.168.1.0/24</code>, click Calculate and copy the result, for example: <pre><code>0.0.0.0/1, 128.0.0.0/2, 192.0.0.0/9, 192.128.0.0/11, 192.160.0.0/13, 192.168.0.0/24, 192.168.2.0/23, 192.168.4.0/22, 192.168.8.0/21, 192.168.16.0/20, 192.168.32.0/19, 192.168.64.0/18, 192.168.128.0/17, 192.169.0.0/16, 192.170.0.0/15, 192.172.0.0/14, 192.176.0.0/12, 192.192.0.0/10, 193.0.0.0/8, 194.0.0.0/7, 196.0.0.0/6, 200.0.0.0/5, 208.0.0.0/4, 224.0.0.0/3, ::/0\n</code></pre> Paste the result into the first peer (the VPN provider peer) under Allowed IPs.</p> <p>Lastly, change the DNS servers field to the IP of the home DNS if needed (make sure the DNS address is within the Allowed IPs of the home Wireguard server peer).</p>"},{"location":"split/#example-client-config","title":"Example Client Config","text":"<pre><code>[Interface]\nAddress = 10.167.26.220/32, fc00:bbbb:bbbb:bb05::2:d8db/128\nDNS = 10.1.1.1\nPrivateKey = redacted\n\n[Peer]\nAllowedIPs = 10.1.1.0/24\nEndpoint = home.com:51820\nPublicKey = redacted\n\n[Peer]\nAllowedIPs = 0.0.0.0/5, 8.0.0.0/7, 10.0.0.0/16, 10.1.0.0/24, 10.1.2.0/23, 10.1.4.0/22, 10.1.8.0/21, 10.1.16.0/20, 10.1.32.0/19, 10.1.64.0/18, 10.1.128.0/17, 10.2.0.0/15, 10.4.0.0/14, 10.8.0.0/13, 10.16.0.0/12, 10.32.0.0/11, 10.64.0.0/10, 10.128.0.0/9, 11.0.0.0/8, 12.0.0.0/6, 16.0.0.0/4, 32.0.0.0/3, 64.0.0.0/2, 128.0.0.0/1, ::/0\nEndpoint = 193.32.127.70:51820\nPublicKey = redacted\n</code></pre>"},{"location":"split/#additional-configuration","title":"Additional Configuration","text":""},{"location":"split/#dns-access-list","title":"DNS Access List","text":"<p>The Wireguard server subnet may need to be added to the DNS access list, for example in OPNSense under Services &gt; Unbound DNS &gt; Access Lists &gt; Add &gt; allow <code>10.22.46.0/24</code>.</p>"},{"location":"split/#reverse-proxy","title":"Reverse Proxy","text":"<p>The Wireguard server subnet may need to be added to the reverse proxy's LAN IP ranges, for example in SWAG it should be added to Allow/Deny and to Geoblock.</p>"},{"location":"split/#always-on","title":"Always-on","text":"<p>The tunnel can stay connected at all times, even when you're at home, it can be enabled under Settings &gt; Network &amp; Internet &gt; Advanced &gt; VPN &gt; Wireguard Settings &gt; Enable Always-on VPN.</p>"},{"location":"split/#troubleshoot","title":"Troubleshoot","text":""},{"location":"split/#push-notifications-are-not-working","title":"Push notifications are not working","text":"<p>In the Wireguard app edit the tunnel configuration and add an application exclusion for Google Play services.</p>"},{"location":"split/#the-phone-battery-is-being-drained-quickly","title":"The phone battery is being drained quickly","text":"<p>Make sure that you didn't set a Persistent Keep-alive on either the server Wireguard configuration or the client tunnel configuration.</p>"},{"location":"tmux/","title":"Tmux - Getting Started","text":"<p>tmux is a terminal multiplexer for Unix-like operating systems. It allows multiple terminal sessions to be accessed simultaneously in a single window. It is useful for running more than one command-line program at the same time. It can also be used to detach processes from their controlling terminals, allowing SSH sessions to remain active without being visible.</p>"},{"location":"tmux/#installation","title":"Installation","text":""},{"location":"tmux/#osx","title":"OSx","text":"<p><code>brew install tmux reattach-to-user-namespace</code></p>"},{"location":"tmux/#enable-copypaste","title":"Enable Copy/Paste","text":"<p>iTerm2 &gt; Preferences &gt; General &gt; Selection &gt; Applications in terminal may access clipboard</p>"},{"location":"tmux/#debian-ubuntu","title":"Debian / Ubuntu","text":"<p><code>sudo apt install tmux xsel</code></p>"},{"location":"tmux/#install-tpm","title":"Install TPM","text":"<p><code>git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm</code></p>"},{"location":"tmux/#initial-configuration","title":"Initial Configuration","text":"<p>Copy the following to <code>~/.tmux.conf</code></p> <pre><code>set -g mouse on\n\nunbind-key C-b\nunbind-key C-x\nset-option -g prefix C-a\nbind C-x setw synchronize-panes\nbind-key h split-window -h\nbind-key v split-window -v\n\nset -g status-justify \"centre\"\nset -g set-titles on\nset -g base-index 1\nset -g status-bg black\nset -g status-fg white\nsetw -g automatic-rename on\nsetw -g window-status-current-format \"#{?pane_synchronized,#[bg=red],#[fg=white, bg=blue]} #I #W #[fg=blue, bg=black]\"\n\nset -g @plugin \"tmux-plugins/tpm\"\nset -g @plugin \"tmux-plugins/tmux-sensible\"\nset -g @plugin \"tmux-plugins/tmux-resurrect\"\nset -g @plugin \"tmux-plugins/tmux-continuum\"\nset -g @plugin \"tmux-plugins/tmux-yank\"\nset -g @yank_selection_mouse \"clipboard\"\nset -g @resurrect-processes \":all:\"\nset -g @resurrect-capture-pane-contents \"on\"\nrun \"~/.tmux/plugins/tpm/tpm\"\n</code></pre>"},{"location":"tmux/#commands","title":"Commands","text":"<pre><code>tmux                          start a new session\ntmux ls                       list all sessions\ntmux a                        attach to an existing session\ntmux a -t &lt;name&gt;              attach to a named session\ntmux new -s &lt;name&gt;            start a new named session\ntmux kill-session -t &lt;name&gt;   kill a named session\ntmux kill-server              kill all sessions\n</code></pre>"},{"location":"tmux/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p>The modifier prefix has been changed from the default <code>ctrl-b</code> to <code>ctrl-a</code> which is more convenient.</p> <p>Use the modifier prefix <code>ctrl-a</code> with these keyboard shortcuts.</p> <pre><code>?             list shortcuts                         \nR             reload the configuration               \nI             install new pluginx                    \nd             detach the session                     \nh             split horizontally                     \nv             split vertically                       \nc             create a new window                    \np             switch to the previous window          \nn             switch to the next window              \nw             list the windows                       \n1-9           switch to the window number            \n,             rename the window                      \n$             rename the session                     \nctrl-s        save the environment to the disk       \nctrl-r        restore the environment from the disk  \narrows        switch between panes                   \nctrl+arrows   resize pane                            \nspace         switch pane layout                     \nz             maximize/minimize pane                 \nctrl-x        synchronize panes                     \n</code></pre>"},{"location":"tmux/#automation-example","title":"Automation Example","text":"<pre><code>tmux new-window -n status\ntmux split-window -h\ntmux select-pane -t 0\ntmux send-keys \"htop\" C-m\ntmux split-window -v\ntmux select-pane -t 1\ntmux send-keys \"docker stats\" C-m\ntmux select-pane -t 2\n</code></pre>"},{"location":"tmux/#convenient-aliases","title":"Convenient Aliases","text":"<p>Copy the following to <code>~/.zshrc</code></p> <pre><code>alias t='tmux'\nalias ts='tmux new -s'\nalias tks='tmux kill-session -t'\nalias tka='tmux kill-server'\n</code></pre>"},{"location":"tmux/#links","title":"Links","text":"<p>Find more ways to use Tmux - Awesome Tmux</p>"},{"location":"vpn/","title":"VPN Route","text":"<p>This setup allows you to route containers through a VPN and protect yourself from your ISP.</p> <p>This guide is the basic step-by-step version of great blog posts by Spad and Tokugero which also contain more advanced information.</p> <p>qBittorrent and Mullvad are used in this guide as an example, but you can route any container the same way, and use any VPN service that supports Wireguard.</p>"},{"location":"vpn/#requirements","title":"Requirements","text":"<ul> <li>A working instance of qBittorrent</li> </ul>"},{"location":"vpn/#initial-vpn-wireguard-client-configuration","title":"Initial VPN Wireguard Client Configuration","text":"<p>Configure your VPN Wireguard Client according to the Wireguard documentation.</p> <pre><code>  vpn:\n    image: ghcr.io/linuxserver/wireguard\n    container_name: vpn\n    cap_add:\n      - NET_ADMIN\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n    volumes:\n      - /path/to/appdata/config:/config\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1\n    restart: unless-stopped\n</code></pre> <p>Once done start the container and validate that <code>docker logs vpn</code> contains no errors (Ignore the missing wg0.conf message).</p>"},{"location":"vpn/#connecting-the-wireguard-client-to-the-vpn","title":"Connecting the Wireguard Client to the VPN","text":"<p>Copy the Wireguard configuration that you get from your VPN provider into a file called <code>wg0.conf</code> and place it in your VPN Wireguard Client's <code>config/wg_confs</code> folder, and make the following changes:</p> <ul> <li>Remove IPv6 addresses (and ::/0) if you haven't enabled IPv6 in your docker network</li> <li>Add the <code>PostUp</code> and <code>PreDown</code> lines listed below</li> </ul> <pre><code>[Interface]\nPrivateKey = &lt;private-key&gt;\nAddress = &lt;some-address&gt;/32\nDNS = &lt;some-address&gt;\nPostUp = DROUTE=$(ip route | grep default | awk '{print $3}'); HOMENET=192.168.0.0/16; HOMENET2=10.0.0.0/12; HOMENET3=172.16.0.0/12; ip route add $HOMENET3 via $DROUTE;ip route add $HOMENET2 via $DROUTE; ip route add $HOMENET via $DROUTE;iptables -I OUTPUT -d $HOMENET -j ACCEPT;iptables -A OUTPUT -d $HOMENET2 -j ACCEPT; iptables -A OUTPUT -d $HOMENET3 -j ACCEPT;  iptables -A OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT\nPreDown = DROUTE=$(ip route | grep default | awk '{print $3}'); HOMENET=192.168.0.0/16; HOMENET2=10.0.0.0/12; HOMENET3=172.16.0.0/12; ip route del $HOMENET3 via $DROUTE;ip route del $HOMENET2 via $DROUTE; ip route del $HOMENET via $DROUTE; iptables -D OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT; iptables -D OUTPUT -d $HOMENET -j ACCEPT; iptables -D OUTPUT -d $HOMENET2 -j ACCEPT; iptables -D OUTPUT -d $HOMENET3 -j ACCEPT\n\n[Peer]\nPublicKey = &lt;public-key&gt;\nAllowedIPs = 0.0.0.0/0\nEndpoint = &lt;some-address&gt;:&lt;some-port&gt;\n</code></pre> <p>The PostUp command adds a killswitch using iptables rules to prevent connections on other interfaces, and maintains connections to the web-ui of the services in the containers. The PreDown command cleans up these rules when the VPN goes down.</p> <p>Save the changes and restart the container with <code>docker restart vpn</code>, validate that <code>docker logs vpn</code> contains no errors.</p> <p>Perform the following validations to check that the VPN works:</p> <ul> <li>Check that you have connectivity by running <code>docker exec vpn ping 1.1.1.1</code></li> <li>Check that the VPN is working by running <code>docker exec vpn curl -s https://am.i.mullvad.net/ip</code>, you should get an IP that is different from your internet's IP.</li> </ul>"},{"location":"vpn/#routing-qbittorrent-through-the-vpn","title":"Routing qBittorrent Through the VPN","text":"<p>Replace the following lines on the qBittorrent container:</p> <pre><code>    ports:\n      - 6881:6881\n      - 6881:6881/udp\n      - 8080:8080\n</code></pre> <p>With:</p> <pre><code>    network_mode: \"service:vpn\"\n    depends_on:\n      - vpn\n</code></pre> <p>Add the port under the VPN Wireguard Client container:</p> <pre><code>    ports:\n      - 8080:8080 # qBittorrent\n</code></pre> <p>Recreate the VPN Wireguard Client container to apply the changes, then recreate the qBittorrent container which depends on the VPN.</p> <p>Perform the following validations to check that the VPN works:</p> <ul> <li>Check that the VPN is working by running <code>docker exec qbittorrent curl -s https://am.i.mullvad.net/ip</code> and make sure you don't get your internet's IP.</li> <li>Check that qBittorrent's Web Administration interface is working by browsing http://<code>&lt;server-ip&gt;</code>:8080.</li> </ul>"},{"location":"vpn/#configuring-other-containers","title":"Configuring Other Containers","text":"<p>Now that qBittorrent is routed through the VPN, other containers like swag, radarr, sonarr, prowlarr, etc, need to be configured to use <code>vpn</code> instead of <code>qbittorrent</code> as the container name for reaching qBittorrent.</p>"},{"location":"vpn/#swag","title":"SWAG","text":"<p>Edit your <code>qbittorrent.subdomain.conf</code> or <code>qbittorrent.subfolder.conf</code> in SWAG's config folder under <code>config/nginx/proxy-confs/</code>.</p> <p>Replace all occurrences of <code>set $upstream_app qbittorrent;</code> with <code>set $upstream_app vpn;</code>.</p> <p>Restart the SWAG to apply the changes with <code>docker restart swag</code>.</p>"},{"location":"vpn/#sonarr-radarr","title":"Sonarr / Radarr","text":"<p>Under <code>Settings</code> &gt; <code>Download Clients</code> &gt; Click qBittorrent's Download Client &gt; Set <code>Host</code> to <code>vpn</code> &gt; click <code>Test</code> &amp; <code>Save</code>.</p>"},{"location":"vpn/#notes","title":"Notes","text":""},{"location":"vpn/#port-forwarding","title":"Port forwarding","text":"<p>VPN providers like Torguard support port forwarding, if your application needs it.</p> <p>Copy the port number you got to <code>qBittorrent</code> &gt; <code>Settings</code> &gt; <code>Connection</code> &gt; <code>Port used for incoming connections</code>.</p>"},{"location":"vpn/#restarting-order","title":"Restarting order","text":"<p>If you're experiencing problems and you want to restart everything, the correct order is:</p> <ul> <li>VPN - <code>docker restart vpn</code></li> <li>Containers using the VPN - <code>docker restart &lt;container&gt;</code></li> </ul>"},{"location":"vpn/#cant-connect-to-the-web-ui-of-routed-containers","title":"Can't connect to the Web-UI of routed containers","text":"<p>Make sure that you have added <code>PostUp</code> and <code>PreDown</code> to <code>wg0.conf</code> as detailed in Connecting the Wireguard Client to the VPN.</p>"},{"location":"vpn/#dns-leaks","title":"DNS leaks","text":"<p>If you want to make sure wireguard isn't using your local DNS, add the following to the vpn's compose (Replace <code>8.8.8.8</code> with your DNS of choice):   <pre><code>dns:\n  - 8.8.8.8\n</code></pre></p>"},{"location":"vps/","title":"VPS Proxy","text":"<p>This setup allows you to hide your home IP, protect your privacy and protect your home server against DDOS attacks while keeping all of your data at home.</p> <p>Once it's up and running, exposing a resource through the VPS is as simple as adding one line to your home SWAG.</p> <p>The TLDR version is:</p> <ul> <li>Create a VPN tunnel between your home and a VPS</li> <li>Configure SWAG to proxy traffic through the tunnel</li> <li>Configure Fail2ban to block attackers</li> </ul> <p>There are many ways to create this setup with many variations for many different purposes, in my opinion these containers are easy to work with and to maintain, every container in this setup can be used for other purposes as well as being used for the proxy without any compromises:</p> <ul> <li>Home SWAG can be used as a reverse proxy for all of your other Home server containers.</li> <li>Home Wireguard Client can be used to route any container through the VPS.</li> <li>VPS SWAG can be used as a reverse proxy for all of your other VPS containers.</li> <li>VPS Wireguard Server can be used as your private cloud VPN server.</li> </ul>"},{"location":"vps/#requirements","title":"Requirements","text":"<ul> <li>A working instance of SWAG at home</li> <li>A working instance of SWAG on the VPS</li> </ul>"},{"location":"vps/#initial-vps-wireguard-server-configuration","title":"Initial VPS Wireguard Server Configuration","text":"<p>Configure your VPS Wireguard Server according to the Wireguard documentation.</p> <pre><code>  wireguard:\n    image: ghcr.io/linuxserver/wireguard\n    container_name: wireguard\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n      - SERVERURL=external.com\n      - SERVERPORT=51820\n      - PEERS=1\n      - PEERDNS=auto\n      - INTERNAL_SUBNET=10.13.13.0\n      - ALLOWEDIPS=10.13.13.0/24\n    volumes:\n      - /path/to/appdata/config:/config\n      - /lib/modules:/lib/modules\n    ports:\n      - 51820:51820/udp\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1\n    restart: unless-stopped\n</code></pre> <p>Note that <code>ALLOWEDIPS</code> is set to only allow access to the Wireguard subnet.</p> <p>Once done start the container and validate that <code>docker logs wireguard</code> contains no errors.</p>"},{"location":"vps/#initial-home-wireguard-client-configuration","title":"Initial Home Wireguard Client Configuration","text":"<p>Configure your Home Wireguard Client according to the Wireguard documentation.</p> <pre><code>  wireguard:\n    image: ghcr.io/linuxserver/wireguard\n    container_name: wireguard\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n    volumes:\n      - /path/to/appdata/config:/config\n      - /lib/modules:/lib/modules\n    restart: unless-stopped\n</code></pre> <p>Once done start the container and validate that <code>docker logs wireguard</code> contains no errors (Ignore the missing wg0.conf message).</p>"},{"location":"vps/#connecting-the-wireguard-client-to-the-wireguard-server","title":"Connecting the Wireguard Client to the Wireguard Server","text":"<p>Copy <code>peer1.conf</code> from your VPS Wireguard Server's <code>config/peer1/</code> folder to your Home Wireguard Client's <code>config</code> folder and rename it to <code>wg0.conf</code>.</p> <p>Edit your Home Wireguard Client's <code>wg0.conf</code>, remove the <code>DNS</code> line and add the <code>PersistentKeepalive = 25</code> line under <code>Peer</code>, it should look like this: <pre><code>[Interface]\nAddress = 10.13.13.2\nPrivateKey = &lt;private-key&gt;\nListenPort = 51820\n\n[Peer]\nPublicKey = &lt;public-key&gt;\nEndpoint = &lt;domain&gt;:51820\nAllowedIPs = 10.13.13.0/24\nPersistentKeepalive = 25\n</code></pre> Save the changes and restart the container on your Home server with <code>docker restart wireguard</code>, validate that <code>docker logs wireguard</code> contains no errors.</p> <p>Validate that the tunnel is working by pinging both sides:</p> <ul> <li>On the Home server run - <code>docker exec wireguard ping 10.13.13.1</code></li> <li>On the VPS run - <code>docker exec wireguard ping 10.13.13.2</code></li> </ul>"},{"location":"vps/#configuring-the-vps-swag-to-use-the-tunnel","title":"Configuring the VPS SWAG to Use the Tunnel","text":"<p>Replace the following lines on the VPS SWAG container:</p> <pre><code>    ports:\n      - 443:443\n      - 80:80\n</code></pre> <p>With:</p> <pre><code>    network_mode: \"service:wireguard\"\n    depends_on:\n      - wireguard\n</code></pre> <p>Add the ports under the VPS Wireguard Server container:</p> <pre><code>    ports:\n      - 80:80\n      - 443:443\n      - 51820:51820/udp\n</code></pre> <p>Add the following to the bottom of the VPS SWAG configuration under <code>config/nginx/site-confs/default</code>:</p> <pre><code>server {\n    listen 443 ssl;\n    server_name *.external.com;\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location / {\n        include /config/nginx/proxy.conf;\n        resolver 127.0.0.11 valid=30s;\n        proxy_pass http://10.13.13.2:8080;\n    }\n}\n</code></pre> <p>Recreate the VPS Wireguard Server container to apply the changes, then recreate the VPS SWAG container which depends on the tunnel.</p>"},{"location":"vps/#configuring-the-home-swag-to-use-the-tunnel","title":"Configuring the Home SWAG to Use the Tunnel","text":"<p>Replace the following lines on the Home SWAG container:</p> <pre><code>    ports:\n      - 443:443\n      - 80:80\n</code></pre> <p>With:</p> <pre><code>    network_mode: \"service:wireguard\"\n    depends_on:\n      - wireguard\n</code></pre> <p>Add the ports under the Home Wireguard Client container:</p> <pre><code>    ports:\n      - 80:80\n      - 443:443\n      - 51820:51820/udp\n</code></pre> <p>Configure the Home SWAG to see the real IP of connections coming from the tunnel by adding the following inside the <code>http</code> section in <code>config/nginx/nginx.conf</code>:</p> <pre><code>    set_real_ip_from 10.13.13.1/32;\n    real_ip_header X-Forwarded-For;\n</code></pre> <p>In order to catch all the unused subdomains and redirect to an error page, add <code>listen 8080 default_server;</code> to <code>config/nginx/site-confs/default</code> under the main server block:</p> <pre><code># main server block\nserver {\n    listen 8080 default_server;\n    listen 443 ssl http2 default_server;\n</code></pre> <p>Expose a container through the tunnel by adding <code>listen 8080;</code> to it's proxy configuration, for example:</p> <pre><code>server {\n    listen 8080;\n    listen 443 ssl;\n    server_name heimdall.*;\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location / {\n        include /config/nginx/proxy.conf;\n        resolver 127.0.0.11 valid=30s;\n        set $upstream_app heimdall;\n        set $upstream_port 443;\n        set $upstream_proto https;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n\n    }\n}\n</code></pre> <p>Recreate the Home Wireguard Client container to apply the changes, then recreate the Home SWAG container which depends on the tunnel.</p> <p>Validate that the containers you exposed now work through the tunnel by browsing <code>https://&lt;container&gt;.external.com/</code>.</p>"},{"location":"vps/#traffic-overview","title":"Traffic Overview","text":""},{"location":"vps/#fail2ban","title":"Fail2ban","text":"<p>Now that everything is working, Fail2ban should ban the right IP of attackers, but they're coming in through the tunnel and iptables isn't blocking them, therefore we will block them through NGINX.</p> <p>Create a file called <code>nginx.conf</code> in your Home SWAG under <code>config/fail2ban/action.d/</code> with the following:</p> <pre><code>[INCLUDES]\n\n[Definition]\n\nactionstart = touch /config/nginx/blocklist.conf\nactionstop = \nactioncheck = \nactionban = grep -qxF \"deny &lt;ip&gt;;\" /config/nginx/blocklist.conf || echo \"deny &lt;ip&gt;;\" &gt;&gt; /config/nginx/blocklist.conf &amp;&amp; /bin/s6-svc -r /var/run/s6/services/nginx\nactionunban = sed -i '/deny &lt;ip&gt;;/d' /config/nginx/blocklist.conf &amp;&amp; /bin/s6-svc -r /var/run/s6/services/nginx\n\n[Init]\n\nname = default\n</code></pre> <p>Edit <code>config/fail2ban/jail.local</code> and add <code>nginx</code> to the <code>action</code> of all the jails, for example:</p> <pre><code>[authelia]\nenabled  = true\nfilter   = authelia\nport     = http,https\nlogpath  = /authelia/authelia.log\naction  = iptables-allports[name=authelia]\n          nginx\n</code></pre> <p>Add the following line into the <code>http</code> section in <code>config/nginx/nginx.conf</code>:</p> <pre><code>    include /config/nginx/blocklist.conf;\n</code></pre> <p>Restart the Home SWAG to apply the changes with <code>docker restart swag</code>.</p>"},{"location":"vps/#notes","title":"Notes","text":""},{"location":"vps/#exposing-more-containers","title":"Exposing more containers","text":"<p>Expose more containers by simply adding <code>listen 8080;</code> to their proxy configuration on the Home server, for example:</p> <pre><code>server {\n    listen 8080;\n    listen 443 ssl;\n</code></pre> <p>Restart Home SWAG by running <code>docker restart swag</code> to apply the changes.</p>"},{"location":"vps/#restarting-order","title":"Restarting order","text":"<p>If you're experiencing problems and you want to restart everything, the correct order is:</p> <ul> <li>VPS - <code>docker restart wireguard</code></li> <li>VPS - <code>docker restart swag</code></li> <li>Home - <code>docker restart wireguard</code></li> <li>Home - <code>docker restart swag</code></li> </ul>"},{"location":"vps/#authelia-authentik","title":"Authelia / Authentik","text":"<p>If you expose Authelia/Authentik through the tunnel, you need to make a small adjustment for the redirects to work.</p> <p>The idea is to force https, since traffic through the tunnel is coming over as http but the VPS exposes https.</p> <p>Edit Authelia/Authentik confs under <code>config/nginx/</code>, replace <code>$scheme</code> with <code>https</code>.</p> <p>Restart the Home SWAG to apply the changes with <code>docker restart swag</code>.</p>"},{"location":"vps/#exposing-a-resource-only-through-one-domain-but-not-the-other","title":"Exposing a resource only through one domain but not the other","text":"<p>You control what gets exposed where in 2 ways:</p> <ul> <li>Through the <code>listen &lt;port&gt;;</code> setting, 8080 is through the VPS and 443/80 is directly.</li> <li>Through the <code>server_name something.external.com</code> setting, if you explicitely specify the full address.</li> </ul> <p>If a resource isn't exposed, the default action under the main server block in your Home SWAG will apply.</p>"},{"location":"vps/#attackers-are-filling-my-logs-with-access-denied","title":"Attackers are filling my logs with Access Denied!","text":"<p>If you want attackers to be redirected instead of showing them an error page and avoid them spamming the logs with 403 errors, add the following inside the <code>http</code> section in <code>config/nginx/nginx.conf</code> on both SWAGs:</p> <pre><code>    error_page 400 403 404 444 500 502 503 504 http://www.google.com/;\n</code></pre> <p>Restart the Home SWAG to apply the changes with <code>docker restart swag</code>.</p>"},{"location":"yaml-anchors/","title":"YAML Anchors","text":"<p>Using YAML anchors is a great way to reduce configuration duplication and be able to add configuration to all containers in a single place.</p>"},{"location":"yaml-anchors/#basic","title":"Basic","text":"<p>You want all containers to have the same restart policy and the same memory limit of 2GB:</p> <pre><code>version: \"3.9\"\n\nx-base: &amp;base\n  mem_limit: 2000m\n  restart: always\n\nservices:\n  radarr:\n    &lt;&lt;: *base\n    image: lscr.io/linuxserver/radarr\n    container_name: radarr\n    volumes:\n      - ${APPSDIR}/radarr:/config\n      - ${DATADIR}/media:/media\n  sonarr:\n    &lt;&lt;: *base\n    image: lscr.io/linuxserver/sonarr\n    container_name: sonarr\n    volumes:\n      - ${APPSDIR}/sonarr:/config\n      - ${DATADIR}/media:/media\n</code></pre> <p>Every container with <code>&lt;&lt;: *base</code> will include everything listed under <code>x-base</code>, and changes to it will affect all containers.</p>"},{"location":"yaml-anchors/#advanced","title":"Advanced","text":"<p>You have a few common templates, and you want to be able to use all of them:</p> <ul> <li><code>base</code> - The base of containers, you can safely assume that changes to it will affect all containers.</li> <li><code>internalbase</code> - The base + associating with the internal docker network.</li> <li><code>vpnbase</code> - The base + associating with the VPN network.</li> <li><code>lsio</code> - Common environment variables in all LSIO containers.</li> <li><code>lsiobase</code> - The base + associating with the internal docker network + LSIO variables.</li> <li><code>vpnlsiobase</code> - The base + associating with the VPN network + LSIO variables.</li> </ul> <pre><code>version: \"3.9\"\n\nx-base: &amp;base\n  mem_limit: 2000m\n  restart: always \nx-internalbase: &amp;internalbase\n  &lt;&lt;: *base\n  networks:\n    - internal\nx-vpnbase: &amp;vpnbase\n  &lt;&lt;: *base\n  network_mode: \"service:vpn\"\nx-lsio: &amp;lsio\n  PUID: ${PUID}\n  PGID: ${PGID}\n  TZ: ${TZ}\nx-lsiobase: &amp;lsiobase\n  &lt;&lt;: *internalbase\n  environment:\n    &lt;&lt;: *lsio\nx-vpnlsiobase: &amp;vpnlsiobase\n  &lt;&lt;: *vpnbase\n  environment:\n    &lt;&lt;: *lsio\n\nservices:\n  radarr:\n    &lt;&lt;: *lsiobase\n    image: lscr.io/linuxserver/radarr\n    container_name: radarr\n    volumes:\n      - ${APPSDIR}/radarr:/config\n      - ${DATADIR}/media:/media\n  sonarr:\n    &lt;&lt;: *lsiobase\n    image: lscr.io/linuxserver/sonarr\n    container_name: sonarr\n    volumes:\n      - ${APPSDIR}/sonarr:/config\n      - ${DATADIR}/media:/media\n  lidarr:\n    &lt;&lt;: *vpnlsiobase\n    image: lscr.io/linuxserver/lidarr:nightly\n    container_name: lidarr\n    volumes:\n      - ${APPSDIR}/lidarr:/config\n      - ${DATADIR}/media:/media\n  prowlarr:\n    &lt;&lt;: *vpnlsiobase\n    image: lscr.io/linuxserver/prowlarr:nightly-alpine\n    container_name: prowlarr\n    volumes:\n      - ${APPSDIR}/prowlarr:/config\n  ombi:\n    &lt;&lt;: *vpnlsiobase\n    image: lscr.io/linuxserver/ombi:development\n    container_name: ombi\n    volumes:\n      - ${APPSDIR}/ombi4:/config\n  collabora:\n    &lt;&lt;: *internalbase\n    image: collabora/code\n    container_name: collabora\n    environment:\n      domain: ${CLBDOMAIN}\n      dictionaries: en_US\n</code></pre> <p>We easily associated 2 containers with <code>lsiobase</code>, 3 with <code>vpnlsiobase</code>, and 1 with <code>internalbase</code>.</p>"},{"location":"yaml-anchors/#overriding-anchors","title":"Overriding Anchors","text":"<p>There may be a need to add environment variables beyond the ones defined in the base anchor, unfortunately when declaring the same section again it will override the base, not append to it. Instead, you need to make a separate anchor for the environment variables and use it directly.</p> <p>For example:</p> <pre><code>x-base: &amp;base\n  mem_limit: 2000m\n  restart: always \nx-internalbase: &amp;internalbase\n  &lt;&lt;: *base\n  networks:\n    - internal\nx-lsio: &amp;lsio\n  PUID: ${PUID}\n  PGID: ${PGID}\n  TZ: ${TZ}\nx-lsiobase: &amp;lsiobase\n  &lt;&lt;: *internalbase\n  environment:\n    &lt;&lt;: *lsio\n\nservices:\n  mariadb:\n    &lt;&lt;: *internalbase\n    image: lscr.io/linuxserver/mariadb\n    container_name: mariadb\n    environment:\n      &lt;&lt;: *lsio\n      MYSQL_DIR: /config\n      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}\n    volumes:\n      - ${APPSDIR}/mariadb:/config\n</code></pre>"},{"location":"zfs/","title":"ZFS","text":"<p>The following creates a zfs pool with 2 mirrors of 2 disks each, with:</p> <ul> <li>LZ4 compression</li> <li>Linux ACLs</li> <li>Larger record size for media</li> <li>Snapshots with a retention policy:<ul> <li>4 every 15 minutes in the last hour</li> <li>24 every hour in the last day</li> <li>31 every day in the last month</li> <li>8 every week in the last 2 months</li> <li>12 every month in the last year (disabled for <code>/mnt/pool/media</code>)</li> </ul> </li> <li>Scrub reports and alerts sent to ntfy</li> </ul>"},{"location":"zfs/#installation","title":"Installation","text":"<pre><code>sudo apt install zfsutils-linux zfs-auto-snapshot\n</code></pre>"},{"location":"zfs/#creation","title":"Creation","text":"<p>Find the IDs of the disks you want to use for the zfs pool:</p> <pre><code>sudo lsblk -o NAME,SIZE,SERIAL,LABEL,FSTYPE\nNAME          SIZE SERIAL          LABEL FSTYPE\nsda          18.2T 8LG7V8BA\nsdb          14.6T 2CGREXTB\nsdc          18.2T 8LG87T5A\nsdd          14.6T 2CGPPSGB\n</code></pre> <p>Decide on a layout create the zfs pool using the disk IDs:</p> <pre><code>sudo mkdir -p /mnt/pool\nsudo zpool create -m /mnt/pool pool mirror /dev/disk/by-id/ata-WDC_WUH722020BLE6L4_8LG7V8BA /dev/disk/by-id/ata-WDC_WUH722020BLE6L4_8LG87T5A mirror /dev/disk/by-id/ata-WDC_WUH721816ALE6L4_2CGREXTB /dev/disk/by-id/ata-WDC_WUH721816ALE6L4_2CGPPSGB\n</code></pre>"},{"location":"zfs/#configuration","title":"Configuration","text":"<p>Set the pool configuration:</p> <pre><code>sudo zfs set compression=lz4 pool\nsudo zfs set acltype=posixacl pool\nsudo zfs set xattr=sa pool\nsudo zfs set aclinherit=passthrough pool\nsudo zfs set atime=off pool\n</code></pre> <p>Create a filesystem under <code>/mnt/pool/media</code> to configure it for media (larger record size and no monthly snapshots):</p> <pre><code>sudo zfs create pool/media\nsudo zfs set recordsize=1M pool/media\nsudo zfs set com.sun:auto-snapshot:monthly=false pool/media\n</code></pre>"},{"location":"zfs/#alerts","title":"Alerts","text":"<p>Pull the latest zed scripts that have ntfy support:</p> <pre><code>cd /etc/zfs/zed.d/\nsudo mv /etc/zfs/zed.d/zed-functions.sh /etc/zfs/zed.d/zed-functions.sh.bak\nsudo mv /etc/zfs/zed.d/zed.rc /etc/zfs/zed.d/zed.rc.bak\nsudo wget https://raw.githubusercontent.com/openzfs/zfs/master/cmd/zed/zed.d/zed-functions.sh\nsudo wget https://raw.githubusercontent.com/openzfs/zfs/master/cmd/zed/zed.d/zed.rc\nsudo chmod 0644 /etc/zfs/zed.d/zed-functions.sh\nsudo chmod 0600 /etc/zfs/zed.d/zed.rc\n</code></pre> <p>Edit <code>/etc/zfs/zed.d/zed.rc</code> and set the following:</p> <pre><code>ZED_NOTIFY_VERBOSE=1\nZED_NTFY_TOPIC=\"zfs\"\nZED_NTFY_URL=\"https://ntfy.domain.com\"\n</code></pre> <p>Restart zed:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl restart zed\n</code></pre> <p>Test the alerts:</p> <pre><code>cd /tmp\ndd if=/dev/zero of=sparse_file bs=1 count=0 seek=512M\nzpool create test /tmp/sparse_file\nzpool scrub test\n</code></pre> <p>Remove the test file:</p> <pre><code>zpool export test\nrm sparse_file\n</code></pre>"}]}