{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#tag:containers","title":"Containers","text":"<ul> <li>            Consolidating Proxies          </li> <li>            DNS for Containers          </li> <li>            Docker Server Storage          </li> <li>            Optimizing Nextcloud          </li> <li>            Piped          </li> <li>            SOCKS Proxy          </li> <li>            Searx-NG          </li> <li>            Simplelogin          </li> <li>            VPN Route          </li> <li>            VPS Proxy          </li> <li>            Wireguard Hub          </li> <li>            YAML Anchors          </li> </ul>"},{"location":"#tag:network","title":"Network","text":"<ul> <li>            Asus VLANs          </li> <li>            Firehol          </li> <li>            Geoblock          </li> <li>            Hardcoded DNS          </li> <li>            OPN-Arp          </li> <li>            Split DNS          </li> <li>            Split Tunnel          </li> </ul>"},{"location":"#tag:other","title":"Other","text":"<ul> <li>            Atuin          </li> <li>            Brave          </li> <li>            Phone          </li> <li>            Setup          </li> <li>            Smartd          </li> <li>            Tmux          </li> <li>            ZFS          </li> </ul>"},{"location":"Containers/consolidating-proxies/","title":"Consolidating Proxies","text":"<p>You can consolidate the majority of internal nginx proxies using mappings, these mappings get resolved when the mapped variables are used.</p> <p>Note - This doesn't work for every app since some require special configuration, but it works for most of them.</p>","tags":["Containers"]},{"location":"Containers/consolidating-proxies/#consolidated-proxies","title":"Consolidated proxies","text":"<pre><code>map $internal_app $internal_port {\n    babybuddy 8000;\n    bazarr 6767;\n    bitwarden 80;\n    collabora 9980;\n    drawio 8080;\n    gitea 3000;\n    heimdall 4443;\n    lidarr 8686;\n    mkdocs 8000;\n    paperless 8000;\n    photoview 80;\n    podgrab 8080;\n    prowlarr 9696;\n    radarr 7878;\n    scrutiny 8080;\n    sonarr 8989;\n    uptime 3001;\n    youtubedl 8080;\n}\nmap $internal_app $internal_proto {\n    default http;\n    collabora https;\n    heimdall https;\n}\nmap $internal_app $internal_container {\n    default $internal_app;\n    bazarr \"mullvad\";\n    lidarr \"mullvad\";\n    podgrab \"mullvad\";\n    prowlarr \"mullvad\";\n    radarr \"mullvad\";\n    sonarr \"mullvad\";\n}\nserver {\n    listen 443 ssl;\n    server_name ~^(?&lt;internal_app&gt;.*?)\\..*$;\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n    if ($lan-ip = no) { return 404; }\n\n    location / {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        proxy_pass $internal_proto://$internal_container:$internal_port;\n    }\n}\n</code></pre>","tags":["Containers"]},{"location":"Containers/consolidating-proxies/#explanation","title":"Explanation","text":"<p>We created 3 mappings:</p> <ol> <li><code>map $internal_app $internal_container</code> - app name to the container name, with the app name by default.</li> <li><code>map $internal_app $internal_proto</code> - app name to the protocol, with <code>http</code> by default.</li> <li><code>map $internal_app $internal_port</code> - app name to the app port, with no default.</li> </ol> <p>When a request comes in, it gets processed by the regular expression <code>~^(?&lt;internal_app&gt;.*?)\\..*$</code> which sets <code>$internal_app</code> with the subdomain, for example radarr in the case of <code>radarr.domain.com</code>.</p> <p>It then checks if the request is local, which requires defining what is the local network.</p> <p>The final part: <code>proxy_pass $internal_proto://$internal_container:$internal_port</code> figures out where to proxy the request based on the <code>$internal_app</code> variable, for example radarr gets proxied to <code>http://radarr:7878</code>.</p>","tags":["Containers"]},{"location":"Containers/container-dns/","title":"DNS for Containers","text":"","tags":["Containers"]},{"location":"Containers/container-dns/#problem","title":"Problem","text":"<p>The common setup is to have a server with many containers, and a network DNS such as pihole or adguardhome.</p> <p>The issue is that all dns queries by the server and all containers are grouped into a single bucket on the network DNS, making it difficult to track malicious DNS queries by a single container.</p>","tags":["Containers"]},{"location":"Containers/container-dns/#solution","title":"Solution","text":"<p>Create an adguardhome container for all the other containers to use as their DNS, and set the host as the upstream DNS for reverse lookups, so that container names will be displayed instead of IPs.</p> <p>These are the general steps with an example below:</p> <ul> <li>Create a bridge network with a static subnet.</li> <li>Create an adguardhome container with a static IP in that subnet.</li> <li>Assign all other containers static IPs in that subnet as well.</li> <li>Set the DNS of all other containers to the static IP of adguardhome.</li> <li>Set all other containers to depend on adguardhome.</li> </ul> <pre><code>networks:\n  internal:\n    driver: bridge\n    ipam:\n      config:\n        - subnet: 172.20.0.0/16\nservices:\n  agh:\n    image: adguard/adguardhome\n    container_name: agh\n    volumes:\n      - /path/to/agh/conf:/opt/adguardhome/conf\n      - /path/to/agh/work:/opt/adguardhome/work\n    networks:\n      internal:\n        ipv4_address: 172.20.20.20\n    ports:\n      - 13080:80\n      - 13000:3000\n  someapp:\n    networks:\n      internal:\n        ipv4_address: 172.20.0.2\n    dns: 172.20.20.20\n    depends_on:\n        - agh\n</code></pre>","tags":["Containers"]},{"location":"Containers/container-dns/#adguardhome-configuration","title":"AdguardHome Configuration","text":"<p>Go through the initial configuration on port 13000 and switch to port 13080 to access the web-ui.</p> <p>Settings &gt; General settings</p> <ul> <li>Block domains using filters and hosts files: Uncheck</li> <li>Enable log: Check</li> <li>Query logs rotation: 90 days</li> <li>Ignored domains: ||your-private-domain.tld^</li> <li>Enable statistics: Check</li> <li>Statistics retention: 90 days</li> <li>Ignored domains: ||your-private-domain.tld^</li> </ul> <p>Settings &gt; DNS settings</p> <ul> <li>Upstream DNS servers: <code>127.0.0.11</code>.</li> <li>Private reverse DNS servers: <code>127.0.0.11:53</code>.</li> <li>Use private reverse DNS resolvers: Check</li> <li>Rate limit: 0</li> </ul>","tags":["Containers"]},{"location":"Containers/docker-server-storage/","title":"Docker Server Storage","text":"<p>Docker server storage can be divided into 3 buckets:</p> <ul> <li>NVMe - fast storage for important data.</li> <li>SSD - disposable data.</li> <li>HDD - slow storage for important data.</li> </ul>","tags":["Containers"]},{"location":"Containers/docker-server-storage/#nvme","title":"NVMe","text":"<p>Fast storage, ideally on high endurance NVMe, ideally in a ZFS mirror with snapshots.</p> <p>Contains:</p> <ul> <li>Host OS</li> <li>Container config bind mounts</li> <li>Databases</li> <li>Small data that benefits from fast storage</li> </ul>","tags":["Containers"]},{"location":"Containers/docker-server-storage/#ssd","title":"SSD","text":"<p>Cheap SSD, disposable data that shouldn't reduce the lifespan of the NVMe and doesn't require ZFS redundancy or snapshots.</p> <p>Contains:</p> <ul> <li>Caches</li> <li>Logs</li> <li>Media transcodes</li> <li>Docker images and image volumes, change <code>data-root</code> under <code>/etc/docker/daemon.json</code><pre><code>{\n        \"data-root\": \"/mnt/cache/docker\",\n        \"storage-driver\": \"overlay2\"\n}\n</code></pre> </li> </ul>","tags":["Containers"]},{"location":"Containers/docker-server-storage/#hdd","title":"HDD","text":"<p>Slow storage, ideally in a ZFS mirror/raidz with snapshots.</p> <p>Contains:</p> <ul> <li>Media</li> <li>Photos</li> <li>Documents</li> <li>Large data</li> <li>Backup of NVMe data</li> </ul>","tags":["Containers"]},{"location":"Containers/docker-server-storage/#investigating-writes","title":"Investigating Writes","text":"<p>Install <code>fatrace</code></p> <pre><code>sudo apt install fatrace\n</code></pre> <p>Record writes for 60 seconds</p> <pre><code>sudo fatrace -f W -o /tmp/fatrace -s 60\n</code></pre> <p>Sort by count</p> <pre><code>sort /tmp/fatrace | uniq -c | sort -n -r | more\n</code></pre> <p>Example output</p> <pre><code>    271 beam.smp(65906): W   /home/user/docker-data/pinchflat/db/pinchflat.db-wal\n    166 nginx(270970): W   /home/user/docker-data/swag/log/nginx/access.log\n     60 Radarr(67147): W   /home/user/docker-data/arr/radarr/radarr.db-wal\n     57 Prowlarr(67150): W   /home/user/docker-data/arr/prowlarr/prowlarr.db-wal\n     46 fail2ban-client(68766): W   /home/user/docker-data/swag/fail2ban/fail2ban.sqlite3\n     45 Radarr(67147): W   /home/user/docker-data/arr/radarr/radarr.db-shm\n     40 Lidarr(67160): W   /home/user/docker-data/arr/lidarr/lidarr.db-wal\n     40 dockerd(57396): W   /mnt/cache/docker/containers/uuid/uuid-json.log\n     39 Prowlarr(67150): W   /home/user/docker-data/arr/prowlarr/prowlarr.db-shm\n     33 Radarr(67147): W   /home/user/docker-data/arr/radarr/radarr.db\n     32 postgres(61541): W   /home/user/docker-data/atuin/db/pg_stat_tmp/db_16384.tmp\n     32 dockerd(57396): W   /mnt/cache/docker/containers/uuid/uuid-json.log\n     28 Prowlarr(67150): W   /home/user/docker-data/arr/prowlarr/logs.db-wal\n     26 Sonarr(67148): W   /home/user/docker-data/arr/sonarr/logs.db-wal\n     26 Radarr(67147): W   /home/user/docker-data/arr/radarr/logs.db-shm\n     25 Prowlarr(67150): W   /home/user/docker-data/arr/prowlarr/prowlarr.db\n     19 Radarr(67147): CW  /home/user/docker-data/arr/radarr/radarr.db-wal\n     17 Radarr(67147): W   /home/user/docker-data/arr/radarr/logs.db-wal\n     17 Radarr(67147): W   /home/user/docker-data/arr/radarr/logs.db\n     17 Radarr(67147): CW  /home/user/docker-data/arr/radarr/radarr.db\n     16 beszel(61939): W   /home/user/docker-data/beszel/data.db-wal\n</code></pre>","tags":["Containers"]},{"location":"Containers/optimizing-nextcloud/","title":"Optimizing Nextcloud","text":"<p>A step by step guide for setting up:</p> <ul> <li>SWAG reverse proxy via cloudflare</li> <li>Nextcloud</li> <li>Redis</li> <li>Mariadb</li> <li>Collabora</li> <li>Notify push</li> <li>Talk high performance backend</li> <li>Whiteboard</li> <li>Imaginary</li> </ul> <p>Replace all occurences of <code>domain.com</code> with your domain.</p>","tags":["Containers"]},{"location":"Containers/optimizing-nextcloud/#swag","title":"SWAG","text":"<ul> <li>Create a Cloudflare account and set it as the nameserver for your domain.</li> <li>Create DNS records for <code>domain.com</code> and <code>*.domain.com</code> with your home's WAN IP, disable the orange cloud.</li> <li>Port forward <code>443</code> to your server on your home router.</li> <li>Add SWAG to your docker compose and start it.     <pre><code>swag:\n  image: lscr.io/linuxserver/swag:latest\n  container_name: swag\n  cap_add:\n    - NET_ADMIN\n  environment:\n    - PUID=1000\n    - PGID=1000\n    - TZ=Etc/UTC\n    - URL=domain.com\n    - VALIDATION=dns\n    - SUBDOMAINS=wildcard\n    - DNSPLUGIN=cloudflare\n    - PROPAGATION=60\n    - SWAG_AUTORELOAD=true\n  volumes:\n    - /path/to/swag:/config\n  ports:\n    - 443:443\n    - 80:80\n  restart: unless-stopped\n</code></pre></li> <li>Generate a Cloudflare API token with <code>DNS:Read, DNS:Edit</code> permissions to <code>domain.com</code> and copy the token.</li> <li>Edit <code>/path/to/swag/dns-conf/cloudflare.ini</code>, delete everything and paste the following with your token:   <pre><code>dns_cloudflare_api_token = token\n</code></pre></li> <li>Rename <code>/path/to/swag/nginx/proxy-confs/nextcloud.subdomain.conf.sample</code> to <code>nextcloud.subdomain.conf</code>.</li> <li>Edit <code>/path/to/swag/nginx/ssl.conf</code> and uncomment HSTS and all the additional headers on the bottom.</li> <li>Restart SWAG and make sure that <code>domain.com</code> shows the welcome page with a valid certificate.</li> </ul>","tags":["Containers"]},{"location":"Containers/optimizing-nextcloud/#nextcloud","title":"Nextcloud","text":"<ul> <li>Add Nextcloud, Mariadb, and Redis to your docker compose and start them.     <pre><code>nextcloud:\n  image: lscr.io/linuxserver/nextcloud:latest\n  container_name: nextcloud\n  environment:\n    - PUID=1000\n    - PGID=1000\n    - TZ=Etc/UTC\n  volumes:\n    - /path/to/nextcloud/config:/config\n    - /path/to/nextcloud/data:/data\n  restart: unless-stopped\n  depends_on:\n    - mariadb\nmariadb:\n  image: lscr.io/linuxserver/mariadb:latest\n  container_name: mariadb\n  environment:\n    - PUID=1000\n    - PGID=1000\n    - TZ=Etc/UTC\n    - MYSQL_ROOT_PASSWORD=nextcloud_root_password\n    - MYSQL_DATABASE=nextcloud_db\n    - MYSQL_USER=nextcloud_user\n    - MYSQL_PASSWORD=nextcloud_password\n  volumes:\n    - /path/to/mariadb:/config\n  restart: unless-stopped\nredis:\n  image: redis:alpine\n  container_name: redis\n  restart: unless-stopped\n</code></pre></li> <li>Navigate to <code>https://nextcloud.domain.com</code> and fill out the details for Nextcloud and Mariadb. </li> </ul> <ul> <li>Select recommended apps to install.</li> <li>Run the following commands.     <pre><code>docker exec nextcloud occ app:disable richdocumentscode\ndocker exec nextcloud occ maintenance:repair --include-expensive\ndocker exec nextcloud occ db:add-missing-indices\ndocker exec -u abc nextcloud mkdir -p /config/log/nextcloud\ndocker exec nextcloud occ config:system:set overwrite.cli.url --value='https://nextcloud.domain.com'\ndocker exec nextcloud occ config:system:set memcache.local --value='\\\\OC\\\\Memcache\\\\APCu'\ndocker exec nextcloud occ config:system:set memcache.locking --value='\\\\OC\\\\Memcache\\\\Redis'\ndocker exec nextcloud occ config:system:set memcache.distributed --value='\\\\OC\\\\Memcache\\\\Redis'\ndocker exec nextcloud occ config:system:set logfile --value='/config/log/nextcloud/nextcloud.log'\ndocker exec nextcloud occ config:system:set trusted_proxies 0 --value='172.16.0.0/12'\ndocker exec nextcloud occ config:system:set trusted_proxies 1 --value='127.0.0.1'\ndocker exec nextcloud occ config:system:set trusted_proxies 2 --value='::1'\ndocker exec nextcloud occ config:system:set redis host --value='redis'\ndocker exec nextcloud occ config:system:set redis port --value=6379 --type=integer\ndocker exec nextcloud occ config:system:set loglevel --value=2 --type=integer\ndocker exec nextcloud occ config:system:set log_rotate_size --value=10485760 --type=integer\ndocker exec nextcloud occ config:system:set maintenance_window_start --value=1 --type=integer\ndocker exec nextcloud occ config:system:set filesystem_check_changes --value=1 --type=integer\ndocker exec nextcloud occ config:system:set filelocking.enabled --value=true --type=boolean\n</code></pre></li> <li>Add the following to <code>/path/to/nextcloud/config/php/www2.conf</code>.   <pre><code>pm = dynamic\npm.max_children = 120\npm.start_servers = 12\npm.min_spare_servers = 6\npm.max_spare_servers = 18\n</code></pre></li> <li>Restart Nextcloud to apply the changes.</li> </ul>","tags":["Containers"]},{"location":"Containers/optimizing-nextcloud/#collabora","title":"Collabora","text":"<ul> <li>Add Collabora to your docker compose and start it.     <pre><code>collabora:\n  image: collabora/code\n  container_name: collabora\n  environment:\n    - DONT_GEN_SSL_CERT=1\n    - aliasgroup1=https://nextcloud.domain.com\n    - dictionaries=en_US\n    - server_name=nextcloud.domain.com\n    - extra_params=--o:security.capabilities=false --o:ssl.enable=false --o:ssl.termination=true --o:logging.level=warning --o:net.post_allow.host[0]=.+ --o:home_mode.enable=true --o:mount_jail_tree=false --o:mount_namespaces=false  --o:remote_font_config.url=https://nextcloud.domain.com/apps/richdocuments/settings/fonts.json\n  restart: unless-stopped\n  cap_add:\n    - SYS_CHROOT\n    - MKNOD\n</code></pre></li> <li>Add the following locations to <code>/path/to/swag/nginx/proxy-confs/nextcloud.subdomain.conf</code> inside the <code>server</code> section.     <pre><code>location ^~ /browser/ {\n    include /config/nginx/proxy.conf;\n    include /config/nginx/resolver.conf;\n    set $upstream_app collabora;\n    set $upstream_port 9980;\n    set $upstream_proto http;\n    proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n}\nlocation ^~ /hosting/ {\n    include /config/nginx/proxy.conf;\n    include /config/nginx/resolver.conf;\n    set $upstream_app collabora;\n    set $upstream_port 9980;\n    set $upstream_proto http;\n    proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n}\nlocation ^~ /cool/ {\n    include /config/nginx/proxy.conf;\n    include /config/nginx/resolver.conf;\n    set $upstream_app collabora;\n    set $upstream_port 9980;\n    set $upstream_proto http;\n    proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n}\n</code></pre></li> <li>Run the following commands.     <pre><code>docker exec nextcloud occ app:enable richdocuments\ndocker exec nextcloud occ config:app:set richdocuments wopi_url --value https://nextcloud.domain.com\ndocker exec nextcloud occ config:app:set richdocuments wopi_allowlist --value=0.0.0.0/0\ndocker exec nextcloud occ config:app:set richdocuments doc_format --value=ooxml\n</code></pre></li> <li>Disable Collabora's dark mode under View &gt; Dark Mode.</li> </ul>","tags":["Containers"]},{"location":"Containers/optimizing-nextcloud/#notify-push","title":"Notify Push","text":"<ul> <li>Add the following environment variable to Nextcloud's docker compose and recreate it.     <pre><code>environment:\n  - DOCKER_MODS=linuxserver/mods:nextcloud-notify-push\n</code></pre></li> </ul>","tags":["Containers"]},{"location":"Containers/optimizing-nextcloud/#talk-high-performance-backend","title":"Talk High Performance Backend","text":"<ul> <li>Generate 3 secrets using the following command and paste them to the compose below.     <pre><code>openssl rand -hex 32\n</code></pre></li> <li>Add the High Performance Backend to your docker compose and start it.     <pre><code>talk:\n  image: nextcloud/aio-talk:latest\n  container_name: talk\n  init: true\n  ports:\n    - 3478:3478/tcp\n    - 3478:3478/udp\n  environment:\n    - NC_DOMAIN=nextcloud.domain.com\n    - TALK_HOST=talk.domain.com\n    - TZ=Etc/UTC\n    - TALK_PORT=3478\n    - TURN_SECRET=secret\n    - SIGNALING_SECRET=secret\n    - INTERNAL_SECRET=secret\n  restart: unless-stopped\n</code></pre></li> <li>Paste the following to the bottom of <code>/path/to/swag/nginx/proxy-confs/nextcloud.subdomain.conf</code>.     <pre><code>server {\n    listen 443 ssl;\n    listen [::]:443 ssl;\n    server_name talk.*;\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location / {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        set $upstream_app talk;\n        set $upstream_port 8081;\n        set $upstream_proto http;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n    }\n}\n</code></pre></li> </ul> <ul> <li>Run the following commands using the secrets generated earlier.   <pre><code>docker exec nextcloud occ talk:signaling:add --verify https://talk.domain.com SIGNALING_SECRET\ndocker exec nextcloud occ talk:stun:add talk.domain.com:3478\ndocker exec nextcloud occ talk:turn:add --secret TURN_SECRET turn talk.domain.com:3478 udp,tcp\n</code></pre></li> <li>Optionally port forward <code>3478</code> on your router to expose it.</li> </ul>","tags":["Containers"]},{"location":"Containers/optimizing-nextcloud/#whiteboard","title":"Whiteboard","text":"<ul> <li>Generate a secret using the following command and paste it below.     <pre><code>openssl rand -hex 32\n</code></pre></li> <li>Add Whiteboard to your docker compose and start it.     <pre><code>whiteboard:\n  image: ghcr.io/nextcloud-releases/whiteboard:release\n  container_name: whiteboard\n  environment:\n    - NEXTCLOUD_URL=https://nextcloud.domain.com\n    - STORAGE_STRATEGY=redis\n    - REDIS_HOST=redis\n    - JWT_SECRET_KEY=secret\n  restart: unless-stopped\n</code></pre></li> <li>Paste the following to the bottom of <code>/path/to/swag/nginx/proxy-confs/nextcloud.subdomain.conf</code>.     <pre><code>server {\n    listen 443 ssl;\n    listen [::]:443 ssl;\n    server_name whiteboard.*;\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location / {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        set $upstream_app whiteboard;\n        set $upstream_port 3002;\n        set $upstream_proto http;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n    }\n}\n</code></pre></li> <li>Run the following commands.   <pre><code>docker exec nextcloud occ app:enable whiteboard\ndocker exec nextcloud occ config:app:set whiteboard collabBackendUrl --value=\"https://whiteboard.domain.com\"\ndocker exec nextcloud occ config:app:set whiteboard jwt_secret_key --value=\"secret\"\n</code></pre></li> </ul>","tags":["Containers"]},{"location":"Containers/optimizing-nextcloud/#imaginary","title":"Imaginary","text":"<ul> <li>Add Imaginary to your docker compose and start it.     <pre><code>imaginary:\n  image: nextcloud/aio-imaginary:latest\n  container_name: imaginary\n  restart: unless-stopped\n</code></pre></li> <li>Run the following commands.   <pre><code>docker exec nextcloud occ config:system:set enable_previews --value=true --type=boolean\ndocker exec nextcloud occ config:system:set enabledPreviewProviders 0 --value='OC\\\\Preview\\\\Imaginary'\ndocker exec nextcloud occ config:system:set enabledPreviewProviders 1 --value='OC\\\\Preview\\\\Movie'\ndocker exec nextcloud occ config:system:set enabledPreviewProviders 2 --value='OC\\\\Preview\\\\MP4'\ndocker exec nextcloud occ config:system:set preview_imaginary_url --value='http://imaginary:9000'\n</code></pre></li> </ul>","tags":["Containers"]},{"location":"Containers/optimizing-nextcloud/#maintenance","title":"Maintenance","text":"<ul> <li>Manually pull new images and recreate the containers every few weeks.</li> <li>Check <code>docker logs mariadb</code> for upgrade instructions.</li> <li>Run the following commands.   <pre><code>docker exec nextcloud occ maintenance:repair --include-expensive\ndocker exec nextcloud occ db:add-missing-indices\ndocker exec nextcloud occ app:update --all\n</code></pre></li> </ul>","tags":["Containers"]},{"location":"Containers/piped/","title":"Piped","text":"<p>Piped is an alternative YouTube frontend which is efficient by design.</p>","tags":["Containers"]},{"location":"Containers/piped/#compose","title":"Compose","text":"<p>Create the following containers:</p> <pre><code>  pipeddb:\n    image: postgres:13-alpine\n    container_name: pipeddb\n    volumes:\n      - /path/to/pipeddb:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_DB=piped\n      - POSTGRES_USER=piped\n      - POSTGRES_PASSWORD=&lt;PASSWORD&gt; # Set a database password\n    restart: always\n\n  pipedproxy:\n    image: 1337kavin/ytproxy\n    container_name: pipedproxy\n    user: \"1000:1000\" # Replace with the user and group IDs\n    volumes:\n      - /path/to/pipedproxy:/app/socket\n    restart: always\n\n  pipedfe:\n    image: 1337kavin/piped-frontend\n    container_name: pipedfe\n    # Replace pipedapi.mydomain.com with the API subdomain\n    entrypoint: ash -c 'sed -i s/pipedapi.kavin.rocks/pipedapi.mydomain.com/g /usr/share/nginx/html/assets/* &amp;&amp; /docker-entrypoint.sh &amp;&amp; nginx -g \"daemon off;\"' \n    restart: always\n\n  pipedapi:\n    image: 1337kavin/piped\n    container_name: pipedapi\n    volumes:\n      - /path/to/piped/config.properties:/app/config.properties:ro\n    restart: always\n</code></pre> <p>You may need to <code>chown -R 1000:1000 /path/to/pipedproxy</code> with your user and group ID.</p>","tags":["Containers"]},{"location":"Containers/piped/#configuration","title":"Configuration","text":"<p>Set the following configuration in <code>/path/to/piped/config.properties</code>:</p> <pre><code># The port to Listen on.\nPORT: 8080\n\n# The number of workers to use for the server\nHTTP_WORKERS: 2\n\n# Proxy\nPROXY_PART: https://pipedproxy.mydomain.com\n\n# Outgoing HTTP Proxy - eg: 127.0.0.1:8118\n#HTTP_PROXY: 127.0.0.1:8118\n\nFRONTEND_URL: https://piped.mydomain.com\n\n# Captcha Parameters\n#CAPTCHA_BASE_URL: https://api.capmonster.cloud/\n#CAPTCHA_API_KEY: INSERT_HERE\n\n# Public API URL\nAPI_URL: https://pipedapi.mydomain.com\n\n# Hibernate properties\nhibernate.connection.url: jdbc:postgresql://pipeddb:5432/piped\nhibernate.connection.driver_class: org.postgresql.Driver\nhibernate.dialect: org.hibernate.dialect.PostgreSQL10Dialect\nhibernate.connection.username: piped\nhibernate.connection.password: &lt;PASSWORD&gt; # Replace with the database password\n</code></pre>","tags":["Containers"]},{"location":"Containers/piped/#reverse-proxy","title":"Reverse Proxy","text":"<pre><code>server {\n    listen 443 ssl;\n    server_name piped.mydomain.com; # Set the API domain\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location / {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        set $upstream_app pipedfe;\n        set $upstream_port 80;\n        set $upstream_proto http;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n    }\n}\n\nserver {\n    listen 443 ssl;\n    server_name pipedapi.mydomain.com; # Set the frontend domain\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location / {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        set $upstream_app pipedapi;\n        set $upstream_port 8080;\n        set $upstream_proto http;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n    }\n    location /webhooks/pubsub {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        set $upstream_app pipedapi;\n        set $upstream_port 8080;\n        set $upstream_proto http;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n    }\n}\n\nserver {\n    listen 443 ssl;\n    server_name pipedproxy.mydomain.com; # Set the proxy domain\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location ~ (/videoplayback|/api/v4/|/api/manifest/) {\n        proxy_pass http://unix:/var/run/ytproxy/http-proxy.sock;\n        add_header Access-Control-Allow-Origin *;\n        add_header Access-Control-Allow-Headers *;\n        if ($request_method = OPTIONS ) {\n            return 200;\n        }\n        proxy_buffering on;\n        proxy_set_header Host $arg_host;\n        proxy_ssl_server_name on;\n        proxy_set_header X-Forwarded-For \"\";\n        proxy_set_header CF-Connecting-IP \"\";\n        proxy_hide_header \"alt-svc\";\n        sendfile on;\n        sendfile_max_chunk 512k;\n        tcp_nopush on;\n        aio threads=default;\n        aio_write on;\n        directio 2m;\n        proxy_hide_header Cache-Control;\n        proxy_hide_header etag;\n        proxy_http_version 1.1;\n        proxy_set_header Connection keep-alive;\n        proxy_max_temp_file_size 0;\n        access_log off;\n        add_header Cache-Control private always;\n        proxy_hide_header Access-Control-Allow-Origin;\n    }\n\n    location / {\n        proxy_pass http://unix:/var/run/ytproxy/http-proxy.sock;\n        add_header Access-Control-Allow-Origin *;\n        add_header Access-Control-Allow-Headers *;\n        if ($request_method = OPTIONS ) {\n            return 200;\n        }\n        proxy_buffering on;\n        proxy_set_header Host $arg_host;\n        proxy_ssl_server_name on;\n        proxy_set_header X-Forwarded-For \"\";\n        proxy_set_header CF-Connecting-IP \"\";\n        proxy_hide_header \"alt-svc\";\n        sendfile on;\n        sendfile_max_chunk 512k;\n        tcp_nopush on;\n        aio threads=default;\n        aio_write on;\n        directio 2m;\n        proxy_hide_header Cache-Control;\n        proxy_hide_header etag;\n        proxy_http_version 1.1;\n        proxy_set_header Connection keep-alive;\n        proxy_max_temp_file_size 0;\n        access_log off;\n        add_header Cache-Control \"public, max-age=604800\";\n        proxy_hide_header Access-Control-Allow-Origin;\n    }\n}\n</code></pre> <p>All the sub-domains can remain internal-only except for the following domain that must be exposed for subscriptions to work:</p> <pre><code>    location /webhooks/pubsub {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        set $upstream_app pipedapi;\n        set $upstream_port 8080;\n        set $upstream_proto http;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n    }\n</code></pre> <p>And finally, add the following volume to SWAG: <pre><code>  - /path/to/pipedproxy:/var/run/ytproxy\n</code></pre></p>","tags":["Containers"]},{"location":"Containers/searx-ng/","title":"Searx-NG","text":"<p>SearXNG is a free metasearch engine with the aim of protecting the privacy of its users. To this end, Searx does not share users' IP addresses or search history with the search engines from which it gathers results. Tracking cookies served by the search engines are blocked, preventing user-profiling-based results modification.</p>","tags":["Containers"]},{"location":"Containers/searx-ng/#installation","title":"Installation","text":"","tags":["Containers"]},{"location":"Containers/searx-ng/#compose","title":"Compose","text":"<pre><code>  searxng:\n    image: searxng/searxng\n    container_name: searxng\n    volumes:\n      - /path/to/searxng:/etc/searxng\n    environment:\n      - BASE_URL=https://search.yourdomain.com/\n    ports:\n      - 8080:8080\n    restart: always\n</code></pre>","tags":["Containers"]},{"location":"Containers/searx-ng/#reverse-proxy","title":"Reverse Proxy","text":"<pre><code>server {\n    listen 443 ssl;\n    server_name search.yourdomain.com;\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location / {\n        include /config/nginx/proxy.conf;\n        include /config/nginx/resolver.conf;\n        set $upstream_app searxng;\n        set $upstream_port 8080;\n        set $upstream_proto http;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n    }\n}\n</code></pre>","tags":["Containers"]},{"location":"Containers/searx-ng/#settings","title":"Settings","text":"<p>The settings file is <code>/path/to/searx/settings.yml</code>, it can seem overwhelming but the majority of it are the search engine configuration which can be enabled/disabled from the UI.</p> <p>These settings may require changing in the file: <pre><code># see https://docs.searxng.org/admin/engines/settings.html#use-default-settings\nuse_default_settings: true\ngeneral:\n  debug: false\n  instance_name: \"Search\"\n  privacypolicy_url: false\n  donation_url: false\n  contact_url: false\n  enable_metrics: false\nserver:\n  secret_key: \"CHANGE THIS\"\n  limiter: false  # can be disabled for a private instance\n  image_proxy: true\nui:\n  static_use_hash: true\n  default_theme: simple\n  theme_args:\n    simple_style: dark\n  infinite_scroll: true\n  query_in_title: true\nsearch:\n  autocomplete: \"duckduckgo\"\n  default_lang: \"all\"\nenabled_plugins:\n  - 'Hash plugin'\n  - 'Search on category select'\n  - 'Self Informations'\n  - 'Tracker URL remover'\n  - 'Hostnames plugin'\n  - 'Open Access DOI rewrite'\n  - 'Unit converter plugin'\nhostnames:\n  high_priority:\n    - '(.*)\\/blog\\/(.*)'\n    - '(.*\\.)?wikipedia.org$'\n    - '(.*\\.)?github.com$'\n    - '(.*\\.)?reddit.com$'\n    - '(.*\\.)?linuxserver.io$'\n    - '(.*\\.)?docker.com$'\n    - '(.*\\.)?archlinux.org$'\n    - '(.*\\.)?stackoverflow.com$'\n    - '(.*\\.)?askubuntu.com$'\n    - '(.*\\.)?superuser.com$'\n  remove:\n    - '(.*\\.)?facebook.com$'\n    - '(.*\\.)?instagram.com$'\n    - '(.*\\.)?codegrepper.com$'\n    - '(.*\\.)?w3schools.com$'\n    - '(.*\\.)?geeksforgeeks.org$'\n    - '(.*\\.)?stackshare.io$'\n    - '(.*\\.)?tutorialspoint.com$'\n    - '(.*\\.)?answeright.com$'\n    - '(.*\\.)?askdev.info$'\n    - '(.*\\.)?askdev.io$'\n    - '(.*\\.)?blogmepost.com$'\n    - '(.*\\.)?c-sharpcorner.com$'\n    - '(.*\\.)?code-examples.net$'\n    - '(.*\\.)?codeflow.site$'\n    - '(.*\\.)?gitmemory.cn$'\n    - '(.*\\.)?gitmemory.com$'\n    - '(.*\\.)?intellipaat.com$'\n    - '(.*\\.)?javaer101.com$'\n    - '(.*\\.)?programmerstart.com$'\n    - '(.*\\.)?programmersought.com$'\n    - '(.*\\.)?qastack.com$'\n    - '(.*\\.)?roboflow.ai$'\n    - '(.*\\.)?stackanswers.net$'\n    - '(.*\\.)?stackoom.com$'\n    - '(.*\\.)?stackovernet.com$'\n    - '(.*\\.)?stackovernet.xyz$'\n    - '(.*\\.)?stackoverrun.com$'\n    - '(.*\\.)?thetopsites.net$'\n    - '(.*\\.)?ubuntugeeks.com$'\n    - '(.*\\.)?cyberciti.biz$'\n    - '(.*\\.)?ispycode.com$'\n    - '(.*\\.)?reposhub.com$'\n    - '(.*\\.)?githubmemory.com$'\n    - '(.*\\.)?issueexplorer.com$'\n    - '(.*\\.)?tabnine.com$'\n    - '(.*\\.)?gitcode.net$'\n    - '(.*\\.)?command-not-found.com$'\n    - '(.*\\.)?im-coder.com$'\n    - '(.*\\.)?i-harness.com$'\n  replace:\n    '(.*\\.)?reddit.com$': 'some.redlib.com'\n    '(.*\\.)?redd.it$': 'some.redlib.com'\n    '(.*\\.)?youtube.com$': 'some.piped.com'\n    '(.*\\.)?youtu.be$': 'some.piped.com'\n</code></pre></p>","tags":["Containers"]},{"location":"Containers/searx-ng/#rate-limiting-optional","title":"Rate Limiting (Optional)","text":"<p>Rate limiting can be enabled by adding a redis container and setting these: <pre><code>server:\n  limiter: true  # can be disabled for a private instance\nredis:\n  url: redis://redis:6379/0\n</code></pre></p> <p>An example compose can be found here.</p>","tags":["Containers"]},{"location":"Containers/simplelogin/","title":"Simplelogin","text":"","tags":["Containers"]},{"location":"Containers/simplelogin/#strategy","title":"Strategy","text":"","tags":["Containers"]},{"location":"Containers/simplelogin/#notes","title":"Notes","text":"<ul> <li>Check the reputation of your VPS IP before proceeding.</li> <li>Follow the official documentation to set up the domain.</li> <li>Read about each environment variable of simplelogin and postfix.</li> <li>Using SWAG to generate certs and then mounting the certs to postfix.</li> <li>SWAG has the following post-renewal hook under <code>./swag/etc/letsencrypt/renewal-hooks/post/postfix.sh</code>:<pre><code>#!/usr/bin/with-contenv bash\n\ntouch /config/etc/letsencrypt/postfix_renew\n</code></pre> </li> </ul> <ul> <li>Postfix has the following script mounted to <code>/etc/periodic/hourly/renew-postfix-tls</code> for reloading on cert updates:<pre><code>#!/usr/bin/env bash\n\nset -e\n\nif [ -f ${RENEW_PATH} ]; then\n    /src/generate_config.py --postfix\n    postfix reload\n    rm -f ${RENEW_PATH}\nfi\n</code></pre> </li> </ul> <ul> <li>Setting up Crowdsec, Geoblock, and Firehol is highly recommended.</li> <li>Check the dmarc once you finish setting everything up.</li> <li>Check the spammyness once you finish setting everything up.</li> </ul>","tags":["Containers"]},{"location":"Containers/simplelogin/#example-compose","title":"Example Compose","text":"<pre><code>  simplelogin:\n    image: lscr.io/linuxserver-labs/simplelogin:latest\n    container_name: simplelogin\n    volumes:\n      - ./mail/sl:/config\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n      - DB_URI=postgresql://dbuser:dbpassword@sldb:5432/simplelogin\n    ports:\n      - 7777:7777\n    restart: unless-stopped\n  sldb:\n    image: postgres:12.1-alpine\n    container_name: sldb\n    volumes:\n      - ./mail/db:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_USER=dbuser\n      - POSTGRES_PASSWORD=dbpassword\n      - POSTGRES_DB=simplelogin\n    restart: unless-stopped\n  postfix:\n    container_name: postfix\n    image: simplelogin/postfix:4.2.0\n    ports:\n      - \"0.0.0.0:25:25\"\n      - \"0.0.0.0:465:465\"\n    volumes:\n      - ./mail/db:/var/lib/postgresql/data\n      - ./swag/etc/letsencrypt:/etc/letsencrypt\n      - ./mail/check-cert.sh:/etc/periodic/hourly/renew-postfix-tls:ro\n    environment:\n      - DB_HOST=sldb\n      - DB_USER=dbuser\n      - DB_PASSWORD=dbpassword\n      - DB_NAME=simplelogin\n      - EMAIL_HANDLER_HOST=simplelogin\n      - POSTFIX_FQDN=mail.domain.com\n      - ALIASES_DEFAULT_DOMAIN=domain.com\n      - LETSENCRYPT_EMAIL=support@domain.com\n      - TLS_KEY_FILE=/etc/letsencrypt/live/domain.com/privkey.pem\n      - TLS_CERT_FILE=/etc/letsencrypt/live/domain.com/fullchain.pem\n      - RENEW_PATH=/etc/letsencrypt/postfix_renew\n      - POSTFIX_DQN_KEY=dqnkey\n      - SIMPLELOGIN_COMPATIBILITY_MODE=v4\n    restart: unless-stopped\n</code></pre>","tags":["Containers"]},{"location":"Containers/simplelogin/#example-env-file","title":"Example ENV File","text":"<pre><code>URL=https://simplelogin.domain.com\nEMAIL_DOMAIN=domain.com\nSUPPORT_EMAIL=support@domain.com\nADMIN_EMAIL=support@domain.com\nEMAIL_SERVERS_WITH_PRIORITY=[(10, \"mail.domain.com.\")]\nDKIM_PRIVATE_KEY_PATH=/config/dkim.key\nDB_URI=postgresql://dbuser:dbpassword@sldb:5432/simplelogin\nFLASK_SECRET=secret123\nGNUPGHOME=/config/gnupg\nLOCAL_FILE_UPLOAD=1\nPOSTFIX_SERVER=postfix\nDISABLE_ONBOARDING=true\nNAMESERVERS=\"1.1.1.1\"\nDISABLE_REGISTRATION=0\n</code></pre>","tags":["Containers"]},{"location":"Containers/simplelogin/#self-test","title":"Self Test","text":"<p>Create <code>test</code> aliases for each domain and disable them so you won't get emails. Add the following to your host's cron, edit the <code>TARGETS</code> and <code>curl</code> command accordingly.</p> <pre><code>#!/bin/bash\n\nTARGETS=(\"test@domain1.com\" \"test@domain2.com\" \"test@domain3.com\")\n\nfor TARGET in \"${TARGETS[@]}\"; do\n    docker exec postfix sendmail $TARGET\n    sleep 10\n    result=$(docker exec sldb psql -U sl_user simplelogin -AXqtc \"SELECT COUNT(*) FROM email_log JOIN alias ON email_log.alias_id = alias.id WHERE alias.email = '$TARGET' AND email_log.created_at BETWEEN NOW() - INTERVAL '5 MINUTES' AND NOW();\")\n    if [[ \"$result\" -lt 1 ]]; then\n        curl -d \"Email test failed for $TARGET\" \"https://ntfy.domain1.com/topic\"\n    fi\ndone\n</code></pre>","tags":["Containers"]},{"location":"Containers/socks-proxy/","title":"SOCKS Proxy","text":"<p>This setup allows you to route specific applications through randomized SOCKS proxies by your VPN provider without the entire devices having to connect to the VPN.</p>","tags":["Containers"]},{"location":"Containers/socks-proxy/#tldr","title":"TLDR","text":"<p>Use NGINX through a Wireguard container to load balance between the VPN provider's SOCKS5 proxies and configure applications to use the NGINX proxy.</p>","tags":["Containers"]},{"location":"Containers/socks-proxy/#initial-vpn-wireguard-client-configuration","title":"Initial VPN Wireguard Client Configuration","text":"<p>Configure your VPN Wireguard Client according to the Wireguard documentation.</p> <pre><code>  vpn:\n    image: ghcr.io/linuxserver/wireguard\n    container_name: vpn\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n    volumes:\n      - /path/to/appdata/config:/config\n      - /lib/modules:/lib/modules\n    restart: unless-stopped\n</code></pre> <p>Once done start the container and validate that <code>docker logs vpn</code> contains no errors (Ignore the missing wg0.conf message).</p>","tags":["Containers"]},{"location":"Containers/socks-proxy/#connecting-the-wireguard-client-to-the-vpn","title":"Connecting the Wireguard Client to the VPN","text":"<p>Copy the Wireguard configuration that you get from your VPN provider into a file called <code>wg0.conf</code> and place it in your VPN Wireguard Client's <code>config</code> folder, and make the following changes:</p> <ul> <li>Remove IPv6 addresses (and ::/0) if you haven't enabled IPv6 in your docker network</li> <li>Add the <code>PostUp</code> and <code>PreDown</code> lines listed below <pre><code>[Interface]\nPrivateKey = &lt;private-key&gt;\nAddress = &lt;some-address&gt;/32\nDNS = &lt;some-address&gt;\nPostUp = DROUTE=$(ip route | grep default | awk '{print $3}'); HOMENET=192.168.0.0/16; HOMENET2=10.0.0.0/12; HOMENET3=172.16.0.0/12; ip route add $HOMENET3 via $DROUTE;ip route add $HOMENET2 via $DROUTE; ip route add $HOMENET via $DROUTE;iptables -I OUTPUT -d $HOMENET -j ACCEPT;iptables -A OUTPUT -d $HOMENET2 -j ACCEPT; iptables -A OUTPUT -d $HOMENET3 -j ACCEPT;  iptables -A OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT\nPreDown = DROUTE=$(ip route | grep default | awk '{print $3}'); HOMENET=192.168.0.0/16; HOMENET2=10.0.0.0/12; HOMENET3=172.16.0.0/12; ip route del $HOMENET3 via $DROUTE;ip route del $HOMENET2 via $DROUTE; ip route del $HOMENET via $DROUTE; iptables -D OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT; iptables -D OUTPUT -d $HOMENET -j ACCEPT; iptables -D OUTPUT -d $HOMENET2 -j ACCEPT; iptables -D OUTPUT -d $HOMENET3 -j ACCEPT\n\n[Peer]\nPublicKey = &lt;public-key&gt;\nAllowedIPs = 0.0.0.0/0\nEndpoint = &lt;some-address&gt;:&lt;some-port&gt;\n</code></pre> The PostUp command adds a killswitch using iptables rules to prevent connections on other interfaces. Connections from LAN networks are still allowed to be able to connect to the services in the containers. The PreDown command cleans up these rules when the VPN goes down.</li> </ul> <p>Save the changes and restart the container with <code>docker restart vpn</code>, validate that <code>docker logs vpn</code> contains no errors.</p> <p>Perform the following validations to check that the VPN works:</p> <ul> <li>Check that you have connectivity by running <code>docker exec vpn ping 1.1.1.1</code></li> <li>Check that the VPN is working by running <code>docker exec vpn curl -s https://am.i.mullvad.net/ip</code>, you should get an IP that is different from your internet's IP.</li> </ul>","tags":["Containers"]},{"location":"Containers/socks-proxy/#nginx-configuration","title":"NGINX Configuration","text":"<p>Create an NGINX container using the following compose:</p> <pre><code>---\n  proxy:\n    image: ghcr.io/linuxserver/nginx\n    container_name: proxy\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n    volumes:\n      - &lt;/path/to/proxy/config&gt;:/config\n    network_mode: \"service:vpn\"\n    restart: unless-stopped\n</code></pre> <p>Edit <code>/path/to/proxy/config/nginx/nginx.conf</code>, delete everything and paste the following:</p> <pre><code>## Version 2021/06/15 - Changelog: https://github.com/linuxserver/docker-baseimage-alpine-nginx/commits/master/root/defaults/nginx.conf\n\nuser abc;\nworker_processes 4;\npid /run/nginx.pid;\ninclude /etc/nginx/modules/*.conf;\n\nevents {\n    worker_connections 768;\n}\n\nstream {\n    upstream stream_backend {\n        random;\n        server ch5-wg.socks5.mullvad.net:1080;\n        server ch6-wg.socks5.mullvad.net:1080;\n        server ch7-wg.socks5.mullvad.net:1080;\n        server ch8-wg.socks5.mullvad.net:1080;\n        server ch9-wg.socks5.mullvad.net:1080;\n    }\n\n    server {\n        listen 1080;\n        proxy_pass stream_backend;\n    }\n}\n\ndaemon off;\n</code></pre> <p>Replace the list of proxy servers such as <code>server ch5-wg.socks5.mullvad.net:1080</code> with proxy servers of your VPN provider.</p> <p>Add the port under the VPN Wireguard Client container:</p> <pre><code>    ports:\n      - 1080:1080 # SOCKS proxy\n</code></pre> <p>Recreate the VPN Wireguard Client container to apply the changes, then recreate the NGINX proxy container which depends on the VPN.</p> <p>Check that the proxy is working by running the following multiple times, you should get different IPs that are different from your internet's IP.</p> <pre><code>curl --socks5 localhost:1080 https://ifconfig.me\n</code></pre> <p>Now configure the applications to use the SOCKS proxy on your server's IP and port 1080, and exclude your local domain and IP range.</p> <p>For example in Firefox:</p> <p></p>","tags":["Containers"]},{"location":"Containers/socks-proxy/#notes","title":"Notes","text":"<ul> <li>If there are other containers routed through the same VPN container, the SOCKS proxy will act as another hop meaning if you connect to a VPN in one country and select a SOCKS proxy in another country, it will hop twice which is more secure.</li> </ul> <ul> <li>The performance should be almost identical to not having a SOCKS proxy, if you feel any slowness then select another proxy provided by your VPN provider.</li> </ul>","tags":["Containers"]},{"location":"Containers/vpn-route/","title":"VPN Route","text":"<p>This setup allows you to route containers through a VPN and protect yourself from your ISP.</p> <p>This guide is the basic step-by-step version of great blog posts by Spad and Tokugero which also contain more advanced information.</p> <p>qBittorrent and Mullvad are used in this guide as an example, but you can route any container the same way, and use any VPN service that supports Wireguard.</p>","tags":["Containers"]},{"location":"Containers/vpn-route/#requirements","title":"Requirements","text":"<ul> <li>A working instance of qBittorrent</li> </ul>","tags":["Containers"]},{"location":"Containers/vpn-route/#initial-vpn-wireguard-client-configuration","title":"Initial VPN Wireguard Client Configuration","text":"<p>Configure your VPN Wireguard Client according to the Wireguard documentation.</p> <pre><code>  vpn:\n    image: ghcr.io/linuxserver/wireguard\n    container_name: vpn\n    cap_add:\n      - NET_ADMIN\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n    volumes:\n      - /path/to/appdata/config:/config\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1\n    restart: unless-stopped\n</code></pre> <p>Once done start the container and validate that <code>docker logs vpn</code> contains no errors (Ignore the missing wg0.conf message).</p>","tags":["Containers"]},{"location":"Containers/vpn-route/#connecting-the-wireguard-client-to-the-vpn","title":"Connecting the Wireguard Client to the VPN","text":"<p>Copy the Wireguard configuration that you get from your VPN provider into a file called <code>wg0.conf</code> and place it in your VPN Wireguard Client's <code>config/wg_confs</code> folder, and make the following changes:</p> <ul> <li>Remove IPv6 addresses (and ::/0) if you haven't enabled IPv6 in your docker network</li> <li>Add the <code>PostUp</code> and <code>PreDown</code> lines listed below</li> </ul> <pre><code>[Interface]\nPrivateKey = &lt;private-key&gt;\nAddress = &lt;some-address&gt;/32\nDNS = &lt;some-address&gt;\nPostUp = DROUTE=$(ip route | grep default | awk '{print $3}'); HOMENET=192.168.0.0/16; HOMENET2=10.0.0.0/12; HOMENET3=172.16.0.0/12; ip route add $HOMENET3 via $DROUTE;ip route add $HOMENET2 via $DROUTE; ip route add $HOMENET via $DROUTE;iptables -I OUTPUT -d $HOMENET -j ACCEPT;iptables -A OUTPUT -d $HOMENET2 -j ACCEPT; iptables -A OUTPUT -d $HOMENET3 -j ACCEPT;  iptables -A OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT\nPreDown = DROUTE=$(ip route | grep default | awk '{print $3}'); HOMENET=192.168.0.0/16; HOMENET2=10.0.0.0/12; HOMENET3=172.16.0.0/12; ip route del $HOMENET3 via $DROUTE;ip route del $HOMENET2 via $DROUTE; ip route del $HOMENET via $DROUTE; iptables -D OUTPUT ! -o %i -m mark ! --mark $(wg show %i fwmark) -m addrtype ! --dst-type LOCAL -j REJECT; iptables -D OUTPUT -d $HOMENET -j ACCEPT; iptables -D OUTPUT -d $HOMENET2 -j ACCEPT; iptables -D OUTPUT -d $HOMENET3 -j ACCEPT\n\n[Peer]\nPublicKey = &lt;public-key&gt;\nAllowedIPs = 0.0.0.0/0\nEndpoint = &lt;some-address&gt;:&lt;some-port&gt;\n</code></pre> <p>The PostUp command adds a killswitch using iptables rules to prevent connections on other interfaces, and maintains connections to the web-ui of the services in the containers. The PreDown command cleans up these rules when the VPN goes down.</p> <p>Save the changes and restart the container with <code>docker restart vpn</code>, validate that <code>docker logs vpn</code> contains no errors.</p> <p>Perform the following validations to check that the VPN works:</p> <ul> <li>Check that you have connectivity by running <code>docker exec vpn ping 1.1.1.1</code></li> <li>Check that the VPN is working by running <code>docker exec vpn curl -s https://am.i.mullvad.net/ip</code>, you should get an IP that is different from your internet's IP.</li> </ul>","tags":["Containers"]},{"location":"Containers/vpn-route/#routing-qbittorrent-through-the-vpn","title":"Routing qBittorrent Through the VPN","text":"<p>Replace the following lines on the qBittorrent container:</p> <pre><code>    ports:\n      - 6881:6881\n      - 6881:6881/udp\n      - 8080:8080\n</code></pre> <p>With:</p> <pre><code>    network_mode: \"service:vpn\"\n    depends_on:\n      - vpn\n</code></pre> <p>Add the port under the VPN Wireguard Client container:</p> <pre><code>    ports:\n      - 8080:8080 # qBittorrent\n</code></pre> <p>Recreate the VPN Wireguard Client container to apply the changes, then recreate the qBittorrent container which depends on the VPN.</p> <p>Perform the following validations to check that the VPN works:</p> <ul> <li>Check that the VPN is working by running <code>docker exec qbittorrent curl -s https://am.i.mullvad.net/ip</code> and make sure you don't get your internet's IP.</li> <li>Check that qBittorrent's Web Administration interface is working by browsing http://<code>&lt;server-ip&gt;</code>:8080.</li> </ul>","tags":["Containers"]},{"location":"Containers/vpn-route/#configuring-other-containers","title":"Configuring Other Containers","text":"<p>Now that qBittorrent is routed through the VPN, other containers like swag, radarr, sonarr, prowlarr, etc, need to be configured to use <code>vpn</code> instead of <code>qbittorrent</code> as the container name for reaching qBittorrent.</p>","tags":["Containers"]},{"location":"Containers/vpn-route/#swag","title":"SWAG","text":"<p>Edit your <code>qbittorrent.subdomain.conf</code> or <code>qbittorrent.subfolder.conf</code> in SWAG's config folder under <code>config/nginx/proxy-confs/</code>.</p> <p>Replace all occurrences of <code>set $upstream_app qbittorrent;</code> with <code>set $upstream_app vpn;</code>.</p> <p>Restart the SWAG to apply the changes with <code>docker restart swag</code>.</p>","tags":["Containers"]},{"location":"Containers/vpn-route/#sonarr-radarr","title":"Sonarr / Radarr","text":"<p>Under <code>Settings</code> &gt; <code>Download Clients</code> &gt; Click qBittorrent's Download Client &gt; Set <code>Host</code> to <code>vpn</code> &gt; click <code>Test</code> &amp; <code>Save</code>.</p>","tags":["Containers"]},{"location":"Containers/vpn-route/#notes","title":"Notes","text":"","tags":["Containers"]},{"location":"Containers/vpn-route/#port-forwarding","title":"Port forwarding","text":"<p>VPN providers like Torguard support port forwarding, if your application needs it.</p> <p>Copy the port number you got to <code>qBittorrent</code> &gt; <code>Settings</code> &gt; <code>Connection</code> &gt; <code>Port used for incoming connections</code>.</p>","tags":["Containers"]},{"location":"Containers/vpn-route/#restarting-order","title":"Restarting order","text":"<p>If you're experiencing problems and you want to restart everything, the correct order is:</p> <ul> <li>VPN - <code>docker restart vpn</code></li> <li>Containers using the VPN - <code>docker restart &lt;container&gt;</code></li> </ul>","tags":["Containers"]},{"location":"Containers/vpn-route/#cant-connect-to-the-web-ui-of-routed-containers","title":"Can't connect to the Web-UI of routed containers","text":"<p>Make sure that you have added <code>PostUp</code> and <code>PreDown</code> to <code>wg0.conf</code> as detailed in Connecting the Wireguard Client to the VPN.</p>","tags":["Containers"]},{"location":"Containers/vpn-route/#dns-leaks","title":"DNS leaks","text":"<p>If you want to make sure wireguard isn't using your local DNS, add the following to the vpn's compose (Replace <code>8.8.8.8</code> with your DNS of choice):   <pre><code>dns:\n  - 8.8.8.8\n</code></pre></p>","tags":["Containers"]},{"location":"Containers/vps-proxy/","title":"VPS Proxy","text":"<p>This setup allows you to hide your home IP, protect your privacy and protect your home server against DDOS attacks while keeping all of your data at home.</p> <p>Once it's up and running, exposing a resource through the VPS is as simple as adding one line to your home SWAG.</p> <p>The TLDR version is:</p> <ul> <li>Create a VPN tunnel between your home and a VPS</li> <li>Configure SWAG to proxy traffic through the tunnel</li> <li>Configure Fail2ban to block attackers</li> </ul> <p>There are many ways to create this setup with many variations for many different purposes, in my opinion these containers are easy to work with and to maintain, every container in this setup can be used for other purposes as well as being used for the proxy without any compromises:</p> <ul> <li>Home SWAG can be used as a reverse proxy for all of your other Home server containers.</li> <li>Home Wireguard Client can be used to route any container through the VPS.</li> <li>VPS SWAG can be used as a reverse proxy for all of your other VPS containers.</li> <li>VPS Wireguard Server can be used as your private cloud VPN server.</li> </ul>","tags":["Containers"]},{"location":"Containers/vps-proxy/#requirements","title":"Requirements","text":"<ul> <li>A working instance of SWAG at home</li> <li>A working instance of SWAG on the VPS</li> </ul>","tags":["Containers"]},{"location":"Containers/vps-proxy/#initial-vps-wireguard-server-configuration","title":"Initial VPS Wireguard Server Configuration","text":"<p>Configure your VPS Wireguard Server according to the Wireguard documentation.</p> <pre><code>  wireguard:\n    image: ghcr.io/linuxserver/wireguard\n    container_name: wireguard\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n      - SERVERURL=external.com\n      - SERVERPORT=51820\n      - PEERS=1\n      - PEERDNS=auto\n      - INTERNAL_SUBNET=10.13.13.0\n      - ALLOWEDIPS=10.13.13.0/24\n    volumes:\n      - /path/to/appdata/config:/config\n      - /lib/modules:/lib/modules\n    ports:\n      - 51820:51820/udp\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1\n    restart: unless-stopped\n</code></pre> <p>Note that <code>ALLOWEDIPS</code> is set to only allow access to the Wireguard subnet.</p> <p>Once done start the container and validate that <code>docker logs wireguard</code> contains no errors.</p>","tags":["Containers"]},{"location":"Containers/vps-proxy/#initial-home-wireguard-client-configuration","title":"Initial Home Wireguard Client Configuration","text":"<p>Configure your Home Wireguard Client according to the Wireguard documentation.</p> <pre><code>  wireguard:\n    image: ghcr.io/linuxserver/wireguard\n    container_name: wireguard\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Europe/London\n    volumes:\n      - /path/to/appdata/config:/config\n      - /lib/modules:/lib/modules\n    restart: unless-stopped\n</code></pre> <p>Once done start the container and validate that <code>docker logs wireguard</code> contains no errors (Ignore the missing wg0.conf message).</p>","tags":["Containers"]},{"location":"Containers/vps-proxy/#connecting-the-wireguard-client-to-the-wireguard-server","title":"Connecting the Wireguard Client to the Wireguard Server","text":"<p>Copy <code>peer1.conf</code> from your VPS Wireguard Server's <code>config/peer1/</code> folder to your Home Wireguard Client's <code>config</code> folder and rename it to <code>wg0.conf</code>.</p> <p>Edit your Home Wireguard Client's <code>wg0.conf</code>, remove the <code>DNS</code> line and add the <code>PersistentKeepalive = 25</code> line under <code>Peer</code>, it should look like this: <pre><code>[Interface]\nAddress = 10.13.13.2\nPrivateKey = &lt;private-key&gt;\nListenPort = 51820\n\n[Peer]\nPublicKey = &lt;public-key&gt;\nEndpoint = &lt;domain&gt;:51820\nAllowedIPs = 10.13.13.0/24\nPersistentKeepalive = 25\n</code></pre> Save the changes and restart the container on your Home server with <code>docker restart wireguard</code>, validate that <code>docker logs wireguard</code> contains no errors.</p> <p>Validate that the tunnel is working by pinging both sides:</p> <ul> <li>On the Home server run - <code>docker exec wireguard ping 10.13.13.1</code></li> <li>On the VPS run - <code>docker exec wireguard ping 10.13.13.2</code></li> </ul>","tags":["Containers"]},{"location":"Containers/vps-proxy/#configuring-the-vps-swag-to-use-the-tunnel","title":"Configuring the VPS SWAG to Use the Tunnel","text":"<p>Replace the following lines on the VPS SWAG container:</p> <pre><code>    ports:\n      - 443:443\n      - 80:80\n</code></pre> <p>With:</p> <pre><code>    network_mode: \"service:wireguard\"\n    depends_on:\n      - wireguard\n</code></pre> <p>Add the ports under the VPS Wireguard Server container:</p> <pre><code>    ports:\n      - 80:80\n      - 443:443\n      - 51820:51820/udp\n</code></pre> <p>Add the following to the bottom of the VPS SWAG configuration under <code>config/nginx/site-confs/default</code>:</p> <pre><code>server {\n    listen 443 ssl;\n    server_name *.external.com;\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location / {\n        include /config/nginx/proxy.conf;\n        resolver 127.0.0.11 valid=30s;\n        proxy_pass http://10.13.13.2:8080;\n    }\n}\n</code></pre> <p>Recreate the VPS Wireguard Server container to apply the changes, then recreate the VPS SWAG container which depends on the tunnel.</p>","tags":["Containers"]},{"location":"Containers/vps-proxy/#configuring-the-home-swag-to-use-the-tunnel","title":"Configuring the Home SWAG to Use the Tunnel","text":"<p>Replace the following lines on the Home SWAG container:</p> <pre><code>    ports:\n      - 443:443\n      - 80:80\n</code></pre> <p>With:</p> <pre><code>    network_mode: \"service:wireguard\"\n    depends_on:\n      - wireguard\n</code></pre> <p>Add the ports under the Home Wireguard Client container:</p> <pre><code>    ports:\n      - 80:80\n      - 443:443\n      - 51820:51820/udp\n</code></pre> <p>Configure the Home SWAG to see the real IP of connections coming from the tunnel by adding the following inside the <code>http</code> section in <code>config/nginx/nginx.conf</code>:</p> <pre><code>    set_real_ip_from 10.13.13.1/32;\n    real_ip_header X-Forwarded-For;\n</code></pre> <p>In order to catch all the unused subdomains and redirect to an error page, add <code>listen 8080 default_server;</code> to <code>config/nginx/site-confs/default</code> under the main server block:</p> <pre><code># main server block\nserver {\n    listen 8080 default_server;\n    listen 443 ssl http2 default_server;\n</code></pre> <p>Expose a container through the tunnel by adding <code>listen 8080;</code> to it's proxy configuration, for example:</p> <pre><code>server {\n    listen 8080;\n    listen 443 ssl;\n    server_name heimdall.*;\n    include /config/nginx/ssl.conf;\n    client_max_body_size 0;\n\n    location / {\n        include /config/nginx/proxy.conf;\n        resolver 127.0.0.11 valid=30s;\n        set $upstream_app heimdall;\n        set $upstream_port 443;\n        set $upstream_proto https;\n        proxy_pass $upstream_proto://$upstream_app:$upstream_port;\n\n    }\n}\n</code></pre> <p>Recreate the Home Wireguard Client container to apply the changes, then recreate the Home SWAG container which depends on the tunnel.</p> <p>Validate that the containers you exposed now work through the tunnel by browsing <code>https://&lt;container&gt;.external.com/</code>.</p>","tags":["Containers"]},{"location":"Containers/vps-proxy/#traffic-overview","title":"Traffic Overview","text":"","tags":["Containers"]},{"location":"Containers/vps-proxy/#fail2ban","title":"Fail2ban","text":"<p>Now that everything is working, Fail2ban should ban the right IP of attackers, but they're coming in through the tunnel and iptables isn't blocking them, therefore we will block them through NGINX.</p> <p>Create a file called <code>nginx.conf</code> in your Home SWAG under <code>config/fail2ban/action.d/</code> with the following:</p> <pre><code>[INCLUDES]\n\n[Definition]\n\nactionstart = touch /config/nginx/blocklist.conf\nactionstop = \nactioncheck = \nactionban = grep -qxF \"deny &lt;ip&gt;;\" /config/nginx/blocklist.conf || echo \"deny &lt;ip&gt;;\" &gt;&gt; /config/nginx/blocklist.conf &amp;&amp; /bin/s6-svc -r /var/run/s6/services/nginx\nactionunban = sed -i '/deny &lt;ip&gt;;/d' /config/nginx/blocklist.conf &amp;&amp; /bin/s6-svc -r /var/run/s6/services/nginx\n\n[Init]\n\nname = default\n</code></pre> <p>Edit <code>config/fail2ban/jail.local</code> and add <code>nginx</code> to the <code>action</code> of all the jails, for example:</p> <pre><code>[authelia]\nenabled  = true\nfilter   = authelia\nport     = http,https\nlogpath  = /authelia/authelia.log\naction  = iptables-allports[name=authelia]\n          nginx\n</code></pre> <p>Add the following line into the <code>http</code> section in <code>config/nginx/nginx.conf</code>:</p> <pre><code>    include /config/nginx/blocklist.conf;\n</code></pre> <p>Restart the Home SWAG to apply the changes with <code>docker restart swag</code>.</p>","tags":["Containers"]},{"location":"Containers/vps-proxy/#notes","title":"Notes","text":"","tags":["Containers"]},{"location":"Containers/vps-proxy/#exposing-more-containers","title":"Exposing more containers","text":"<p>Expose more containers by simply adding <code>listen 8080;</code> to their proxy configuration on the Home server, for example:</p> <pre><code>server {\n    listen 8080;\n    listen 443 ssl;\n</code></pre> <p>Restart Home SWAG by running <code>docker restart swag</code> to apply the changes.</p>","tags":["Containers"]},{"location":"Containers/vps-proxy/#restarting-order","title":"Restarting order","text":"<p>If you're experiencing problems and you want to restart everything, the correct order is:</p> <ul> <li>VPS - <code>docker restart wireguard</code></li> <li>VPS - <code>docker restart swag</code></li> <li>Home - <code>docker restart wireguard</code></li> <li>Home - <code>docker restart swag</code></li> </ul>","tags":["Containers"]},{"location":"Containers/vps-proxy/#authelia-authentik","title":"Authelia / Authentik","text":"<p>If you expose Authelia/Authentik through the tunnel, you need to make a small adjustment for the redirects to work.</p> <p>The idea is to force https, since traffic through the tunnel is coming over as http but the VPS exposes https.</p> <p>Edit Authelia/Authentik confs under <code>config/nginx/</code>, replace <code>$scheme</code> with <code>https</code>.</p> <p>Restart the Home SWAG to apply the changes with <code>docker restart swag</code>.</p>","tags":["Containers"]},{"location":"Containers/vps-proxy/#exposing-a-resource-only-through-one-domain-but-not-the-other","title":"Exposing a resource only through one domain but not the other","text":"<p>You control what gets exposed where in 2 ways:</p> <ul> <li>Through the <code>listen &lt;port&gt;;</code> setting, 8080 is through the VPS and 443/80 is directly.</li> <li>Through the <code>server_name something.external.com</code> setting, if you explicitely specify the full address.</li> </ul> <p>If a resource isn't exposed, the default action under the main server block in your Home SWAG will apply.</p>","tags":["Containers"]},{"location":"Containers/vps-proxy/#attackers-are-filling-my-logs-with-access-denied","title":"Attackers are filling my logs with Access Denied!","text":"<p>If you want attackers to be redirected instead of showing them an error page and avoid them spamming the logs with 403 errors, add the following inside the <code>http</code> section in <code>config/nginx/nginx.conf</code> on both SWAGs:</p> <pre><code>    error_page 400 403 404 444 500 502 503 504 http://www.google.com/;\n</code></pre> <p>Restart the Home SWAG to apply the changes with <code>docker restart swag</code>.</p>","tags":["Containers"]},{"location":"Containers/wireguard-hub/","title":"Wireguard Hub","text":"<p>Linuxserver's Wireguard container is extremely versatile, in this example we'll use it as a server that tunnels clients through multiple redundant vpn connections while maintaining access to the LAN.</p> <p>VPN providers have a limit on the amount of devices, this setup will allow you to have an unlimited amount of devices tunneled through a single VPN connection while also supporting a failover backup connection!</p> <p>Objectives:</p> <ul> <li>Implement in a single wireguard server container.</li> <li>Allow unlimited clients to connect to the wireguard server container and utilize the same VPN connection.</li> <li>Support a fallback VPN connection for increased reliability.</li> <li>Support accessing LAN devices over wireguard.</li> <li>Support excluding domains that block VPNs.</li> <li>Support tunneling other containers through the same VPN connection.</li> <li>Support tunneling entire VLANs and hosts through the same VPN connection.</li> </ul>","tags":["Containers"]},{"location":"Containers/wireguard-hub/#instructions","title":"Instructions","text":"<p>Clone the following boilerplate:</p> <pre><code>git clone https://github.com/quietsy/wireguard-hub.git\n</code></pre>","tags":["Containers"]},{"location":"Containers/wireguard-hub/#server-template","title":"Server Template","text":"<p>Replace <code>CHANGETHIS</code> with your LAN subnet under <code>wireguard/templates/server.conf</code>.</p>","tags":["Containers"]},{"location":"Containers/wireguard-hub/#client-tunnels","title":"Client Tunnels","text":"<ul> <li>Obtain 2 wireguard vpn configurations from your vpn provider (mullvad and torguard have been tested).</li> <li>Replace <code>CHANGETHIS</code> with your vpn configurations under:<ul> <li><code>wireguard/wg_confs/wg1.conf</code></li> <li><code>wireguard/wg_confs/wg2.conf</code></li> </ul> </li> </ul>","tags":["Containers"]},{"location":"Containers/wireguard-hub/#wireguard-server-container","title":"Wireguard Server Container","text":"<p>Configure a Wireguard server container according to the Wireguard documentation with the <code>wireguard</code> folder of the boilerplate mounted to <code>/config</code>.</p> <pre><code>services:\n  wireguard:\n    image: lscr.io/linuxserver/wireguard:latest\n    container_name: wireguard\n    cap_add:\n      - NET_ADMIN\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=Etc/UTC\n      - SERVERURL=wireguard.domain.com\n      - SERVERPORT=51820\n      - PEERS=1\n      - PEERDNS=auto\n      - INTERNAL_SUBNET=10.13.13.0\n      - ALLOWEDIPS=0.0.0.0/0\n      - LOG_CONFS=true\n      - DOCKER_MODS=linuxserver/mods:universal-package-install\n      - INSTALL_PACKAGES=ipset\n    volumes:\n      - ./wireguard:/config\n    ports:\n      - 51820:51820/udp\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1\n    restart: unless-stopped\n</code></pre> <p>Create the container and perform the following checks to verify that the VPN tunnels works:</p> <ul> <li>Check that <code>docker logs wireguard</code> contains no errors, and check that the server is working properly by connecting a client to it.</li> <li>Check that you have connectivity on wg1 by running <code>docker exec wireguard ping -c4 -I wg1 1.1.1.1</code>.</li> <li>Check that you have connectivity on wg2 by running <code>docker exec wireguard ping -c4 -I wg2 1.1.1.1</code>.</li> <li>Check the details of your VPN tunnel on wg1 by running <code>docker exec wireguard curl --interface wg1 -s https://am.i.mullvad.net/json</code>, you should get an IP that is different from your WAN IP.</li> <li>Check the details of your VPN tunnel on wg2 by running <code>docker exec wireguard curl --interface wg2 -s https://am.i.mullvad.net/json</code>, you should get an IP that is different from your WAN IP.</li> <li>Connect to the tunnel with a client device and navigate to <code>https://am.i.mullvad.net/json</code>, verify that the server is working properly and that you're tunneled through one the VPN tunnels.</li> </ul>","tags":["Containers"]},{"location":"Containers/wireguard-hub/#bypassing-the-vpn-for-specific-sites-optional","title":"Bypassing the VPN for specific sites (optional)","text":"","tags":["Containers"]},{"location":"Containers/wireguard-hub/#manual","title":"Manual","text":"<p>Add domains that would bypass the VPN to <code>wireguard/unblock/domains.txt</code>.</p>","tags":["Containers"]},{"location":"Containers/wireguard-hub/#web-ui","title":"Web-UI","text":"<p>There's a basic web-ui for adding sites to the file under <code>wireguard/unblock/index.php</code>.</p> <p>You can host it on SWAG by adding the following mounts to SWAG's compose:</p> <pre><code>    volumes:\n      - ./wireguard/unblock:/config/unblock\n      - ./wireguard/unblock/unblock.subdomain.conf:/config/nginx/proxy-confs/unblock.subdomain.conf:ro\n</code></pre> <p>Recreate SWAG and navigate to <code>https://unblock.domain.com</code>, test that it adds domains to <code>wireguard/unblock/domains.txt</code>.</p>","tags":["Containers"]},{"location":"Containers/wireguard-hub/#routing-other-containers-through-the-tunnel-optional","title":"Routing other containers through the tunnel (optional)","text":"<p>Other containers can be routed through the hub by adding another wireguard container in client mode.</p>","tags":["Containers"]},{"location":"Containers/wireguard-hub/#wireguard-client-container","title":"Wireguard Client Container","text":"<ul> <li>Add a new peer to the wireguard server container using the <code>PEERS</code> environment variable, and recreate it.</li> <li>Create another wireguard container, this time in client mode, according to the VPN Route guide.</li> <li>Copy the peer's <code>./wireguard/peer#/peer#.conf</code> from the server to the client's <code>./wgclient/wg_confs/wg0.conf</code>.</li> <li>Set the <code>Endpoint</code> to be the server container: <code>Endpoint = wireguard:51820</code>.</li> <li>Add <code>PostUp</code> and <code>PreDown</code> rules according to the VPN Route guide.</li> <li>Create the container for changes to take effect.</li> </ul>","tags":["Containers"]},{"location":"Containers/wireguard-hub/#port-forwarding-optional","title":"Port forwarding (optional)","text":"<ul> <li>Uncomment the port forwarding <code>PostUp</code> and <code>PreDown</code> rules in <code>wg1.conf</code> and <code>wg2.conf</code>.</li> <li>Replace <code>10.13.13.2</code> with the wireguard client peer IP.</li> <li>Replace <code>45678</code> with the port of the app.</li> <li>Replace <code>12345</code> with the port you got from the vpn provider for each tunnel.</li> <li>Duplicate the rules for udp if needed.</li> <li>Restart the container for changes to take effect.</li> </ul>","tags":["Containers"]},{"location":"Containers/wireguard-hub/#routing-on-opnsense-optional","title":"Routing on OPNSense (optional)","text":"<p>VLANs and hosts can be routed through the hub via OPNSense.</p> <ul> <li>Add a new peer to the wireguard server container using the <code>PEERS</code> environment variable, and recreate it.</li> <li>Follow https://docs.opnsense.org/manual/how-tos/wireguard-selective-routing.html.</li> </ul> <p>Step 1:</p> <ul> <li>Set <code>Public Key</code> to the server's public key from <code>./wireguard/server/publickey-server</code>.</li> <li>Set <code>Allowed IPs</code> to <code>0.0.0.0/0</code>.</li> <li>Set <code>Endpoint Address</code> to the server's LAN IP.</li> <li>Set <code>Endpoint Port</code> to <code>51820</code>.</li> <li>Set <code>Keepalive</code> to <code>25</code>.</li> </ul> <p>Step 2:</p> <ul> <li>Set <code>Public Key</code> to the peer's public key from <code>./wireguard/peer#/publickey-peer#</code>.</li> <li>Set <code>Private Key</code> to the peer's public key from <code>./wireguard/peer#/privatekey-peer#</code>.</li> <li>Set <code>Listen Port</code> to <code>51820</code>.</li> <li>Set <code>Tunnel Address</code> to the peer's address as listed under<code>[interface]</code> in <code>./wireguard/peer#/peer#.conf</code>.</li> <li>Select your peer under <code>Peers</code>.</li> <li>Check <code>Disable Routes</code>.</li> <li>Set <code>Gateway</code> to <code>10.13.13.200</code>.</li> </ul> <p>Follow the rest of the guide.</p>","tags":["Containers"]},{"location":"Containers/wireguard-hub/#traffic-overview","title":"Traffic Overview","text":"<p>The order of traffic is as follows:</p> <ol> <li>Localhost - traffic to the container.</li> <li>Local network - traffic the DNS and gateway.</li> <li>Wireguard clients - traffic to the wireguard clients.</li> <li>Excluded domains - bypasses the VPN and routes directly.</li> <li>Main VPN tunnel - the VPN tunnel in <code>wg1.conf</code>.</li> <li>Failover VPN tunnel - the VPN tunnel in <code>wg2.conf</code>.</li> </ol>","tags":["Containers"]},{"location":"Containers/yaml-anchors/","title":"YAML Anchors","text":"<p>Using YAML anchors is a great way to reduce configuration duplication and be able to add configuration to all containers in a single place.</p>","tags":["Containers"]},{"location":"Containers/yaml-anchors/#basic","title":"Basic","text":"<p>You want all containers to have the same restart policy and the same memory limit of 2GB:</p> <pre><code>version: \"3.9\"\n\nx-base: &amp;base\n  mem_limit: 2000m\n  restart: always\n\nservices:\n  radarr:\n    &lt;&lt;: *base\n    image: lscr.io/linuxserver/radarr\n    container_name: radarr\n    volumes:\n      - ${APPSDIR}/radarr:/config\n      - ${DATADIR}/media:/media\n  sonarr:\n    &lt;&lt;: *base\n    image: lscr.io/linuxserver/sonarr\n    container_name: sonarr\n    volumes:\n      - ${APPSDIR}/sonarr:/config\n      - ${DATADIR}/media:/media\n</code></pre> <p>Every container with <code>&lt;&lt;: *base</code> will include everything listed under <code>x-base</code>, and changes to it will affect all containers.</p>","tags":["Containers"]},{"location":"Containers/yaml-anchors/#advanced","title":"Advanced","text":"<p>You have a few common templates, and you want to be able to use all of them:</p> <ul> <li><code>base</code> - The base of containers, you can safely assume that changes to it will affect all containers.</li> <li><code>internalbase</code> - The base + associating with the internal docker network.</li> <li><code>vpnbase</code> - The base + associating with the VPN network.</li> <li><code>lsio</code> - Common environment variables in all LSIO containers.</li> <li><code>lsiobase</code> - The base + associating with the internal docker network + LSIO variables.</li> <li><code>vpnlsiobase</code> - The base + associating with the VPN network + LSIO variables.</li> </ul> <pre><code>version: \"3.9\"\n\nx-base: &amp;base\n  mem_limit: 2000m\n  restart: always \nx-internalbase: &amp;internalbase\n  &lt;&lt;: *base\n  networks:\n    - internal\nx-vpnbase: &amp;vpnbase\n  &lt;&lt;: *base\n  network_mode: \"service:vpn\"\nx-lsio: &amp;lsio\n  PUID: ${PUID}\n  PGID: ${PGID}\n  TZ: ${TZ}\nx-lsiobase: &amp;lsiobase\n  &lt;&lt;: *internalbase\n  environment:\n    &lt;&lt;: *lsio\nx-vpnlsiobase: &amp;vpnlsiobase\n  &lt;&lt;: *vpnbase\n  environment:\n    &lt;&lt;: *lsio\n\nservices:\n  radarr:\n    &lt;&lt;: *lsiobase\n    image: lscr.io/linuxserver/radarr\n    container_name: radarr\n    volumes:\n      - ${APPSDIR}/radarr:/config\n      - ${DATADIR}/media:/media\n  sonarr:\n    &lt;&lt;: *lsiobase\n    image: lscr.io/linuxserver/sonarr\n    container_name: sonarr\n    volumes:\n      - ${APPSDIR}/sonarr:/config\n      - ${DATADIR}/media:/media\n  lidarr:\n    &lt;&lt;: *vpnlsiobase\n    image: lscr.io/linuxserver/lidarr:nightly\n    container_name: lidarr\n    volumes:\n      - ${APPSDIR}/lidarr:/config\n      - ${DATADIR}/media:/media\n  prowlarr:\n    &lt;&lt;: *vpnlsiobase\n    image: lscr.io/linuxserver/prowlarr:nightly-alpine\n    container_name: prowlarr\n    volumes:\n      - ${APPSDIR}/prowlarr:/config\n  ombi:\n    &lt;&lt;: *vpnlsiobase\n    image: lscr.io/linuxserver/ombi:development\n    container_name: ombi\n    volumes:\n      - ${APPSDIR}/ombi4:/config\n  collabora:\n    &lt;&lt;: *internalbase\n    image: collabora/code\n    container_name: collabora\n    environment:\n      domain: ${CLBDOMAIN}\n      dictionaries: en_US\n</code></pre> <p>We easily associated 2 containers with <code>lsiobase</code>, 3 with <code>vpnlsiobase</code>, and 1 with <code>internalbase</code>.</p>","tags":["Containers"]},{"location":"Containers/yaml-anchors/#overriding-anchors","title":"Overriding Anchors","text":"<p>There may be a need to add environment variables beyond the ones defined in the base anchor, unfortunately when declaring the same section again it will override the base, not append to it. Instead, you need to make a separate anchor for the environment variables and use it directly.</p> <p>For example:</p> <pre><code>x-base: &amp;base\n  mem_limit: 2000m\n  restart: always \nx-internalbase: &amp;internalbase\n  &lt;&lt;: *base\n  networks:\n    - internal\nx-lsio: &amp;lsio\n  PUID: ${PUID}\n  PGID: ${PGID}\n  TZ: ${TZ}\nx-lsiobase: &amp;lsiobase\n  &lt;&lt;: *internalbase\n  environment:\n    &lt;&lt;: *lsio\n\nservices:\n  mariadb:\n    &lt;&lt;: *internalbase\n    image: lscr.io/linuxserver/mariadb\n    container_name: mariadb\n    environment:\n      &lt;&lt;: *lsio\n      MYSQL_DIR: /config\n      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}\n    volumes:\n      - ${APPSDIR}/mariadb:/config\n</code></pre>","tags":["Containers"]},{"location":"Network/asus-vlans/","title":"Asus VLANs","text":"","tags":["Network"]},{"location":"Network/asus-vlans/#reasons-for-using-an-asus-router","title":"Reasons for using an Asus router","text":"<ul> <li>Not cloud connected</li> <li>Doesn't require a controller</li> <li>Supports mesh, wpa3</li> <li>Cheap for a 2x2 Wi-Fi 6 AP with 5 LAN ports and VLAN support</li> <li>Can act as a backup router if needed</li> <li>Has a great community around it with asus-merlin</li> </ul>","tags":["Network"]},{"location":"Network/asus-vlans/#steps","title":"Steps","text":"<p>Tested on the Asus RT-AX58U but could work on any asus-merlin router.</p> <ul> <li>Install Asus-Merlin on the router</li> <li>Set the router to AP mode</li> <li>Enable Administration &gt; System &gt; Enable JFFS custom scripts and configs</li> <li>Set the router to a static IP instead of DHCP</li> <li>Create all needed guest networks, in this example there will be Guest 2.5Ghz and Guest 5Ghz</li> <li>Save the script to <code>/jffs/scripts/services-start</code> after it's done</li> <li>Set <code>chmod a+x /jffs/scripts/services-start</code></li> <li>Reboot the router to apply changes</li> </ul>","tags":["Network"]},{"location":"Network/asus-vlans/#discovery","title":"Discovery","text":"<p>Before editing the script we need to figure out the interface names, disconnect all ethernet cables except one and run <code>ip a</code> to check which interface is UP, keep switching between ports and running  <code>ip a</code> to map all ports.</p> <p>For example:</p> <ul> <li>eth0 - LAN 1</li> <li>eth1 - LAN 2</li> <li>eth2 - LAN 3</li> <li>eth3 - LAN 4</li> <li>eth4 - WAN</li> <li>eth5 - Main wifi 2.4Ghz</li> <li>eth6 - Main wifi 5Ghz</li> <li>wl0.1 - Guest wifi 2.4Ghz</li> <li>wl1.1 - Guest wifi 5Ghz</li> </ul>","tags":["Network"]},{"location":"Network/asus-vlans/#script","title":"Script","text":"<p>The following script assumes the layout above and creates 2 VLANs:</p> <ol> <li>227 - LAN ports 1-4, Main wifi 2.5Ghz, Main wifi 5Ghz</li> <li>11 (with client isolation) - Guest wifi 2.5Ghz, Guest wifi 5Ghz</li> </ol> <p>Change the script according to your router model's layout and needs.</p> <pre><code>#!/bin/sh\n\nbrctl delif br0 eth4\nbrctl delif br0 wl0.1\nbrctl delif br0 wl1.1\nip link add link eth4 name eth4.227 type vlan id 227\nip link add link eth4 name eth4.11 type vlan id 11\nip link set eth4.227 up\nip link set eth4.11 up\nbrctl addif br0 eth4.227\nbrctl addbr br1\nbrctl addif br1 eth4.11\nbrctl addif br1 wl0.1\nbrctl addif br1 wl1.1\nip link set br1 up\nnvram set lan_ifnames=\"eth0 eth1 eth2 eth3 eth5 eth6 eth4.227\"\nnvram set lan1_ifnames=\"wl0.1 wl1.1 eth4.11\"\nnvram set lan1_ifname=\"br1\"\nnvram set br0_ifnames=\"eth0 eth1 eth2 eth3 eth5 eth6 eth4.227\"\nnvram set br1_ifnames=\"wl0.1 wl1.1 eth4.11\"\nnvram set br1_ifname=\"br1\"\nnvram set wl0.1_ap_isolate=\"1\"\nnvram set wl1.1_ap_isolate=\"1\"\nkillall eapd\neapd\nethswctl -c hw-switching -o disable\n</code></pre>","tags":["Network"]},{"location":"Network/asus-vlans/#recovery","title":"Recovery","text":"<p>If the router doesn't boot after making the changes, you can revert it to factory defaults on most models by following these steps:</p> <ol> <li>Power off the router</li> <li>Hold the WDS button on the back</li> <li>Turn the router on while still holding the WDS button</li> <li>Wait for the power led to turn off</li> <li>Reboot the router normally</li> </ol>","tags":["Network"]},{"location":"Network/firehol/","title":"Firehol","text":"<p>Firehol blocklists are a collection of automatically updating ipsets from all available security IP Feeds, mainly related to on-line attacks, on-line service abuse, malwares, botnets, command and control servers and other cybercrime activities.</p>","tags":["Network"]},{"location":"Network/firehol/#vps","title":"VPS","text":"","tags":["Network"]},{"location":"Network/firehol/#installation","title":"Installation","text":"<p>Install the following packages:</p> <pre><code>sudo apt install ipset iprange\n</code></pre>","tags":["Network"]},{"location":"Network/firehol/#firehol-blocklists","title":"Firehol Blocklists","text":"<p>Navigate to Firehol's website or Firehol's github repo and choose which blocklists you want to enable.</p> <p>Copy the raw links into <code>/home/user/firehol/firehol.conf</code>. For example:</p> <pre><code>https://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level1.netset\nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level2.netset\nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level3.netset\nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_abusers_1d.netset\n</code></pre>","tags":["Network"]},{"location":"Network/firehol/#firehol-script","title":"Firehol Script","text":"<p>Create a script to refresh the firehol ipsets and recreate the iptables rules.</p> <p>For example <code>/home/user/firehol/firehol.sh</code>:</p> <pre><code>#!/bin/bash\n\nLOG=\"/home/user/firehol/firehol.log\"\nURLS=$(cat \"/home/user/firehol/firehol.conf\")\necho \"Updating Firehol $(date)\" &gt;&gt; $LOG\n\niptables -D INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT &gt; /dev/null 2&gt;&amp;1\niptables -D DOCKER-USER -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT &gt; /dev/null 2&gt;&amp;1\niptables -D FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT &gt; /dev/null 2&gt;&amp;1\niptables -I FORWARD 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT &gt;&gt; $LOG\niptables -I INPUT 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT &gt;&gt; $LOG\niptables -I DOCKER-USER 1 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT &gt;&gt; $LOG\n\nfor URL in $URLS\ndo\n    echo $URL &gt;&gt; $LOG\n    NAME=$(basename $URL)\n    echo $NAME &gt;&gt; $LOG\n    FILE=\"/home/user/firehol/$NAME\"\n    curl -s -k $URL &gt; $FILE\n    # The following sed removes LAN ranges from the lists otherwise you might block yourself\n    sed -i -e 's#10.0.0.0/8##' -e 's#172.16.0.0/12##' -e 's#192.168.0.0/16##' -e 's#127.0.0.0/8##' $FILE\n    COUNT=$(/usr/bin/iprange -C $FILE)\n    COUNT=${COUNT/*,/}\n    echo $COUNT &gt;&gt; $LOG\n    /usr/sbin/ipset create --exist $NAME hash:net family inet maxelem 131072 &gt;&gt; $LOG\n    /usr/sbin/ipset flush $NAME &gt; /dev/null 2&gt;&amp;1\n    /usr/bin/iprange $FILE --ipset-reduce 20 --ipset-reduce-entries 65535 --print-prefix \"-A $NAME \" &gt; $FILE.ipset\n    /usr/sbin/ipset restore --exist --file $FILE.ipset &gt;&gt; $LOG\n    /usr/sbin/iptables -D FORWARD -m set --match-set $NAME src -j DROP &amp;&gt;/dev/null\n    /usr/sbin/iptables -D INPUT -m set --match-set $NAME src -j DROP &amp;&gt;/dev/null\n    /usr/sbin/iptables -D DOCKER-USER -m set --match-set $NAME src -j DROP &amp;&gt;/dev/null\n    /usr/sbin/iptables -I DOCKER-USER 2 -m set --match-set $NAME src -j DROP &gt;&gt; $LOG\n    /usr/sbin/iptables -I INPUT 2 -m set --match-set $NAME src -j DROP &gt;&gt; $LOG\n    /usr/sbin/iptables -I FORWARD 2 -m set --match-set $NAME src -j DROP &gt;&gt; $LOG\ndone\n</code></pre> <p>Verify that it works and the ipsets have been filled:</p> <pre><code>chmod +x /home/user/firehol/firehol.sh\nsudo /home/user/firehol/firehol.sh\nsudo ipset list firehol_level1.netset\n</code></pre>","tags":["Network"]},{"location":"Network/firehol/#cron-scheduling","title":"Cron Scheduling","text":"","tags":["Network"]},{"location":"Network/firehol/#warning-make-sure-youre-not-accidentally-blocking-your-own-access-to-the-vps-before-proceeding","title":"Warning - make sure you're not accidentally blocking your own access to the VPS before proceeding.","text":"<p>Run the firehol script on reboot and daily.</p> <p>For example, add the following to <code>sudo crontab -e</code>:</p> <pre><code>0 1 * * * /home/user/firehol/firehol.sh\n@reboot sleep 120 &amp;&amp; /home/user/firehol/firehol.sh\n</code></pre> <p>Verify that it runs on reboot and daily. There's a 2 minute delay before it applies after reboots, to give you enough time to fix a lockout.</p>","tags":["Network"]},{"location":"Network/firehol/#opnsense","title":"OPNSense","text":"","tags":["Network"]},{"location":"Network/firehol/#alias","title":"Alias","text":"<p>Navigate to Firewall &gt; Aliases and create the following aliases:</p> <pre><code>Name: Firehol\nType: URL IPs\nContent: \nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level1.netset\nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level2.netset\nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level3.netset\nhttps://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_abusers_1d.netset\n</code></pre> <pre><code>Name: External\nType: Networks\nContent: !10.0.0.0/8, !172.16.0.0/12, !192.168.0.0/16, !127.0.0.1\n</code></pre> <pre><code>Name: Firehol_without_internal\nType: Network group\nContent: External, Firehol\n</code></pre>","tags":["Network"]},{"location":"Network/firehol/#firewall","title":"Firewall","text":"<p>Navigate to Firewall &gt; Rules &gt; WAN and create the following firewall rule:</p> <pre><code>Action: Block\nInterface: WAN\nDirection: in\nTCP/IP Version: IPv4\nProtocol: any\nSource: Firehol_without_internal\nDestination: any\n</code></pre>","tags":["Network"]},{"location":"Network/firehol/#cron","title":"Cron","text":"<p>Create a cron job to automatically update the blocklists every day.</p> <p>Navigate to System &gt; Settings &gt; Cron and add the following job:</p> <pre><code>Eabled: checked\nMinutes: 0\nHours: 0\nDay of the month: *\nMonths: *\nDays of the week: *\nCommand: Update and reload firewall aliases\n</code></pre>","tags":["Network"]},{"location":"Network/geoblock/","title":"Geoblock","text":"","tags":["Network"]},{"location":"Network/geoblock/#vps","title":"VPS","text":"<p>I've been dealing with constant attacks on a mail server on a VPS coming from 2 specific countries, the only solution that worked was completely blocking these countries.</p> <p>There are 2 popular geoblock providers, Maxmind and DP-IP, we can utilize them using a python library called geoipsets.</p>","tags":["Network"]},{"location":"Network/geoblock/#installation","title":"Installation","text":"<p>Install the following packages:</p> <pre><code>sudo apt install python3 python3.12 python3-pip python3-venv ipset\n</code></pre> <p>Create a python virtual environment:</p> <pre><code>python3 -m venv .venv\n</code></pre> <p>Verify that it works:</p> <pre><code>source .venv/bin/activate\n</code></pre>","tags":["Network"]},{"location":"Network/geoblock/#geoblock-config","title":"Geoblock Config","text":"<p>Create a geoblock config according to the geoipsets documentation.</p> <p>For example <code>/home/user/geoipsets.conf</code>:</p> <pre><code>[general]\nprovider=dbip\nfirewall=iptables\naddress-family=ipv4,ipv6\n\n[countries]\nRU\nCN\n</code></pre> <p>Verify that it works:</p> <pre><code>source .venv/bin/activate\ngeoipsets -o /home/user -c /home/user/geoipsets.conf\n</code></pre>","tags":["Network"]},{"location":"Network/geoblock/#geoblock-script","title":"Geoblock Script","text":"<p>Create a script to refresh the geoblock ipsets and recreate the iptables rules.</p> <p>For example <code>/home/user/geoblock.sh</code>:</p> <pre><code>#!/bin/bash\n\noutput_path=\"/home/user\"\nvenv_path=\"/home/user/.venv/bin/activate\"\nconfig_path=\"/home/user/geoipsets.conf\"\nlog=\"/home/user/geoblock.log\"\n\necho \"Updating Blocklist $(date)\" &gt;&gt; $log\nsource $venv_path\ngeoipsets -o $output_path -c $config_path &gt;&gt; $log\n\nfor i in $(find \"${output_path}/geoipsets\" -name \"*.ipv*\");\ndo\n    name=$(basename $i)\n    echo $name &gt;&gt; $log\n    /usr/sbin/ipset flush $name &gt;&gt; $log\n    /usr/sbin/ipset restore --exist --file $i &gt;&gt; $log\n    command=$(if [[ $name == *ipv4 ]]; then echo \"/usr/sbin/iptables\"; else echo \"/usr/sbin/ip6tables\"; fi)\n    $command -D FORWARD -m set --match-set $name src -j DROP &amp;&gt;/dev/null\n    $command -D INPUT -m set --match-set $name src -j DROP &amp;&gt;/dev/null\n    $command -D DOCKER-USER -m set --match-set $name src -j DROP &amp;&gt;/dev/null\n    $command -I DOCKER-USER 1 -m set --match-set $name src -j DROP &gt;&gt; $log\n    $command -I INPUT 1 -m set --match-set $name src -j DROP &gt;&gt; $log\n    $command -I FORWARD 1 -m set --match-set $name src -j DROP &gt;&gt; $log\ndone\n</code></pre> <p>Verify that it works and the ipsets have been filled:</p> <pre><code>chmod +x /home/user/geoblock.sh\nsudo /home/user/geoblock.sh\nsudo ipset list RU.ipv4\n</code></pre>","tags":["Network"]},{"location":"Network/geoblock/#cron-scheduling","title":"Cron Scheduling","text":"","tags":["Network"]},{"location":"Network/geoblock/#warning-make-sure-youre-not-accidentally-blocking-your-own-access-to-the-vps-before-proceeding","title":"Warning - make sure you're not accidentally blocking your own access to the VPS before proceeding.","text":"<p>Run the geoblock script on reboot and weekly.</p> <p>For example, add the following to <code>sudo crontab -e</code>:</p> <pre><code>20 0 * * 2 /home/user/geoblock.sh\n@reboot sleep 120 &amp;&amp; /home/user/geoblock.sh\n</code></pre> <p>Verify that it runs on reboot and weekly. There's a 2 minute delay before it applies after reboots, to give you enough time to fix a lockout.</p>","tags":["Network"]},{"location":"Network/geoblock/#opnsense","title":"OPNSense","text":"","tags":["Network"]},{"location":"Network/geoblock/#alias","title":"Alias","text":"<p>Navigate to Firewall &gt; Aliases &gt; GeoIP settings and add a link to a geoblock database with your license key:</p> <pre><code>https://download.maxmind.com/app/geoip_download?edition_id=GeoLite2-Country-CSV&amp;license_key=your-license-key&amp;suffix=zip\n</code></pre> <p>Navigate to Firewall &gt; Aliases and create aliases with the countries you want to block or whitelist a specific country:</p> <pre><code>Name: Geoblock\nType: GeoIP (IPv4, IPv6)\nContent: Select all the countries you want to block\n</code></pre> <pre><code>Name: UK\nType: GeoIP (IPv4, IPv6)\nContent: Select UK\n</code></pre>","tags":["Network"]},{"location":"Network/geoblock/#firewall","title":"Firewall","text":"<p>Navigate to Firewall &gt; Rules &gt; WAN and create firewall rules:</p> <pre><code>Action: Block\nInterface: WAN\nDirection: in\nTCP/IP Version: IPv4+IPv6\nProtocol: any\nSource: Geoblock\nDestination: any\nDescription: Blocks specific countries\n</code></pre> <pre><code>Action: Pass\nInterface: WAN\nDirection: in\nTCP/IP Version: IPv4+IPv6\nProtocol: TCP\nSource: UK\nDestination: WAN address\nDestination port range: 443\nDescription: Whitelist UK on port 443\n</code></pre>","tags":["Network"]},{"location":"Network/geoblock/#cron","title":"Cron","text":"<p>Create a cron job to automatically update the blocklists every day.</p> <p>Navigate to System &gt; Settings &gt; Cron and add the following job:</p> <pre><code>Eabled: checked\nMinutes: 0\nHours: 0\nDay of the month: *\nMonths: *\nDays of the week: *\nCommand: Update and reload firewall aliases\n</code></pre>","tags":["Network"]},{"location":"Network/hardcoded-dns/","title":"Hardcoded DNS","text":"<p>Smart home IoT devices are often configured with hardcoded DNS servers such as Google public DNS. 98% of smart assistants and 72% of smart TVs use hardcoded Google DNS servers to resolve DNS queries instead of using the default DNS server configured at the home gateway.</p> <p>Detailed in the paper Characterizing Smart Home IoT Traffic in the Wild.</p> <p>Hardcoded DNS can be prevented with the following actions:</p> <ul> <li>Catch all network traffic on ports 53, 853 and NAT it back to the local DNS.</li> <li>Block all traffic to public DoH IPs using DoH-IP-blocklists.</li> <li>Block all public DoH domains using DoH-IP-blocklists.</li> </ul> <p>The following rules were made using OPNSense and AdGuardHome to achieve it.</p>","tags":["Network"]},{"location":"Network/hardcoded-dns/#opnsense","title":"OPNSense","text":"","tags":["Network"]},{"location":"Network/hardcoded-dns/#alias","title":"Alias","text":"<p>Navigate to Firewall &gt; Aliases and create the following aliases:</p> <pre><code>Name: NAT_Ports\nType: Ports\nContent: 53, 853\n</code></pre> <pre><code>Name: Internal\nType: Networks\nContent: 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16\n</code></pre> <pre><code>Name: Public_DNS\nType: URL IPs\nContent: https://raw.githubusercontent.com/dibdot/DoH-IP-blocklists/master/doh-ipv4.txt, https://raw.githubusercontent.com/dibdot/DoH-IP-blocklists/master/doh-ipv6.txt\n</code></pre>","tags":["Network"]},{"location":"Network/hardcoded-dns/#nat","title":"NAT","text":"<p>The NAT rule redirects all traffic on ports 53, 853 to the local DNS.</p> <p>Navigate to Firewall &gt; NAT &gt; Port Forward and create the following NAT rule:</p> <pre><code>Interface: Select all the LAN and VLAN interfaces\nProtocol: TCP/UDP\nSource: Internal (the alias we created)\nDestination / Invert: checked\nDestination: This Firewall (the local DNS, in my case AGH runs on opnsense)\nDestination port range: NAT_Ports (the alias we created)\nRedirect target IP: 192.168.0.1 (the local DNS IP, in my case AGH runs on opnsense)\nRedirect target port: NAT_Ports\n</code></pre>","tags":["Network"]},{"location":"Network/hardcoded-dns/#floating","title":"Floating","text":"<p>The floating rule blocks DoH traffic.</p> <p>Navigate to Firewall &gt; Rules &gt; Floating and create the following floating rule:</p> <pre><code>Action: Block\nInterface: Select all the interfaces\nDirection: any\nTCP/IP Version: IPv4+IPv6\nProtocol: TCP/UDP\nSource / Invert: checked\nSource: This Firewall (the local DNS, in my case AGH runs on opnsense)\nDestination: Public_DNS (the alias we created)\nDestination port range: HTTPS\n</code></pre>","tags":["Network"]},{"location":"Network/hardcoded-dns/#adguardhome","title":"AdGuardHome","text":"<p>The AdGuardHome blocklist blocks DoH domains.</p> <p>Navigate to AGH &gt; Filters &gt; DNS blocklists and add the following blocklist:</p> <pre><code>https://raw.githubusercontent.com/dibdot/DoH-IP-blocklists/master/doh-domains.txt\n</code></pre>","tags":["Network"]},{"location":"Network/hardcoded-dns/#cron","title":"Cron","text":"<p>Create a cron job to automatically update the blocklist every day.</p> <p>Navigate to System &gt; Settings &gt; Cron and add the following job:</p> <pre><code>Eabled: checked\nMinutes: 0\nHours: 0\nDay of the month: *\nMonths: *\nDays of the week: *\nCommand: Update and reload firewall aliases\n</code></pre>","tags":["Network"]},{"location":"Network/opn-arp/","title":"OPN-Arp","text":"<p>OPN-Arp on OPNSense allows you to send alerts when new devices are spotted on the network.</p> <p></p>","tags":["Network"]},{"location":"Network/opn-arp/#setup","title":"Setup","text":"<ul> <li>Install the <code>opn-arp</code> plugin via the community repo</li> <li>Enable OPN-Arp under Services &gt; OPN-Arp</li> <li>Enable Monit under Services &gt; Monit</li> <li>Add a new entry under Service Tests Settings:<ul> <li>Name: <code>MAC pair</code></li> <li>Condition: <code>content = \"MAC pair\"</code></li> <li>Action: <code>Alert</code> for an email alert or <code>Execute</code> and <code>/root/gotify.sh</code> for gotify (script below)</li> </ul> </li> <li>Add a new entry under Service Settings:<ul> <li>Name: <code>MAC_PAIR</code></li> <li>Type: <code>File</code></li> <li>Path: <code>/var/log/system/latest.log</code></li> <li>Tests: <code>MAC Pair</code></li> </ul> </li> <li>Add a new entry under Alert Settings: (only for email alerts)<ul> <li>Recipient: <code>your@email.com</code></li> <li>Mail Format: <code>From: your@email.com</code></li> </ul> </li> <li>Fill the mail server details under general (only for email alerts)</li> </ul>","tags":["Network"]},{"location":"Network/opn-arp/#gotify-alerts","title":"Gotify Alerts","text":"<ul> <li>Connect to OPNSense via SSH</li> <li>Execute <code>touch /root/gotify.sh &amp;&amp; chmod +x /root/gotify.sh</code></li> <li>Paste the following script into <code>/root/gotify.sh</code>:<pre><code>#!/usr/local/bin/bash\n\nif [[ $MONIT_DESCRIPTION =~ \"MAC pair\" ]]; then\n        ip=$(echo $MONIT_DESCRIPTION | cut -d '(' -f 2  | cut -d ')' -f 1)\n        mac=$(echo $MONIT_DESCRIPTION | cut -d '(' -f 2  | cut -d ')' -f 2)\n        host=$(host $ip | cut -d ' ' -f 5)\n        title=\"New device spotted\"\n        msg=\"IP: $ip - MAC: $mac - Hostname: $host\"\nelse\n        title=$MONIT_SERVICE\n        msg=$MONIT_DESCRIPTION\nfi\n\ncurl -X POST \"https://gotify.domain.com/message?token=yourtoken\" -F \"title=$title\" -F \"message=$msg\"\n</code></pre> </li> </ul> <ul> <li>Edit <code>gotify.domain.com</code> and <code>yourtoken</code> accordingly</li> <li>Create a file under <code>/usr/local/etc/rc.syshook.d/start/99-opnarp</code>:<pre><code>#!/bin/sh\n\nchmod +x /usr/local/etc/rc.d/opnarp\n</code></pre> </li> </ul> <ul> <li> <p>Test it by running:</p> <pre><code>echo \"&lt;29&gt;1 2022-08-29T20:16:44+03:00 router.home root 59285 - [meta sequenceId=1] New IPv4/MAC pair seen: (10.1.3.22)3a:d1:ee:bc:20:2f\" &gt;&gt; /var/log/system/latest.log\n</code></pre> </li> </ul>","tags":["Network"]},{"location":"Network/split-dns/","title":"Split DNS","text":"<p>Spilt DNS allows you to give different answers to DNS requests for internal and external users, so local requests for your server don't have to go via your router, it has several benefits:</p> <ul> <li>Faster due to not having to go through the router.</li> <li>The reverse proxy can easily differentiate between internal and external requests with allow/deny since there's no NAT.</li> <li>Things still work when the internet is down.</li> <li>Things still work when upstream DNS (Your ISP/Google/OpenDNS/etc) isn't available.</li> </ul>","tags":["Network"]},{"location":"Network/split-dns/#requirements","title":"Requirements","text":"<ul> <li>An internal reverse proxy that listens on port 80/443.</li> <li>An internal DNS resolver that supports rewrites or hosting full DNS zones.</li> </ul>","tags":["Network"]},{"location":"Network/split-dns/#popular-dns-configurations","title":"Popular DNS Configurations","text":"<p>These examples assume <code>domain.com</code> is your domain and <code>10.10.10.10</code> is your reverse proxy.</p>","tags":["Network"]},{"location":"Network/split-dns/#opnsense","title":"OPNSense","text":"<p>Navigate to Services &gt; Unbound DNS &gt; Overrides &gt; Host Overrides &gt; Add:</p> <ul> <li>Host: <code>*</code></li> <li>Domain: <code>domain.com</code></li> <li>Type: <code>A or AAAA</code></li> <li>IP: <code>10.10.10.10</code></li> </ul>","tags":["Network"]},{"location":"Network/split-dns/#pfsense","title":"PFSense","text":"<p>Navigate to Services &gt; DNS Resolver &gt; General Setting &gt; Host Overrides &gt; Add:</p> <ul> <li>Host: <code>*</code></li> <li>Domain: <code>domain.com</code></li> <li>IP Address: <code>10.10.10.10</code></li> </ul>","tags":["Network"]},{"location":"Network/split-dns/#pihole-dnsmasq","title":"Pihole &amp; dnsmasq","text":"<p>Create a file called <code>/etc/dnsmasq.d/domain.conf</code> with this contents:</p> <pre><code>address=/domain.com/10.10.10.10\n</code></pre>","tags":["Network"]},{"location":"Network/split-dns/#adguardhome","title":"AdguardHome","text":"<p>Navigate to Filters &gt; DNS rewrites &gt; Add DNS rewrite:</p> <ul> <li>Domain name: <code>*.domain.com</code></li> <li>IP Address: <code>10.10.10.10</code></li> </ul>","tags":["Network"]},{"location":"Network/split-dns/#wireguard-issues","title":"Wireguard Issues","text":"<p>When exposing a wireguard server, the wireguard subdomain should not be split or it will break the connection while roaming between wi-fi and mobile data.</p> <p>For example, you can exclude <code>wg.domain.com</code> on AdguardHome by creating another DNS rewrite of <code>wg.domain.com</code> to <code>wg.domain.com</code>, that will exclude it from the split.</p>","tags":["Network"]},{"location":"Network/split-dns/#nat-reflection-nat-loopback-hairpin-nat","title":"NAT Reflection / NAT Loopback / Hairpin NAT","text":"<p>NAT reflection is an alternative option to split DNS, which can provide some but not all of the same same benefits, it allows LAN devices to use the external IP and get port-forwarded without being NAT'd. </p> <p>It's usually a setting on specific routers that can be enabled via a checkbox.</p> <p>Note that using Cloudflare proxy (the orange cloud) or Cloudflare tunnels will bypass it and still send traffic externally.</p>","tags":["Network"]},{"location":"Network/split-dns/#neither","title":"Neither","text":"<p>Without split DNS or NAT reflection traffic goes out of your router to reach your external IP and then gets NAT'd back in, often getting blocked by the router since external traffic with a LAN IP source is seen as malicious.</p>","tags":["Network"]},{"location":"Network/split-tunnel/","title":"Split Tunnel","text":"<p>This setup allows your phone to always be connected to both your VPN provider and to your home.</p>","tags":["Network"]},{"location":"Network/split-tunnel/#tldr","title":"TLDR","text":"<p>Set the home Wireguard server to the same subnet as the IP you got from your VPN provider and split the allowed IPs with the Wireguard AllowedIPs Calculator.</p>","tags":["Network"]},{"location":"Network/split-tunnel/#requirements","title":"Requirements","text":"<ul> <li>A VPN provider that supports Wireguard</li> <li>A home Wireguard server</li> <li>An Android phone</li> <li>The official Wireguard application</li> </ul>","tags":["Network"]},{"location":"Network/split-tunnel/#vpn-provider-configuration","title":"VPN Provider Configuration","text":"<p>The VPN provider will provide you with a Wireguard config or a QR code, for example:</p> <p><code>PublicKey = aV/aFODKJH5894674CtdyhPDDFiE/qwe/1xnRM=</code> <pre><code>[Interface]\nPrivateKey = EFvrTq36k22b+DXN6788bOIeONjklb2KLVPVj/CUd3o=\nAddress = 10.22.46.77/32,fc00:bbbb:bbbb:bb01::2:d2ab/128\nDNS = 193.138.44.22\n\n[Peer]\nPublicKey = aV/aDhwG0fmp0XuvSnbmWjCtdyhPDDFiE/qwe/1xnRM=\nAllowedIPs = 0.0.0.0/0,::0/0\nEndpoint = 193.8.66.48:51820\n</code></pre></p> <p>Verify that it works by connecting the phone to it.</p>","tags":["Network"]},{"location":"Network/split-tunnel/#home-wireguard-configuration","title":"Home Wireguard Configuration","text":"<p>Set the home Wireguard server to the same subnet as the IP provided by your VPN provider.</p> <p>In this example the home Wireguard server should have this configuration:</p> <ul> <li>IP Address - <code>10.22.46.1</code></li> <li>Subnet - <code>10.22.46.0/24</code></li> </ul> <p>Create a client configuration for your phone with the same IP address, private key, and public key.</p> <p>In this example the home Wireguard server should have a client with this configuration:</p> <ul> <li>IP Address - <code>10.22.46.77/32</code></li> <li>PublicKey - <code>aV/aFODKJH5894674CtdyhPDDFiE/qwe/1xnRM=</code></li> <li>PrivateKey - <code>EFvrTq36k22b+DXN6788bOIeONjklb2KLVPVj/CUd3o=</code></li> </ul> <p>Verify that it works by connecting the phone to it.</p>","tags":["Network"]},{"location":"Network/split-tunnel/#merging-the-tunnels","title":"Merging the Tunnels","text":"<p>Edit the connection to the VPN provider &gt; Add Peer:</p> <ul> <li>Public Key - Copy the public key of the home Wireguard server.</li> <li>Endpoint - <code>your.domain.com:51820</code> (replace with your domain and Wireguard server port)</li> <li>Allowed IPs - The home network subnet, for example: <code>192.168.1.0/24</code></li> </ul> <p>Navigate to the Wireguard AllowedIPs Calculator, set Allowed IPs to <code>0.0.0.0/0, ::/0</code> and Disallowed IPs to the home network subnet, for example: <code>192.168.1.0/24</code>, click Calculate and copy the result, for example: <pre><code>0.0.0.0/1, 128.0.0.0/2, 192.0.0.0/9, 192.128.0.0/11, 192.160.0.0/13, 192.168.0.0/24, 192.168.2.0/23, 192.168.4.0/22, 192.168.8.0/21, 192.168.16.0/20, 192.168.32.0/19, 192.168.64.0/18, 192.168.128.0/17, 192.169.0.0/16, 192.170.0.0/15, 192.172.0.0/14, 192.176.0.0/12, 192.192.0.0/10, 193.0.0.0/8, 194.0.0.0/7, 196.0.0.0/6, 200.0.0.0/5, 208.0.0.0/4, 224.0.0.0/3, ::/0\n</code></pre> Paste the result into the first peer (the VPN provider peer) under Allowed IPs.</p> <p>Lastly, change the DNS servers field to the IP of the home DNS if needed (make sure the DNS address is within the Allowed IPs of the home Wireguard server peer).</p>","tags":["Network"]},{"location":"Network/split-tunnel/#example-client-config","title":"Example Client Config","text":"<pre><code>[Interface]\nAddress = 10.167.26.220/32, fc00:bbbb:bbbb:bb05::2:d8db/128\nDNS = 10.1.1.1\nPrivateKey = redacted\n\n[Peer]\nAllowedIPs = 10.1.1.0/24\nEndpoint = home.com:51820\nPublicKey = redacted\n\n[Peer]\nAllowedIPs = 0.0.0.0/5, 8.0.0.0/7, 10.0.0.0/16, 10.1.0.0/24, 10.1.2.0/23, 10.1.4.0/22, 10.1.8.0/21, 10.1.16.0/20, 10.1.32.0/19, 10.1.64.0/18, 10.1.128.0/17, 10.2.0.0/15, 10.4.0.0/14, 10.8.0.0/13, 10.16.0.0/12, 10.32.0.0/11, 10.64.0.0/10, 10.128.0.0/9, 11.0.0.0/8, 12.0.0.0/6, 16.0.0.0/4, 32.0.0.0/3, 64.0.0.0/2, 128.0.0.0/1, ::/0\nEndpoint = 193.32.127.70:51820\nPublicKey = redacted\n</code></pre>","tags":["Network"]},{"location":"Network/split-tunnel/#additional-configuration","title":"Additional Configuration","text":"","tags":["Network"]},{"location":"Network/split-tunnel/#dns-access-list","title":"DNS Access List","text":"<p>The Wireguard server subnet may need to be added to the DNS access list, for example in OPNSense under Services &gt; Unbound DNS &gt; Access Lists &gt; Add &gt; allow <code>10.22.46.0/24</code>.</p>","tags":["Network"]},{"location":"Network/split-tunnel/#reverse-proxy","title":"Reverse Proxy","text":"<p>The Wireguard server subnet may need to be added to the reverse proxy's LAN IP ranges, for example in SWAG it should be added to Allow/Deny and to Geoblock.</p>","tags":["Network"]},{"location":"Network/split-tunnel/#always-on","title":"Always-on","text":"<p>The tunnel can stay connected at all times, even when you're at home, it can be enabled under Settings &gt; Network &amp; Internet &gt; Advanced &gt; VPN &gt; Wireguard Settings &gt; Enable Always-on VPN.</p>","tags":["Network"]},{"location":"Network/split-tunnel/#troubleshoot","title":"Troubleshoot","text":"","tags":["Network"]},{"location":"Network/split-tunnel/#push-notifications-are-not-working","title":"Push notifications are not working","text":"<p>In the Wireguard app edit the tunnel configuration and add an application exclusion for Google Play services.</p>","tags":["Network"]},{"location":"Network/split-tunnel/#the-phone-battery-is-being-drained-quickly","title":"The phone battery is being drained quickly","text":"<p>Make sure that you didn't set a Persistent Keep-alive on either the server Wireguard configuration or the client tunnel configuration.</p>","tags":["Network"]},{"location":"Other/atuin/","title":"Atuin","text":"<p>Atuin replaces your existing shell history with a SQLite database, and records additional context for your commands. With this context, Atuin gives you faster and better search of your shell history.</p> <p>Atuin also syncs your shell history between all of your machines. Fully end-to-end encrypted.</p>","tags":["Other"]},{"location":"Other/atuin/#server","title":"Server","text":"<p>Change the version to the latest.</p> <pre><code>  atuin:\n    image: ghcr.io/atuinsh/atuin:v18.1.0\n    container_name: atuin\n    user: \"${PUID}:${PGID}\"\n    command: server start\n    environment:\n      ATUIN_HOST: \"0.0.0.0\"\n      ATUIN_OPEN_REGISTRATION: \"true\"\n      ATUIN_DB_URI: postgres://${MYUSER}:${MYPASSWORD}@atuindb/atuin\n    volumes:\n      - \"${APPSDIR}/atuin/config:/config\"\n    restart: always\n  atuindb:\n    image: postgres:14-alpine\n    container_name: atuindb\n    user: \"${PUID}:${PGID}\"\n    environment:\n      POSTGRES_USER: ${MYUSER}\n      POSTGRES_PASSWORD: ${MYPASSWORD}\n      POSTGRES_DB: atuin\n    volumes:\n      - ${APPSDIR}/atuin/db:/var/lib/postgresql/data\n    restart: always\n</code></pre>","tags":["Other"]},{"location":"Other/atuin/#client-installation","title":"Client Installation","text":"","tags":["Other"]},{"location":"Other/atuin/#linux","title":"Linux","text":"<pre><code>bash &lt;(curl --proto '=https' --tlsv1.2 -sSf https://setup.atuin.sh)\n</code></pre>","tags":["Other"]},{"location":"Other/atuin/#termux","title":"Termux","text":"<pre><code>pkg install atuin\n</code></pre>","tags":["Other"]},{"location":"Other/atuin/#opnsense","title":"OPNSense","text":"<p>Enable the freebsd repo in <code>/usr/local/etc/pkg/repos/FreeBSD.conf</code> and run:</p> <pre><code>pkg update\npkg install atuin\n</code></pre>","tags":["Other"]},{"location":"Other/atuin/#configuration","title":"Configuration","text":"<p>Run:</p> <pre><code>echo 'eval \"$(atuin init zsh)\"' &gt;&gt; ~/.zshrc\natuin gen-completions --shell zsh --out-dir $HOME\n</code></pre> <p>Edit <code>~/.config/atuin/config.toml</code>:</p> <pre><code>dialect = \"uk\"\nauto_sync = true\nupdate_check = true\nsync_address = \"https://atuin.domain.com\"\nsync_frequency = \"0\"\nfilter_mode = \"global\"\nworkspaces = true\nfilter_mode_shell_up_key_binding = \"host\"\nstyle = \"compact\"\nenter_accept = true\n\n[sync]\nrecords = true\n</code></pre>","tags":["Other"]},{"location":"Other/atuin/#initialization","title":"Initialization","text":"<pre><code>atuin register -u &lt;USERNAME&gt; -e &lt;EMAIL&gt;\natuin import auto\natuin sync -f\n</code></pre>","tags":["Other"]},{"location":"Other/atuin/#new-machine","title":"New Machine","text":"<pre><code>atuin login -u &lt;USERNAME&gt;\natuin import auto\natuin sync -f\n</code></pre>","tags":["Other"]},{"location":"Other/atuin/#usage","title":"Usage","text":"<p>Atuin documentation</p>","tags":["Other"]},{"location":"Other/brave/","title":"Brave","text":"","tags":["Other"]},{"location":"Other/brave/#settings","title":"Settings","text":"<p>brave://flags</p> <ul> <li>Enable First Party Storage Cleanup support: enabled</li> <li>Enable Brave Wallet: disabled</li> <li>Strict-Origin-Isolation: enabled</li> </ul> <p>Get started</p> <ul> <li>Continue where you left off: on</li> <li>New tab page shows: homepage</li> </ul> <p>Appearance</p> <ul> <li>Show home button: on</li> <li>Show bookmarks button: on</li> <li>Show bookmarks: always</li> <li>Show news button: off</li> <li>Show brave rewards button: off</li> <li>Show brave wallet button: off</li> <li>Show sidebar butoon: off</li> <li>Always show full URLs: on</li> </ul> <p>Shields</p> <ul> <li>Trackers &amp; ads blocking: aggressive</li> <li>Upgrade connections to HTTPS: strict</li> <li>Block scripts: off</li> <li>Block fingerprinting: strict</li> <li>Block cookies: only cross-site</li> <li>Forget me when I close this site: on</li> <li>Content filtering<ul> <li>EasyList Cookie</li> <li>Fanboy's Annoyances</li> <li>Fanboy's Social</li> <li>Fanboy's Anti-Newsletter</li> <li>Fanboy's Mobile Notifications</li> <li>Fanboy's Anti-chat Apps</li> <li>uBlock Annoyances</li> <li>Bypass Paywalls Clean Filters</li> </ul> </li> <li>Show the number of blocked items on the Shields icon: on</li> <li>Auto-redirect AMP pages: on</li> <li>Auto redirect tracking URLs: on</li> <li>Prevent sites from fingerprinting me based on my language preferences: on</li> <li>Allow use of third-party cookies for legacy google sign-in: off</li> <li>Allow facebook logins and embedded posts: off</li> <li>Allow twitter embedded tweets: off</li> <li>Allow linkedin embedded posts: off</li> </ul> <p>Privacy and security</p> <ul> <li>WebRTC IP handling policy: disable</li> <li>Use google services for push messaging: off</li> <li>Allow privacy-preserving product analytics: off</li> <li>Automatically send daily usage ping to brave: off</li> <li>Automatically send diagnostic reports: off</li> <li>Clear browsing data<ul> <li>On exit: browsing history, download history, passwords, autofill</li> </ul> </li> <li>Third-party cookies<ul> <li>Block third-party cookies: enabled</li> <li>Send a \"do not track\" request with your browsing traffic: off</li> </ul> </li> <li>Security<ul> <li>Standard protection: enabled</li> <li>Use secure DNS: disabled</li> <li>Manage V8 security<ul> <li>Sites can use the V8 optimizer: disabled</li> </ul> </li> </ul> </li> <li>Private window with tor: off</li> </ul> <p>Web3</p> <ul> <li>Default ethereum wallet: extensions (no fallback)</li> <li>Default solana wallet: extensions (no fallback)</li> <li>Enable NFT discovery: off</li> <li>Automatically pin NFTs: off</li> <li>Method to resolve IPFS: off</li> <li>IPFS public gateway fallback: off</li> <li>Automatically redirect requests for IPFS network resources to the configured gateway: off</li> <li>IPFS companion: off</li> </ul> <p>Leo</p> <ul> <li>Show Leo icon in the sidebar: off</li> <li>Show Leo in the context menu on websites: off</li> </ul> <p>Search engine</p> <ul> <li>Normal Window - Search engine used in the address bar: searx</li> <li>Private Window - Search engine used in the address bar: searx</li> <li>Improve search suggestions: off</li> <li>Web discovery project: off</li> <li>Index other search engines: off</li> <li>Manage search engines: add searx and piped</li> </ul> <p>Extensions</p> <ul> <li>Allow google login for extensions: off</li> <li>Hangouts: off</li> <li>Media router: off</li> <li>Webtorrent: off</li> <li>Widevine: off</li> <li>Manage extensions<ul> <li>Bitwarden<ul> <li>Auto-fill<ul> <li>Show auto-fill menu on form fields: when field is selected</li> <li>Make bitwarden your default password manager: on</li> <li>Auto-fill on page load: off</li> <li>Default URI match detection: host</li> </ul> </li> <li>Vault timeout action: on browser restart</li> <li>Options<ul> <li>Everything: on</li> </ul> </li> </ul> </li> <li>Dark reader</li> <li>Floccus<ul> <li>Server target: /Bookmarks</li> </ul> </li> <li>Redirector: import</li> <li>SmartProxy: import</li> </ul> </li> </ul> <p>Autofill and passwords</p> <ul> <li>All: off</li> </ul> <p>System</p> <ul> <li>Continue running background apps when Brave is closed: off</li> <li>Use graphics acceleration when available: on</li> </ul>","tags":["Other"]},{"location":"Other/phone/","title":"Phone","text":"","tags":["Other"]},{"location":"Other/phone/#periodic-phone-wipe-notes","title":"Periodic Phone Wipe Notes","text":"<p>I got into the habit of wiping my phone every 6 months (takes about an hour) in order to:</p> <ul> <li>Streamline the process</li> <li>Validate the backups</li> <li>Re-examine which apps should stay</li> <li>Remove leftover data</li> <li>Figure out the pains and find alternatives</li> </ul> <p>My phone is a Pixel 8 with GrapheneOS, it has an always-on VPN, and a lot of self-hosting related apps.</p>","tags":["Other"]},{"location":"Other/phone/#backup","title":"Backup","text":"<ul> <li>Snapshot<ul> <li>Homepages</li> <li>Toggles</li> <li>App drawer</li> </ul> </li> <li>Export<ul> <li>Wireguard</li> <li>Gadgetbridge</li> <li>Lawnchair</li> <li>Ntfy</li> <li>Termux</li> </ul> </li> <li>Backup the entire phone to the PC</li> </ul>","tags":["Other"]},{"location":"Other/phone/#install","title":"Install","text":"<ul> <li>Follow the official documentation.</li> </ul>","tags":["Other"]},{"location":"Other/phone/#configuration","title":"Configuration","text":"<ul> <li>Copy exports and snapshots back</li> <li>Initial configuration<ul> <li>Network &amp; Internet<ul> <li>Private DNS: quietsy.dns.domain.tld</li> <li>Internet connectivity checks: off</li> <li>Internet<ul> <li>Network preferences<ul> <li>Turn on wi-fi automatically: off</li> <li>Notify for public networks: off</li> </ul> </li> </ul> </li> <li>SIMs<ul> <li>VoLTE: off</li> <li>Preferred network type: LTE</li> <li>Allow 2G: off</li> </ul> </li> <li>VPN<ul> <li>Always-on VPN: on</li> <li>Block connections without VPN: off</li> </ul> </li> </ul> </li> <li>Connected devices<ul> <li>Connection preferences<ul> <li>NFC: off</li> <li>Printing: off</li> </ul> </li> </ul> </li> <li>Apps<ul> <li>Sandboxed Google Play<ul> <li>Reroute location requests to the OS: on</li> <li>Google location accuracy: off</li> </ul> </li> <li>Special app access<ul> <li>Special access to hardware accelerators for Google apps: on</li> <li>Unrestricted mobile data: Linphone, FindMyDevice</li> </ul> </li> </ul> </li> <li>Notifications<ul> <li>Wireless emergency alerts: off</li> <li>Hide silent notifications in status bar: on</li> <li>Notification dot on app icon: on</li> <li>Enhanced notifications: on</li> <li>Notifications on lock screen: off</li> <li>Bubbles: on</li> </ul> </li> <li>Sound &amp; vibration<ul> <li>Spatial audio: off</li> <li>Vibration &amp; haptics: on</li> <li>Dial pad tones: off</li> <li>Screen locking sound: off</li> <li>Charging sounds and vibrations: off</li> <li>Tap &amp; click sounds: off</li> <li>Always show icon when in vibrate mode: on</li> <li>Set ringtone and notification sound</li> </ul> </li> <li>Display<ul> <li>Adaptive brightness: on</li> <li>Lock screen<ul> <li>Privacy: don't show notifications at all</li> <li>Shortcuts<ul> <li>Flashlight</li> <li>Camera</li> </ul> </li> <li>Dynamic clock: on</li> <li>Always show time and info: off</li> <li>Tap to check phone: on</li> <li>Lift to check phone: off</li> <li>Wake screen for notifications: on</li> </ul> </li> <li>Screen timeout: 1 minute</li> <li>Dark theme: on</li> <li>Night light: off</li> <li>Auto-rotate screen: off</li> <li>Smooth display: off</li> <li>Increase touch sensitivity: off</li> <li>Screen saver: off</li> </ul> </li> <li>Wallpaper &amp; style<ul> <li>Set wallpaper</li> <li>Show notifications on the lock screen: off</li> </ul> </li> <li>Battery<ul> <li>Battery saver: off</li> <li>Charging optimization: limit to 80%</li> <li>Battery percentage: on</li> <li>Battery share: off</li> </ul> </li> <li>System<ul> <li>Keyboard<ul> <li>Futo<ul> <li>Keyboard &amp; Typing<ul> <li>Show number row: on</li> <li>Show action/suggestions bar: on</li> <li>Automatic spaces mode: automatically insert spaces only after inserting suggestions</li> <li>Swipe typing: on</li> <li>Auto-correction: on</li> <li>Auto-capitalization: on</li> <li>Double-space period: on</li> <li>Sound on keypress: off</li> <li>Popup on keypress: on</li> <li>Vibrate on keypress: on</li> <li>Vibration: minimum</li> <li>Clipboard history: on</li> </ul> </li> </ul> </li> </ul> </li> <li>Gestures<ul> <li>Quickly open camera: on</li> <li>Navigation mode: gesture navigation</li> <li>Tap to check phone: on</li> <li>Lift to check phone: off</li> </ul> </li> <li>Date &amp; time<ul> <li>Use 24-hour format: on</li> </ul> </li> <li>System updates<ul> <li>Require battery above warning: on</li> <li>Require device to be charging: off</li> <li>Automatic reboot: on</li> </ul> </li> <li>Developer options<ul> <li>OEM unlocking: off</li> <li>USB debugging: off</li> <li>Wireless debugging: off</li> <li>Mobile data always active: off</li> <li>Disable bluetooth LE audio hardware offload: on</li> </ul> </li> </ul> </li> <li>Security &amp; privacy<ul> <li>Security<ul> <li>Screen lock<ul> <li>Scramble PIN input layout: on</li> <li>Enhanced PIN privacy: on</li> <li>Lock after screen timeout: 5 seconds</li> <li>Power button instantly locks: on</li> <li>Allow camera access when locked: on</li> </ul> </li> <li>Fingerprint unlock<ul> <li>Add both hands</li> <li>Use for screen unlocking: on</li> </ul> </li> </ul> </li> <li>Privacy<ul> <li>Camera access: on</li> <li>Microphone access: on</li> <li>Show clipboard access: on</li> <li>Show passwords: off</li> <li>Allow sensors permission to apps by default: off</li> <li>Save screenshot timestamp to EXIF: off</li> <li>Notifications on lock screen: all</li> <li>Show media on lock screen: on</li> </ul> </li> <li>Exploit protection<ul> <li>Auto reboot: 18 hours</li> <li>USB-C port: charging-only when locked, except before first unlock</li> <li>Hardened memory allocator: disable camera</li> <li>Memory tagging: check</li> <li>Native code debugging: check, disable protonmail</li> <li>Webview JIT: check, disable PDF viewer</li> <li>DCL via memory: check, allow google play services, vanadium</li> <li>DCL via storage: off</li> <li>Secure app spawning: on</li> </ul> </li> <li>More privacy &amp; security<ul> <li>Allow sensors permission to apps by default: off</li> <li>Notify about system process crashes: on</li> <li>Automatic exploit protection compatibility mode: on</li> </ul> </li> </ul> </li> <li>Location<ul> <li>Location services<ul> <li>Wi-fi scanning: off</li> <li>Bluetooth scanning: off</li> </ul> </li> </ul> </li> <li>Safety &amp; emergency<ul> <li>Wireless emergency alerts: off</li> </ul> </li> </ul> </li> </ul>","tags":["Other"]},{"location":"Other/phone/#apps","title":"Apps","text":"<p>App store priority for installation: accrescent &gt; obtainium + appverifier (github) &gt; obtainium (f-droid)</p> <ul> <li>Appverifier<ul> <li>Permissions: none</li> <li>Background usage: optimized</li> </ul> </li> <li>Audiobookshelf<ul> <li>Permissions: network</li> <li>Background usage: optimized</li> </ul> </li> <li>Auditor<ul> <li>Enable remote verification: on</li> <li>Permissions: network, notifications</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Bitwarden (password manager)<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Breezy weather<ul> <li>Permissions: network, notifications, sensors</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Davx5 (sync contacts)<ul> <li>Permissions: calendar, contacts, network, notifications</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Finamp (music)<ul> <li>Permissions: network</li> <li>Background usage: optimized</li> </ul> </li> <li>Findmydevice<ul> <li>Permissions: camera, contacts, location, network, notifications, phone, sensors</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Floccus (bookmark sync)<ul> <li>Permissions: network</li> <li>Background usage: off</li> </ul> </li> <li>Gadgetbridge (cloudless gadgets)<ul> <li>Permissions: calendar, call logs, contacts, location, nearby devices, network, notifications, phone, sensors, sms</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Immich (photos)<ul> <li>Permissions: network</li> <li>Background usage: optimized</li> </ul> </li> <li>Jellyfin (media)<ul> <li>Permissions: network</li> <li>Background usage: unrestricted</li> </ul> </li> <li>LibreTube (youtube)<ul> <li>Permissions: network</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Linphone (voip)<ul> <li>Permissions: contacts, microphone, network, notifications, phone, sensors</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Molly<ul> <li>Permissions: contacts, network, notifications, phone, sensors</li> <li>Background usage: optimized</li> </ul> </li> <li>Nextcloud news (rss reader)<ul> <li>Permissions: network</li> <li>Background usage: none</li> </ul> </li> <li>Nextcloud (self-hosted cloud)<ul> <li>Permissions: network, notifications</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Nextcloud notes<ul> <li>Permissions: network</li> <li>Background usage: none</li> </ul> </li> <li>Ntfy (notifications)<ul> <li>Permissions: network, notifications</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Obtainium<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Organic maps (navigation)<ul> <li>Permissions: location, network, sensors</li> <li>Background usage: none</li> </ul> </li> <li>OSS document scanner<ul> <li>Permissions: none</li> <li>Background usage: optimized</li> </ul> </li> <li>Proton calendar<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Proton mail<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>SimpleLogin<ul> <li>Permissions: network</li> <li>Background usage: none</li> </ul> </li> <li>Termux<ul> <li>Permissions: files (storage scope /backup/), network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Vanadium (browser)<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Wireguard (vpn)<ul> <li>Permissions: network</li> <li>Background usage: optimized</li> </ul> </li> <li>Configure all apps</li> <li>Set folders to auto upload to nextcloud<ul> <li>Photos</li> <li>Videos</li> <li>Call recordings</li> <li>Snapshots</li> <li>Backup</li> </ul> </li> </ul>","tags":["Other"]},{"location":"Other/phone/#private-space","title":"Private Space","text":"<p>For apps that require google play store.</p> <ul> <li>Discord<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Google Play Services (sandboxed)<ul> <li>Permissions: network</li> <li>Background usage: unrestricted</li> </ul> </li> <li>Google Play Store (sandboxed)<ul> <li>Permissions: network, notifications</li> <li>Background usage: optimized</li> </ul> </li> <li>Google Services Framework (sandboxed)<ul> <li>Permissions: network</li> <li>Background usage: optimized</li> </ul> </li> <li>Wireguard (vpn)<ul> <li>Permissions: network</li> <li>Background usage: optimized</li> </ul> </li> </ul>","tags":["Other"]},{"location":"Other/setup/","title":"Setup","text":"","tags":["Other"]},{"location":"Other/setup/#diagram-template","title":"Diagram Template","text":"<p>Use the following template to create a diagram of your setup.</p> <p></p>","tags":["Other"]},{"location":"Other/setup/#requirements","title":"Requirements","text":"<p>The online draw.io or the self-hosted draw.io, here is an example compose: <pre><code>  drawio:\n    image: jgraph/drawio:alpine\n    container_name: drawio\n    ports:\n        - 8080:8080\n    restart: always\n</code></pre></p>","tags":["Other"]},{"location":"Other/setup/#download","title":"Download","text":"","tags":["Other"]},{"location":"Other/smartd/","title":"Smartd","text":"<p><code>smartd</code> is a daemon that monitors the Self-Monitoring, Analysis and Reporting Technology (SMART) system built into many ATA-3 and later ATA, IDE and SCSI-3 hard drives. The purpose of SMART is to monitor the reliability of the hard drive and predict drive failures, and to carry out different types of drive self-tests.</p>","tags":["Other"]},{"location":"Other/smartd/#installation","title":"Installation","text":"<pre><code>sudo apt install smartmontools\n</code></pre>","tags":["Other"]},{"location":"Other/smartd/#configuration","title":"Configuration","text":"<p>Add the following to <code>/etc/smartmontools/smartd.conf</code>:</p> <pre><code>DEVICESCAN -a -S on -s (S/../.././03|L/../01/./02) -W 10,50,60 -m &lt;nomailer&gt; -M exec /home/user/ntfy.sh -M test\n</code></pre> <ul> <li><code>-a</code> - Equivalent to turning on all of the following Directives: '-H' to check the SMART health status, '-f' to report failures of Usage (rather than Prefail) Attributes, '-t' to track changes in both Prefailure and Usage Attributes, '-l error' to report increases in the number of ATA errors, '-l selftest' to report increases in the number of Self-Test Log errors, '-l selfteststs' to report changes of Self-Test execution status, '-C 197' to report nonzero values of the current pending sector count, and '-U 198' to report nonzero values of the offline pending sector count.</li> <li><code>-S on</code> - Enables or disables Attribute Autosave when smartd starts up and has no further effect.</li> <li><code>-s</code> - Run Self-Tests or Offline Immediate Tests, at scheduled times.</li> <li><code>S/../.././03</code> - Runs a short test daily at 3AM.</li> <li><code>L/../01/./02</code> - Runs a long test on the first of every month at 2AM.</li> <li><code>-W 10,50,60</code> - Tracks disk temperatures and alerts if they rise too quickly or hit a high limit. The following will log changes of 10 degrees or more, log when temp reaches 50 degrees, and log/email a warning when temp reaches 60.</li> <li><code>-m &lt;nomailer&gt; -M exec /home/user/ntfy.sh</code> - Run a shell script instead of the default mail command for alerts.</li> <li><code>-M test</code> - Test the notification script, remove after testing.</li> </ul> <p>Add the following to <code>/home/user/ntfy.sh</code>, replace the domain and topic:</p> <pre><code>#!/bin/bash\n\n/usr/bin/curl -Ls -H \"Title: $SMARTD_SUBJECT\" -d \"$SMARTD_FAILTYPE Device: $SMARTD_DEVICE Time: $SMARTD_TFIRST Message: $SMARTD_FULLMESSAGE\" https://ntfy.domain.com/Topic\n</code></pre> <p>Restart to test the alert:</p> <pre><code>chmod +x /home/user/ntfy.sh\nsudo systemctl restart smartd\n</code></pre> <p>Remove <code>-M test</code> from <code>smartd.conf</code> if everything works, and restart <code>smartd</code> again.</p>","tags":["Other"]},{"location":"Other/tmux/","title":"Tmux","text":"","tags":["Other"]},{"location":"Other/tmux/#getting-started","title":"Getting Started","text":"<p>tmux is a terminal multiplexer for Unix-like operating systems. It allows multiple terminal sessions to be accessed simultaneously in a single window. It is useful for running more than one command-line program at the same time. It can also be used to detach processes from their controlling terminals, allowing SSH sessions to remain active without being visible.</p>","tags":["Other"]},{"location":"Other/tmux/#installation","title":"Installation","text":"","tags":["Other"]},{"location":"Other/tmux/#osx","title":"OSx","text":"<p><code>brew install tmux reattach-to-user-namespace</code></p>","tags":["Other"]},{"location":"Other/tmux/#enable-copypaste","title":"Enable Copy/Paste","text":"<p>iTerm2 &gt; Preferences &gt; General &gt; Selection &gt; Applications in terminal may access clipboard</p>","tags":["Other"]},{"location":"Other/tmux/#debian-ubuntu","title":"Debian / Ubuntu","text":"<p><code>sudo apt install tmux xsel</code></p>","tags":["Other"]},{"location":"Other/tmux/#install-tpm","title":"Install TPM","text":"<p><code>git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm</code></p>","tags":["Other"]},{"location":"Other/tmux/#initial-configuration","title":"Initial Configuration","text":"<p>Copy the following to <code>~/.tmux.conf</code></p> <pre><code>set -g mouse on\n\nunbind-key C-b\nunbind-key C-x\nset-option -g prefix C-a\nbind C-x setw synchronize-panes\nbind-key h split-window -h\nbind-key v split-window -v\n\nset -g status-justify \"centre\"\nset -g set-titles on\nset -g base-index 1\nset -g status-bg black\nset -g status-fg white\nsetw -g automatic-rename on\nsetw -g window-status-current-format \"#{?pane_synchronized,#[bg=red],#[fg=white, bg=blue]} #I #W #[fg=blue, bg=black]\"\n\nset -g @plugin \"tmux-plugins/tpm\"\nset -g @plugin \"tmux-plugins/tmux-sensible\"\nset -g @plugin \"tmux-plugins/tmux-resurrect\"\nset -g @plugin \"tmux-plugins/tmux-continuum\"\nset -g @plugin \"tmux-plugins/tmux-yank\"\nset -g @yank_selection_mouse \"clipboard\"\nset -g @resurrect-processes \":all:\"\nset -g @resurrect-capture-pane-contents \"on\"\nrun \"~/.tmux/plugins/tpm/tpm\"\n</code></pre>","tags":["Other"]},{"location":"Other/tmux/#commands","title":"Commands","text":"<pre><code>tmux                          start a new session\ntmux ls                       list all sessions\ntmux a                        attach to an existing session\ntmux a -t &lt;name&gt;              attach to a named session\ntmux new -s &lt;name&gt;            start a new named session\ntmux kill-session -t &lt;name&gt;   kill a named session\ntmux kill-server              kill all sessions\n</code></pre>","tags":["Other"]},{"location":"Other/tmux/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p>The modifier prefix has been changed from the default <code>ctrl-b</code> to <code>ctrl-a</code> which is more convenient.</p> <p>Use the modifier prefix <code>ctrl-a</code> with these keyboard shortcuts.</p> <pre><code>?             list shortcuts                         \nR             reload the configuration               \nI             install new pluginx                    \nd             detach the session                     \nh             split horizontally                     \nv             split vertically                       \nc             create a new window                    \np             switch to the previous window          \nn             switch to the next window              \nw             list the windows                       \n1-9           switch to the window number            \n,             rename the window                      \n$             rename the session                     \nctrl-s        save the environment to the disk       \nctrl-r        restore the environment from the disk  \narrows        switch between panes                   \nctrl+arrows   resize pane                            \nspace         switch pane layout                     \nz             maximize/minimize pane                 \nctrl-x        synchronize panes                     \n</code></pre>","tags":["Other"]},{"location":"Other/tmux/#automation-example","title":"Automation Example","text":"<pre><code>tmux new-window -n status\ntmux split-window -h\ntmux select-pane -t 0\ntmux send-keys \"htop\" C-m\ntmux split-window -v\ntmux select-pane -t 1\ntmux send-keys \"docker stats\" C-m\ntmux select-pane -t 2\n</code></pre>","tags":["Other"]},{"location":"Other/tmux/#convenient-aliases","title":"Convenient Aliases","text":"<p>Copy the following to <code>~/.zshrc</code></p> <pre><code>alias t='tmux'\nalias ts='tmux new -s'\nalias tks='tmux kill-session -t'\nalias tka='tmux kill-server'\n</code></pre>","tags":["Other"]},{"location":"Other/tmux/#links","title":"Links","text":"<p>Find more ways to use Tmux - Awesome Tmux</p>","tags":["Other"]},{"location":"Other/zfs/","title":"ZFS","text":"<p>The following creates a zfs pool with 2 mirrors of 2 disks each, with:</p> <ul> <li>LZ4 compression</li> <li>Linux ACLs</li> <li>Larger record size for media</li> <li>Snapshots with a retention policy:<ul> <li>4 every 15 minutes in the last hour</li> <li>24 every hour in the last day</li> <li>31 every day in the last month</li> <li>8 every week in the last 2 months</li> <li>12 every month in the last year (disabled for <code>/mnt/pool/media</code>)</li> </ul> </li> <li>Scrub reports and alerts sent to ntfy</li> </ul>","tags":["Other"]},{"location":"Other/zfs/#installation","title":"Installation","text":"<pre><code>sudo apt install zfsutils-linux zfs-auto-snapshot\n</code></pre>","tags":["Other"]},{"location":"Other/zfs/#creation","title":"Creation","text":"<p>Find the IDs of the disks you want to use for the zfs pool:</p> <pre><code>sudo lsblk -o NAME,SIZE,SERIAL,LABEL,FSTYPE\nNAME          SIZE SERIAL          LABEL FSTYPE\nsda          18.2T 8LG7V8BA\nsdb          14.6T 2CGREXTB\nsdc          18.2T 8LG87T5A\nsdd          14.6T 2CGPPSGB\n</code></pre> <p>Decide on a layout create the zfs pool using the disk IDs:</p> <pre><code>sudo mkdir -p /mnt/pool\nsudo zpool create -o ashift=12 -m /mnt/pool pool mirror /dev/disk/by-id/ata-WDC_WUH722020BLE6L4_8LG7V8BA /dev/disk/by-id/ata-WDC_WUH722020BLE6L4_8LG87T5A mirror /dev/disk/by-id/ata-WDC_WUH721816ALE6L4_2CGREXTB /dev/disk/by-id/ata-WDC_WUH721816ALE6L4_2CGPPSGB\n</code></pre>","tags":["Other"]},{"location":"Other/zfs/#configuration","title":"Configuration","text":"<p>Set the pool configuration:</p> <pre><code>sudo zfs set compression=lz4 pool\nsudo zfs set acltype=posixacl pool\nsudo zfs set xattr=sa pool\nsudo zfs set aclinherit=passthrough pool\nsudo zfs set atime=off pool\n</code></pre> <p>Create a filesystem under <code>/mnt/pool/media</code> to configure it for media (larger record size and no monthly snapshots):</p> <pre><code>sudo zfs create pool/media\nsudo zfs set recordsize=1M pool/media\nsudo zfs set com.sun:auto-snapshot:monthly=false pool/media\n</code></pre>","tags":["Other"]},{"location":"Other/zfs/#alerts","title":"Alerts","text":"<p>Pull the latest zed scripts that have ntfy support:</p> <pre><code>cd /etc/zfs/zed.d/\nsudo mv /etc/zfs/zed.d/zed-functions.sh /etc/zfs/zed.d/zed-functions.sh.bak\nsudo mv /etc/zfs/zed.d/zed.rc /etc/zfs/zed.d/zed.rc.bak\nsudo wget https://raw.githubusercontent.com/openzfs/zfs/master/cmd/zed/zed.d/zed-functions.sh\nsudo wget https://raw.githubusercontent.com/openzfs/zfs/master/cmd/zed/zed.d/zed.rc\nsudo chmod 0644 /etc/zfs/zed.d/zed-functions.sh\nsudo chmod 0600 /etc/zfs/zed.d/zed.rc\n</code></pre> <p>Edit <code>/etc/zfs/zed.d/zed.rc</code> and set the following:</p> <pre><code>ZED_NOTIFY_VERBOSE=1\nZED_NTFY_TOPIC=\"zfs\"\nZED_NTFY_URL=\"https://ntfy.domain.com\"\n</code></pre> <p>Restart zed:</p> <pre><code>sudo systemctl daemon-reload\nsudo systemctl restart zed\n</code></pre> <p>Test the alerts:</p> <pre><code>cd /tmp\ndd if=/dev/zero of=sparse_file bs=1 count=0 seek=512M\nzpool create test /tmp/sparse_file\nzpool scrub test\n</code></pre> <p>Remove the test file:</p> <pre><code>zpool export test\nrm sparse_file\n</code></pre>","tags":["Other"]}]}